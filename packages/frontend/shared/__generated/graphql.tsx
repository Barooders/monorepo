export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]?: Maybe<T[SubKey]>;
};
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]: Maybe<T[SubKey]>;
};
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  AggregateName: any;
  BrandRating: any;
  CheckoutStatus: any;
  CollectionType: any;
  Condition: any;
  Currency: any;
  CustomerScoring: any;
  DisputeReason: any;
  DisputeStatus: any;
  EventName: any;
  FulfillmentOrderStatus: any;
  FulfillmentStatus: any;
  OrderStatus: any;
  PaymentAccountType: any;
  PaymentProvider: any;
  PaymentSolutionCode: any;
  PaymentStatusType: any;
  PriceOfferStatus: any;
  ProductNotation: any;
  ProductStatus: any;
  ReturnStatus: any;
  ShipmentTimeframe: any;
  ShippingSolution: any;
  ShippingType: any;
  bigint: any;
  bytea: any;
  citext: any;
  date: any;
  float8: any;
  jsonb: any;
  shopify_Color: any;
  shopify_DateTime: any;
  shopify_Decimal: any;
  shopify_HTML: any;
  shopify_JSON: any;
  shopify_URL: any;
  shopify_UnsignedInt64: any;
  timestamp: any;
  timestamptz: any;
  uuid: any;
};

/** Boolean expression to compare columns of type "AggregateName". All fields are combined with logical 'AND'. */
export type AggregateName_Comparison_Exp = {
  _eq: InputMaybe<Scalars['AggregateName']>;
  _gt: InputMaybe<Scalars['AggregateName']>;
  _gte: InputMaybe<Scalars['AggregateName']>;
  _in: InputMaybe<Array<Scalars['AggregateName']>>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  _lt: InputMaybe<Scalars['AggregateName']>;
  _lte: InputMaybe<Scalars['AggregateName']>;
  _neq: InputMaybe<Scalars['AggregateName']>;
  _nin: InputMaybe<Array<Scalars['AggregateName']>>;
};

/** Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'. */
export type Boolean_Comparison_Exp = {
  _eq: InputMaybe<Scalars['Boolean']>;
  _gt: InputMaybe<Scalars['Boolean']>;
  _gte: InputMaybe<Scalars['Boolean']>;
  _in: InputMaybe<Array<Scalars['Boolean']>>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  _lt: InputMaybe<Scalars['Boolean']>;
  _lte: InputMaybe<Scalars['Boolean']>;
  _neq: InputMaybe<Scalars['Boolean']>;
  _nin: InputMaybe<Array<Scalars['Boolean']>>;
};

/** Boolean expression to compare columns of type "BrandRating". All fields are combined with logical 'AND'. */
export type BrandRating_Comparison_Exp = {
  _eq: InputMaybe<Scalars['BrandRating']>;
  _gt: InputMaybe<Scalars['BrandRating']>;
  _gte: InputMaybe<Scalars['BrandRating']>;
  _in: InputMaybe<Array<Scalars['BrandRating']>>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  _lt: InputMaybe<Scalars['BrandRating']>;
  _lte: InputMaybe<Scalars['BrandRating']>;
  _neq: InputMaybe<Scalars['BrandRating']>;
  _nin: InputMaybe<Array<Scalars['BrandRating']>>;
};

/** columns and relationships of "Checkout" */
export type Checkout = {
  __typename?: 'Checkout';
  /** An array relationship */
  Checkout_Payments: Array<Payment>;
  /** An aggregate relationship */
  Checkout_Payments_aggregate: Payment_Aggregate;
  cartId: Scalars['String'];
  createdAt: Scalars['timestamp'];
  id: Scalars['String'];
  status: Scalars['CheckoutStatus'];
};

/** columns and relationships of "Checkout" */
export type CheckoutCheckout_PaymentsArgs = {
  distinct_on: InputMaybe<Array<Payment_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Payment_Order_By>>;
  where: InputMaybe<Payment_Bool_Exp>;
};

/** columns and relationships of "Checkout" */
export type CheckoutCheckout_Payments_AggregateArgs = {
  distinct_on: InputMaybe<Array<Payment_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Payment_Order_By>>;
  where: InputMaybe<Payment_Bool_Exp>;
};

/** Boolean expression to compare columns of type "CheckoutStatus". All fields are combined with logical 'AND'. */
export type CheckoutStatus_Comparison_Exp = {
  _eq: InputMaybe<Scalars['CheckoutStatus']>;
  _gt: InputMaybe<Scalars['CheckoutStatus']>;
  _gte: InputMaybe<Scalars['CheckoutStatus']>;
  _in: InputMaybe<Array<Scalars['CheckoutStatus']>>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  _lt: InputMaybe<Scalars['CheckoutStatus']>;
  _lte: InputMaybe<Scalars['CheckoutStatus']>;
  _neq: InputMaybe<Scalars['CheckoutStatus']>;
  _nin: InputMaybe<Array<Scalars['CheckoutStatus']>>;
};

/** aggregated selection of "Checkout" */
export type Checkout_Aggregate = {
  __typename?: 'Checkout_aggregate';
  aggregate: Maybe<Checkout_Aggregate_Fields>;
  nodes: Array<Checkout>;
};

/** aggregate fields of "Checkout" */
export type Checkout_Aggregate_Fields = {
  __typename?: 'Checkout_aggregate_fields';
  count: Scalars['Int'];
  max: Maybe<Checkout_Max_Fields>;
  min: Maybe<Checkout_Min_Fields>;
};

/** aggregate fields of "Checkout" */
export type Checkout_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Checkout_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "Checkout". All fields are combined with a logical 'AND'. */
export type Checkout_Bool_Exp = {
  Checkout_Payments: InputMaybe<Payment_Bool_Exp>;
  Checkout_Payments_aggregate: InputMaybe<Payment_Aggregate_Bool_Exp>;
  _and: InputMaybe<Array<Checkout_Bool_Exp>>;
  _not: InputMaybe<Checkout_Bool_Exp>;
  _or: InputMaybe<Array<Checkout_Bool_Exp>>;
  cartId: InputMaybe<String_Comparison_Exp>;
  createdAt: InputMaybe<Timestamp_Comparison_Exp>;
  id: InputMaybe<String_Comparison_Exp>;
  status: InputMaybe<CheckoutStatus_Comparison_Exp>;
};

/** unique or primary key constraints on table "Checkout" */
export enum Checkout_Constraint {
  /** unique or primary key constraint on columns "id" */
  CheckoutPkey = 'Checkout_pkey',
}

/** input type for inserting data into table "Checkout" */
export type Checkout_Insert_Input = {
  Checkout_Payments: InputMaybe<Payment_Arr_Rel_Insert_Input>;
  cartId: InputMaybe<Scalars['String']>;
  createdAt: InputMaybe<Scalars['timestamp']>;
  id: InputMaybe<Scalars['String']>;
  status: InputMaybe<Scalars['CheckoutStatus']>;
};

/** aggregate max on columns */
export type Checkout_Max_Fields = {
  __typename?: 'Checkout_max_fields';
  cartId: Maybe<Scalars['String']>;
  createdAt: Maybe<Scalars['timestamp']>;
  id: Maybe<Scalars['String']>;
  status: Maybe<Scalars['CheckoutStatus']>;
};

/** aggregate min on columns */
export type Checkout_Min_Fields = {
  __typename?: 'Checkout_min_fields';
  cartId: Maybe<Scalars['String']>;
  createdAt: Maybe<Scalars['timestamp']>;
  id: Maybe<Scalars['String']>;
  status: Maybe<Scalars['CheckoutStatus']>;
};

/** response of any mutation on the table "Checkout" */
export type Checkout_Mutation_Response = {
  __typename?: 'Checkout_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Checkout>;
};

/** input type for inserting object relation for remote table "Checkout" */
export type Checkout_Obj_Rel_Insert_Input = {
  data: Checkout_Insert_Input;
  /** upsert condition */
  on_conflict: InputMaybe<Checkout_On_Conflict>;
};

/** on_conflict condition type for table "Checkout" */
export type Checkout_On_Conflict = {
  constraint: Checkout_Constraint;
  update_columns: Array<Checkout_Update_Column>;
  where: InputMaybe<Checkout_Bool_Exp>;
};

/** Ordering options when selecting data from "Checkout". */
export type Checkout_Order_By = {
  Checkout_Payments_aggregate: InputMaybe<Payment_Aggregate_Order_By>;
  cartId: InputMaybe<Order_By>;
  createdAt: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  status: InputMaybe<Order_By>;
};

/** primary key columns input for table: Checkout */
export type Checkout_Pk_Columns_Input = {
  id: Scalars['String'];
};

/** select columns of table "Checkout" */
export enum Checkout_Select_Column {
  /** column name */
  CartId = 'cartId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Status = 'status',
}

/** input type for updating data in table "Checkout" */
export type Checkout_Set_Input = {
  cartId: InputMaybe<Scalars['String']>;
  createdAt: InputMaybe<Scalars['timestamp']>;
  id: InputMaybe<Scalars['String']>;
  status: InputMaybe<Scalars['CheckoutStatus']>;
};

/** Streaming cursor of the table "Checkout" */
export type Checkout_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Checkout_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Checkout_Stream_Cursor_Value_Input = {
  cartId: InputMaybe<Scalars['String']>;
  createdAt: InputMaybe<Scalars['timestamp']>;
  id: InputMaybe<Scalars['String']>;
  status: InputMaybe<Scalars['CheckoutStatus']>;
};

/** update columns of table "Checkout" */
export enum Checkout_Update_Column {
  /** column name */
  CartId = 'cartId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Status = 'status',
}

export type Checkout_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Checkout_Set_Input>;
  /** filter the rows which have to be updated */
  where: Checkout_Bool_Exp;
};

/** columns and relationships of "Collection" */
export type Collection = {
  __typename?: 'Collection';
  /** An array relationship */
  childCollections: Array<Collection>;
  /** An aggregate relationship */
  childCollections_aggregate: Collection_Aggregate;
  description: Maybe<Scalars['String']>;
  featuredImageSrc: Maybe<Scalars['String']>;
  handle: Scalars['String'];
  id: Scalars['String'];
  /** An object relationship */
  parentCollection: Maybe<Collection>;
  parentCollectionId: Maybe<Scalars['String']>;
  rules: Maybe<Scalars['jsonb']>;
  seoDescription: Maybe<Scalars['String']>;
  seoTitle: Maybe<Scalars['String']>;
  shopifyCollection: Maybe<Shopify_Collection>;
  shopifyId: Scalars['String'];
  shortName: Maybe<Scalars['String']>;
  title: Maybe<Scalars['String']>;
  type: Maybe<Scalars['CollectionType']>;
};

/** columns and relationships of "Collection" */
export type CollectionChildCollectionsArgs = {
  distinct_on: InputMaybe<Array<Collection_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Collection_Order_By>>;
  where: InputMaybe<Collection_Bool_Exp>;
};

/** columns and relationships of "Collection" */
export type CollectionChildCollections_AggregateArgs = {
  distinct_on: InputMaybe<Array<Collection_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Collection_Order_By>>;
  where: InputMaybe<Collection_Bool_Exp>;
};

/** columns and relationships of "Collection" */
export type CollectionRulesArgs = {
  path: InputMaybe<Scalars['String']>;
};

/** Boolean expression to compare columns of type "CollectionType". All fields are combined with logical 'AND'. */
export type CollectionType_Comparison_Exp = {
  _eq: InputMaybe<Scalars['CollectionType']>;
  _gt: InputMaybe<Scalars['CollectionType']>;
  _gte: InputMaybe<Scalars['CollectionType']>;
  _in: InputMaybe<Array<Scalars['CollectionType']>>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  _lt: InputMaybe<Scalars['CollectionType']>;
  _lte: InputMaybe<Scalars['CollectionType']>;
  _neq: InputMaybe<Scalars['CollectionType']>;
  _nin: InputMaybe<Array<Scalars['CollectionType']>>;
};

/** aggregated selection of "Collection" */
export type Collection_Aggregate = {
  __typename?: 'Collection_aggregate';
  aggregate: Maybe<Collection_Aggregate_Fields>;
  nodes: Array<Collection>;
};

export type Collection_Aggregate_Bool_Exp = {
  count: InputMaybe<Collection_Aggregate_Bool_Exp_Count>;
};

export type Collection_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<Collection_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<Collection_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "Collection" */
export type Collection_Aggregate_Fields = {
  __typename?: 'Collection_aggregate_fields';
  count: Scalars['Int'];
  max: Maybe<Collection_Max_Fields>;
  min: Maybe<Collection_Min_Fields>;
};

/** aggregate fields of "Collection" */
export type Collection_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Collection_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "Collection" */
export type Collection_Aggregate_Order_By = {
  count: InputMaybe<Order_By>;
  max: InputMaybe<Collection_Max_Order_By>;
  min: InputMaybe<Collection_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Collection_Append_Input = {
  rules: InputMaybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "Collection" */
export type Collection_Arr_Rel_Insert_Input = {
  data: Array<Collection_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<Collection_On_Conflict>;
};

/** Boolean expression to filter rows from the table "Collection". All fields are combined with a logical 'AND'. */
export type Collection_Bool_Exp = {
  _and: InputMaybe<Array<Collection_Bool_Exp>>;
  _not: InputMaybe<Collection_Bool_Exp>;
  _or: InputMaybe<Array<Collection_Bool_Exp>>;
  childCollections: InputMaybe<Collection_Bool_Exp>;
  childCollections_aggregate: InputMaybe<Collection_Aggregate_Bool_Exp>;
  description: InputMaybe<String_Comparison_Exp>;
  featuredImageSrc: InputMaybe<String_Comparison_Exp>;
  handle: InputMaybe<String_Comparison_Exp>;
  id: InputMaybe<String_Comparison_Exp>;
  parentCollection: InputMaybe<Collection_Bool_Exp>;
  parentCollectionId: InputMaybe<String_Comparison_Exp>;
  rules: InputMaybe<Jsonb_Comparison_Exp>;
  seoDescription: InputMaybe<String_Comparison_Exp>;
  seoTitle: InputMaybe<String_Comparison_Exp>;
  shopifyId: InputMaybe<String_Comparison_Exp>;
  shortName: InputMaybe<String_Comparison_Exp>;
  title: InputMaybe<String_Comparison_Exp>;
  type: InputMaybe<CollectionType_Comparison_Exp>;
};

/** unique or primary key constraints on table "Collection" */
export enum Collection_Constraint {
  /** unique or primary key constraint on columns "handle" */
  CollectionHandleKey = 'Collection_handle_key',
  /** unique or primary key constraint on columns "id" */
  CollectionPkey = 'Collection_pkey',
  /** unique or primary key constraint on columns "shopifyId" */
  CollectionShopifyIdKey = 'Collection_shopifyId_key',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Collection_Delete_At_Path_Input = {
  rules: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Collection_Delete_Elem_Input = {
  rules: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Collection_Delete_Key_Input = {
  rules: InputMaybe<Scalars['String']>;
};

/** input type for inserting data into table "Collection" */
export type Collection_Insert_Input = {
  childCollections: InputMaybe<Collection_Arr_Rel_Insert_Input>;
  description: InputMaybe<Scalars['String']>;
  featuredImageSrc: InputMaybe<Scalars['String']>;
  handle: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  parentCollection: InputMaybe<Collection_Obj_Rel_Insert_Input>;
  parentCollectionId: InputMaybe<Scalars['String']>;
  rules: InputMaybe<Scalars['jsonb']>;
  seoDescription: InputMaybe<Scalars['String']>;
  seoTitle: InputMaybe<Scalars['String']>;
  shopifyId: InputMaybe<Scalars['String']>;
  shortName: InputMaybe<Scalars['String']>;
  title: InputMaybe<Scalars['String']>;
  type: InputMaybe<Scalars['CollectionType']>;
};

/** aggregate max on columns */
export type Collection_Max_Fields = {
  __typename?: 'Collection_max_fields';
  description: Maybe<Scalars['String']>;
  featuredImageSrc: Maybe<Scalars['String']>;
  handle: Maybe<Scalars['String']>;
  id: Maybe<Scalars['String']>;
  parentCollectionId: Maybe<Scalars['String']>;
  seoDescription: Maybe<Scalars['String']>;
  seoTitle: Maybe<Scalars['String']>;
  shopifyId: Maybe<Scalars['String']>;
  shortName: Maybe<Scalars['String']>;
  title: Maybe<Scalars['String']>;
  type: Maybe<Scalars['CollectionType']>;
};

/** order by max() on columns of table "Collection" */
export type Collection_Max_Order_By = {
  description: InputMaybe<Order_By>;
  featuredImageSrc: InputMaybe<Order_By>;
  handle: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  parentCollectionId: InputMaybe<Order_By>;
  seoDescription: InputMaybe<Order_By>;
  seoTitle: InputMaybe<Order_By>;
  shopifyId: InputMaybe<Order_By>;
  shortName: InputMaybe<Order_By>;
  title: InputMaybe<Order_By>;
  type: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Collection_Min_Fields = {
  __typename?: 'Collection_min_fields';
  description: Maybe<Scalars['String']>;
  featuredImageSrc: Maybe<Scalars['String']>;
  handle: Maybe<Scalars['String']>;
  id: Maybe<Scalars['String']>;
  parentCollectionId: Maybe<Scalars['String']>;
  seoDescription: Maybe<Scalars['String']>;
  seoTitle: Maybe<Scalars['String']>;
  shopifyId: Maybe<Scalars['String']>;
  shortName: Maybe<Scalars['String']>;
  title: Maybe<Scalars['String']>;
  type: Maybe<Scalars['CollectionType']>;
};

/** order by min() on columns of table "Collection" */
export type Collection_Min_Order_By = {
  description: InputMaybe<Order_By>;
  featuredImageSrc: InputMaybe<Order_By>;
  handle: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  parentCollectionId: InputMaybe<Order_By>;
  seoDescription: InputMaybe<Order_By>;
  seoTitle: InputMaybe<Order_By>;
  shopifyId: InputMaybe<Order_By>;
  shortName: InputMaybe<Order_By>;
  title: InputMaybe<Order_By>;
  type: InputMaybe<Order_By>;
};

/** response of any mutation on the table "Collection" */
export type Collection_Mutation_Response = {
  __typename?: 'Collection_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Collection>;
};

/** input type for inserting object relation for remote table "Collection" */
export type Collection_Obj_Rel_Insert_Input = {
  data: Collection_Insert_Input;
  /** upsert condition */
  on_conflict: InputMaybe<Collection_On_Conflict>;
};

/** on_conflict condition type for table "Collection" */
export type Collection_On_Conflict = {
  constraint: Collection_Constraint;
  update_columns: Array<Collection_Update_Column>;
  where: InputMaybe<Collection_Bool_Exp>;
};

/** Ordering options when selecting data from "Collection". */
export type Collection_Order_By = {
  childCollections_aggregate: InputMaybe<Collection_Aggregate_Order_By>;
  description: InputMaybe<Order_By>;
  featuredImageSrc: InputMaybe<Order_By>;
  handle: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  parentCollection: InputMaybe<Collection_Order_By>;
  parentCollectionId: InputMaybe<Order_By>;
  rules: InputMaybe<Order_By>;
  seoDescription: InputMaybe<Order_By>;
  seoTitle: InputMaybe<Order_By>;
  shopifyId: InputMaybe<Order_By>;
  shortName: InputMaybe<Order_By>;
  title: InputMaybe<Order_By>;
  type: InputMaybe<Order_By>;
};

/** primary key columns input for table: Collection */
export type Collection_Pk_Columns_Input = {
  id: Scalars['String'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Collection_Prepend_Input = {
  rules: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "Collection" */
export enum Collection_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  FeaturedImageSrc = 'featuredImageSrc',
  /** column name */
  Handle = 'handle',
  /** column name */
  Id = 'id',
  /** column name */
  ParentCollectionId = 'parentCollectionId',
  /** column name */
  Rules = 'rules',
  /** column name */
  SeoDescription = 'seoDescription',
  /** column name */
  SeoTitle = 'seoTitle',
  /** column name */
  ShopifyId = 'shopifyId',
  /** column name */
  ShortName = 'shortName',
  /** column name */
  Title = 'title',
  /** column name */
  Type = 'type',
}

/** input type for updating data in table "Collection" */
export type Collection_Set_Input = {
  description: InputMaybe<Scalars['String']>;
  featuredImageSrc: InputMaybe<Scalars['String']>;
  handle: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  parentCollectionId: InputMaybe<Scalars['String']>;
  rules: InputMaybe<Scalars['jsonb']>;
  seoDescription: InputMaybe<Scalars['String']>;
  seoTitle: InputMaybe<Scalars['String']>;
  shopifyId: InputMaybe<Scalars['String']>;
  shortName: InputMaybe<Scalars['String']>;
  title: InputMaybe<Scalars['String']>;
  type: InputMaybe<Scalars['CollectionType']>;
};

/** Streaming cursor of the table "Collection" */
export type Collection_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Collection_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Collection_Stream_Cursor_Value_Input = {
  description: InputMaybe<Scalars['String']>;
  featuredImageSrc: InputMaybe<Scalars['String']>;
  handle: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  parentCollectionId: InputMaybe<Scalars['String']>;
  rules: InputMaybe<Scalars['jsonb']>;
  seoDescription: InputMaybe<Scalars['String']>;
  seoTitle: InputMaybe<Scalars['String']>;
  shopifyId: InputMaybe<Scalars['String']>;
  shortName: InputMaybe<Scalars['String']>;
  title: InputMaybe<Scalars['String']>;
  type: InputMaybe<Scalars['CollectionType']>;
};

/** update columns of table "Collection" */
export enum Collection_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  FeaturedImageSrc = 'featuredImageSrc',
  /** column name */
  Handle = 'handle',
  /** column name */
  Id = 'id',
  /** column name */
  ParentCollectionId = 'parentCollectionId',
  /** column name */
  Rules = 'rules',
  /** column name */
  SeoDescription = 'seoDescription',
  /** column name */
  SeoTitle = 'seoTitle',
  /** column name */
  ShopifyId = 'shopifyId',
  /** column name */
  ShortName = 'shortName',
  /** column name */
  Title = 'title',
  /** column name */
  Type = 'type',
}

export type Collection_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append: InputMaybe<Collection_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path: InputMaybe<Collection_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem: InputMaybe<Collection_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key: InputMaybe<Collection_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend: InputMaybe<Collection_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Collection_Set_Input>;
  /** filter the rows which have to be updated */
  where: Collection_Bool_Exp;
};

/** Boolean expression to compare columns of type "Condition". All fields are combined with logical 'AND'. */
export type Condition_Comparison_Exp = {
  _eq: InputMaybe<Scalars['Condition']>;
  _gt: InputMaybe<Scalars['Condition']>;
  _gte: InputMaybe<Scalars['Condition']>;
  _in: InputMaybe<Array<Scalars['Condition']>>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  _lt: InputMaybe<Scalars['Condition']>;
  _lte: InputMaybe<Scalars['Condition']>;
  _neq: InputMaybe<Scalars['Condition']>;
  _nin: InputMaybe<Array<Scalars['Condition']>>;
};

/** Boolean expression to compare columns of type "Currency". All fields are combined with logical 'AND'. */
export type Currency_Comparison_Exp = {
  _eq: InputMaybe<Scalars['Currency']>;
  _gt: InputMaybe<Scalars['Currency']>;
  _gte: InputMaybe<Scalars['Currency']>;
  _in: InputMaybe<Array<Scalars['Currency']>>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  _lt: InputMaybe<Scalars['Currency']>;
  _lte: InputMaybe<Scalars['Currency']>;
  _neq: InputMaybe<Scalars['Currency']>;
  _nin: InputMaybe<Array<Scalars['Currency']>>;
};

/** columns and relationships of "Customer" */
export type Customer = {
  __typename?: 'Customer';
  /** An array relationship */
  PublishedReviews: Array<Review>;
  /** An aggregate relationship */
  PublishedReviews_aggregate: Review_Aggregate;
  /** An array relationship */
  VendorReviews: Array<VendorReview>;
  /** An aggregate relationship */
  VendorReviews_aggregate: VendorReview_Aggregate;
  authUserId: Scalars['uuid'];
  buyerCommissionRate: Scalars['Int'];
  coverPictureShopifyCdnUrl: Maybe<Scalars['String']>;
  createdAt: Scalars['timestamp'];
  description: Maybe<Scalars['String']>;
  /** An array relationship */
  favorites: Array<FavoriteProducts>;
  /** An aggregate relationship */
  favorites_aggregate: FavoriteProducts_Aggregate;
  firstName: Maybe<Scalars['String']>;
  forcedShippingPriceInCents: Maybe<Scalars['float8']>;
  isPro: Scalars['Boolean'];
  isRefurbisher: Scalars['Boolean'];
  lastName: Maybe<Scalars['String']>;
  /** An array relationship */
  negociationAgreements: Array<NegociationAgreement>;
  /** An aggregate relationship */
  negociationAgreements_aggregate: NegociationAgreement_Aggregate;
  /** An array relationship */
  onlineProducts: Array<Product>;
  /** An aggregate relationship */
  onlineProducts_aggregate: Product_Aggregate;
  overridesProductNotation: Scalars['Boolean'];
  /** An array relationship */
  paymentAccounts: Array<PaymentAccounts>;
  /** An aggregate relationship */
  paymentAccounts_aggregate: PaymentAccounts_Aggregate;
  phoneNumber: Maybe<Scalars['String']>;
  preferredPaymentProvider: Scalars['PaymentProvider'];
  products: Shopify_ProductConnection;
  profilePictureShopifyCdnUrl: Maybe<Scalars['String']>;
  /** An array relationship */
  purchasedOrders: Array<Order>;
  /** An aggregate relationship */
  purchasedOrders_aggregate: Order_Aggregate;
  scoring: Maybe<Scalars['CustomerScoring']>;
  sellerName: Maybe<Scalars['String']>;
  shipmentTimeframe: Maybe<Scalars['ShipmentTimeframe']>;
  shopifyId: Scalars['bigint'];
  /** A computed field, executes function "shopify_search" */
  shopifySearch: Maybe<Scalars['String']>;
  updatedAt: Maybe<Scalars['timestamp']>;
  usedShipping: Scalars['ShippingType'];
  /** An object relationship */
  user: Maybe<Users>;
  /** An array relationship */
  vendorSoldOrderLines: Array<OrderLines>;
  /** An aggregate relationship */
  vendorSoldOrderLines_aggregate: OrderLines_Aggregate;
};

/** columns and relationships of "Customer" */
export type CustomerPublishedReviewsArgs = {
  distinct_on: InputMaybe<Array<Review_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Review_Order_By>>;
  where: InputMaybe<Review_Bool_Exp>;
};

/** columns and relationships of "Customer" */
export type CustomerPublishedReviews_AggregateArgs = {
  distinct_on: InputMaybe<Array<Review_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Review_Order_By>>;
  where: InputMaybe<Review_Bool_Exp>;
};

/** columns and relationships of "Customer" */
export type CustomerVendorReviewsArgs = {
  distinct_on: InputMaybe<Array<VendorReview_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<VendorReview_Order_By>>;
  where: InputMaybe<VendorReview_Bool_Exp>;
};

/** columns and relationships of "Customer" */
export type CustomerVendorReviews_AggregateArgs = {
  distinct_on: InputMaybe<Array<VendorReview_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<VendorReview_Order_By>>;
  where: InputMaybe<VendorReview_Bool_Exp>;
};

/** columns and relationships of "Customer" */
export type CustomerFavoritesArgs = {
  distinct_on: InputMaybe<Array<FavoriteProducts_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<FavoriteProducts_Order_By>>;
  where: InputMaybe<FavoriteProducts_Bool_Exp>;
};

/** columns and relationships of "Customer" */
export type CustomerFavorites_AggregateArgs = {
  distinct_on: InputMaybe<Array<FavoriteProducts_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<FavoriteProducts_Order_By>>;
  where: InputMaybe<FavoriteProducts_Bool_Exp>;
};

/** columns and relationships of "Customer" */
export type CustomerNegociationAgreementsArgs = {
  distinct_on: InputMaybe<Array<NegociationAgreement_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<NegociationAgreement_Order_By>>;
  where: InputMaybe<NegociationAgreement_Bool_Exp>;
};

/** columns and relationships of "Customer" */
export type CustomerNegociationAgreements_AggregateArgs = {
  distinct_on: InputMaybe<Array<NegociationAgreement_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<NegociationAgreement_Order_By>>;
  where: InputMaybe<NegociationAgreement_Bool_Exp>;
};

/** columns and relationships of "Customer" */
export type CustomerOnlineProductsArgs = {
  distinct_on: InputMaybe<Array<Product_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Product_Order_By>>;
  where: InputMaybe<Product_Bool_Exp>;
};

/** columns and relationships of "Customer" */
export type CustomerOnlineProducts_AggregateArgs = {
  distinct_on: InputMaybe<Array<Product_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Product_Order_By>>;
  where: InputMaybe<Product_Bool_Exp>;
};

/** columns and relationships of "Customer" */
export type CustomerPaymentAccountsArgs = {
  distinct_on: InputMaybe<Array<PaymentAccounts_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<PaymentAccounts_Order_By>>;
  where: InputMaybe<PaymentAccounts_Bool_Exp>;
};

/** columns and relationships of "Customer" */
export type CustomerPaymentAccounts_AggregateArgs = {
  distinct_on: InputMaybe<Array<PaymentAccounts_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<PaymentAccounts_Order_By>>;
  where: InputMaybe<PaymentAccounts_Bool_Exp>;
};

/** columns and relationships of "Customer" */
export type CustomerProductsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  reverse?: InputMaybe<Scalars['Boolean']>;
  sortKey?: InputMaybe<Shopify_ProductSortKeys>;
};

/** columns and relationships of "Customer" */
export type CustomerPurchasedOrdersArgs = {
  distinct_on: InputMaybe<Array<Order_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Order_Order_By>>;
  where: InputMaybe<Order_Bool_Exp>;
};

/** columns and relationships of "Customer" */
export type CustomerPurchasedOrders_AggregateArgs = {
  distinct_on: InputMaybe<Array<Order_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Order_Order_By>>;
  where: InputMaybe<Order_Bool_Exp>;
};

/** columns and relationships of "Customer" */
export type CustomerVendorSoldOrderLinesArgs = {
  distinct_on: InputMaybe<Array<OrderLines_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<OrderLines_Order_By>>;
  where: InputMaybe<OrderLines_Bool_Exp>;
};

/** columns and relationships of "Customer" */
export type CustomerVendorSoldOrderLines_AggregateArgs = {
  distinct_on: InputMaybe<Array<OrderLines_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<OrderLines_Order_By>>;
  where: InputMaybe<OrderLines_Bool_Exp>;
};

/** Boolean expression to compare columns of type "CustomerScoring". All fields are combined with logical 'AND'. */
export type CustomerScoring_Comparison_Exp = {
  _eq: InputMaybe<Scalars['CustomerScoring']>;
  _gt: InputMaybe<Scalars['CustomerScoring']>;
  _gte: InputMaybe<Scalars['CustomerScoring']>;
  _in: InputMaybe<Array<Scalars['CustomerScoring']>>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  _lt: InputMaybe<Scalars['CustomerScoring']>;
  _lte: InputMaybe<Scalars['CustomerScoring']>;
  _neq: InputMaybe<Scalars['CustomerScoring']>;
  _nin: InputMaybe<Array<Scalars['CustomerScoring']>>;
};

/** aggregated selection of "Customer" */
export type Customer_Aggregate = {
  __typename?: 'Customer_aggregate';
  aggregate: Maybe<Customer_Aggregate_Fields>;
  nodes: Array<Customer>;
};

/** aggregate fields of "Customer" */
export type Customer_Aggregate_Fields = {
  __typename?: 'Customer_aggregate_fields';
  avg: Maybe<Customer_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Customer_Max_Fields>;
  min: Maybe<Customer_Min_Fields>;
  stddev: Maybe<Customer_Stddev_Fields>;
  stddev_pop: Maybe<Customer_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Customer_Stddev_Samp_Fields>;
  sum: Maybe<Customer_Sum_Fields>;
  var_pop: Maybe<Customer_Var_Pop_Fields>;
  var_samp: Maybe<Customer_Var_Samp_Fields>;
  variance: Maybe<Customer_Variance_Fields>;
};

/** aggregate fields of "Customer" */
export type Customer_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Customer_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Customer_Avg_Fields = {
  __typename?: 'Customer_avg_fields';
  buyerCommissionRate: Maybe<Scalars['Float']>;
  forcedShippingPriceInCents: Maybe<Scalars['Float']>;
  shopifyId: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "Customer". All fields are combined with a logical 'AND'. */
export type Customer_Bool_Exp = {
  PublishedReviews: InputMaybe<Review_Bool_Exp>;
  PublishedReviews_aggregate: InputMaybe<Review_Aggregate_Bool_Exp>;
  VendorReviews: InputMaybe<VendorReview_Bool_Exp>;
  VendorReviews_aggregate: InputMaybe<VendorReview_Aggregate_Bool_Exp>;
  _and: InputMaybe<Array<Customer_Bool_Exp>>;
  _not: InputMaybe<Customer_Bool_Exp>;
  _or: InputMaybe<Array<Customer_Bool_Exp>>;
  authUserId: InputMaybe<Uuid_Comparison_Exp>;
  buyerCommissionRate: InputMaybe<Int_Comparison_Exp>;
  coverPictureShopifyCdnUrl: InputMaybe<String_Comparison_Exp>;
  createdAt: InputMaybe<Timestamp_Comparison_Exp>;
  description: InputMaybe<String_Comparison_Exp>;
  favorites: InputMaybe<FavoriteProducts_Bool_Exp>;
  favorites_aggregate: InputMaybe<FavoriteProducts_Aggregate_Bool_Exp>;
  firstName: InputMaybe<String_Comparison_Exp>;
  forcedShippingPriceInCents: InputMaybe<Float8_Comparison_Exp>;
  isPro: InputMaybe<Boolean_Comparison_Exp>;
  isRefurbisher: InputMaybe<Boolean_Comparison_Exp>;
  lastName: InputMaybe<String_Comparison_Exp>;
  negociationAgreements: InputMaybe<NegociationAgreement_Bool_Exp>;
  negociationAgreements_aggregate: InputMaybe<NegociationAgreement_Aggregate_Bool_Exp>;
  onlineProducts: InputMaybe<Product_Bool_Exp>;
  onlineProducts_aggregate: InputMaybe<Product_Aggregate_Bool_Exp>;
  overridesProductNotation: InputMaybe<Boolean_Comparison_Exp>;
  paymentAccounts: InputMaybe<PaymentAccounts_Bool_Exp>;
  paymentAccounts_aggregate: InputMaybe<PaymentAccounts_Aggregate_Bool_Exp>;
  phoneNumber: InputMaybe<String_Comparison_Exp>;
  preferredPaymentProvider: InputMaybe<PaymentProvider_Comparison_Exp>;
  profilePictureShopifyCdnUrl: InputMaybe<String_Comparison_Exp>;
  purchasedOrders: InputMaybe<Order_Bool_Exp>;
  purchasedOrders_aggregate: InputMaybe<Order_Aggregate_Bool_Exp>;
  scoring: InputMaybe<CustomerScoring_Comparison_Exp>;
  sellerName: InputMaybe<String_Comparison_Exp>;
  shipmentTimeframe: InputMaybe<ShipmentTimeframe_Comparison_Exp>;
  shopifyId: InputMaybe<Bigint_Comparison_Exp>;
  shopifySearch: InputMaybe<String_Comparison_Exp>;
  updatedAt: InputMaybe<Timestamp_Comparison_Exp>;
  usedShipping: InputMaybe<ShippingType_Comparison_Exp>;
  user: InputMaybe<Users_Bool_Exp>;
  vendorSoldOrderLines: InputMaybe<OrderLines_Bool_Exp>;
  vendorSoldOrderLines_aggregate: InputMaybe<OrderLines_Aggregate_Bool_Exp>;
};

/** unique or primary key constraints on table "Customer" */
export enum Customer_Constraint {
  /** unique or primary key constraint on columns "authUserId" */
  CustomerAuthUserIdKey = 'Customer_authUserId_key',
  /** unique or primary key constraint on columns "authUserId" */
  CustomerPkey = 'Customer_pkey',
  /** unique or primary key constraint on columns "shopifyId" */
  CustomerShopifyIdKey = 'Customer_shopifyId_key',
}

/** input type for incrementing numeric columns in table "Customer" */
export type Customer_Inc_Input = {
  buyerCommissionRate: InputMaybe<Scalars['Int']>;
  forcedShippingPriceInCents: InputMaybe<Scalars['float8']>;
  shopifyId: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "Customer" */
export type Customer_Insert_Input = {
  PublishedReviews: InputMaybe<Review_Arr_Rel_Insert_Input>;
  VendorReviews: InputMaybe<VendorReview_Arr_Rel_Insert_Input>;
  authUserId: InputMaybe<Scalars['uuid']>;
  buyerCommissionRate: InputMaybe<Scalars['Int']>;
  coverPictureShopifyCdnUrl: InputMaybe<Scalars['String']>;
  createdAt: InputMaybe<Scalars['timestamp']>;
  description: InputMaybe<Scalars['String']>;
  favorites: InputMaybe<FavoriteProducts_Arr_Rel_Insert_Input>;
  firstName: InputMaybe<Scalars['String']>;
  forcedShippingPriceInCents: InputMaybe<Scalars['float8']>;
  isPro: InputMaybe<Scalars['Boolean']>;
  isRefurbisher: InputMaybe<Scalars['Boolean']>;
  lastName: InputMaybe<Scalars['String']>;
  negociationAgreements: InputMaybe<NegociationAgreement_Arr_Rel_Insert_Input>;
  onlineProducts: InputMaybe<Product_Arr_Rel_Insert_Input>;
  overridesProductNotation: InputMaybe<Scalars['Boolean']>;
  paymentAccounts: InputMaybe<PaymentAccounts_Arr_Rel_Insert_Input>;
  phoneNumber: InputMaybe<Scalars['String']>;
  preferredPaymentProvider: InputMaybe<Scalars['PaymentProvider']>;
  profilePictureShopifyCdnUrl: InputMaybe<Scalars['String']>;
  purchasedOrders: InputMaybe<Order_Arr_Rel_Insert_Input>;
  scoring: InputMaybe<Scalars['CustomerScoring']>;
  sellerName: InputMaybe<Scalars['String']>;
  shipmentTimeframe: InputMaybe<Scalars['ShipmentTimeframe']>;
  shopifyId: InputMaybe<Scalars['bigint']>;
  updatedAt: InputMaybe<Scalars['timestamp']>;
  usedShipping: InputMaybe<Scalars['ShippingType']>;
  user: InputMaybe<Users_Obj_Rel_Insert_Input>;
  vendorSoldOrderLines: InputMaybe<OrderLines_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Customer_Max_Fields = {
  __typename?: 'Customer_max_fields';
  authUserId: Maybe<Scalars['uuid']>;
  buyerCommissionRate: Maybe<Scalars['Int']>;
  coverPictureShopifyCdnUrl: Maybe<Scalars['String']>;
  createdAt: Maybe<Scalars['timestamp']>;
  description: Maybe<Scalars['String']>;
  firstName: Maybe<Scalars['String']>;
  forcedShippingPriceInCents: Maybe<Scalars['float8']>;
  lastName: Maybe<Scalars['String']>;
  phoneNumber: Maybe<Scalars['String']>;
  preferredPaymentProvider: Maybe<Scalars['PaymentProvider']>;
  profilePictureShopifyCdnUrl: Maybe<Scalars['String']>;
  scoring: Maybe<Scalars['CustomerScoring']>;
  sellerName: Maybe<Scalars['String']>;
  shipmentTimeframe: Maybe<Scalars['ShipmentTimeframe']>;
  shopifyId: Maybe<Scalars['bigint']>;
  /** A computed field, executes function "shopify_search" */
  shopifySearch: Maybe<Scalars['String']>;
  updatedAt: Maybe<Scalars['timestamp']>;
  usedShipping: Maybe<Scalars['ShippingType']>;
};

/** aggregate min on columns */
export type Customer_Min_Fields = {
  __typename?: 'Customer_min_fields';
  authUserId: Maybe<Scalars['uuid']>;
  buyerCommissionRate: Maybe<Scalars['Int']>;
  coverPictureShopifyCdnUrl: Maybe<Scalars['String']>;
  createdAt: Maybe<Scalars['timestamp']>;
  description: Maybe<Scalars['String']>;
  firstName: Maybe<Scalars['String']>;
  forcedShippingPriceInCents: Maybe<Scalars['float8']>;
  lastName: Maybe<Scalars['String']>;
  phoneNumber: Maybe<Scalars['String']>;
  preferredPaymentProvider: Maybe<Scalars['PaymentProvider']>;
  profilePictureShopifyCdnUrl: Maybe<Scalars['String']>;
  scoring: Maybe<Scalars['CustomerScoring']>;
  sellerName: Maybe<Scalars['String']>;
  shipmentTimeframe: Maybe<Scalars['ShipmentTimeframe']>;
  shopifyId: Maybe<Scalars['bigint']>;
  /** A computed field, executes function "shopify_search" */
  shopifySearch: Maybe<Scalars['String']>;
  updatedAt: Maybe<Scalars['timestamp']>;
  usedShipping: Maybe<Scalars['ShippingType']>;
};

/** response of any mutation on the table "Customer" */
export type Customer_Mutation_Response = {
  __typename?: 'Customer_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Customer>;
};

/** input type for inserting object relation for remote table "Customer" */
export type Customer_Obj_Rel_Insert_Input = {
  data: Customer_Insert_Input;
  /** upsert condition */
  on_conflict: InputMaybe<Customer_On_Conflict>;
};

/** on_conflict condition type for table "Customer" */
export type Customer_On_Conflict = {
  constraint: Customer_Constraint;
  update_columns: Array<Customer_Update_Column>;
  where: InputMaybe<Customer_Bool_Exp>;
};

/** Ordering options when selecting data from "Customer". */
export type Customer_Order_By = {
  PublishedReviews_aggregate: InputMaybe<Review_Aggregate_Order_By>;
  VendorReviews_aggregate: InputMaybe<VendorReview_Aggregate_Order_By>;
  authUserId: InputMaybe<Order_By>;
  buyerCommissionRate: InputMaybe<Order_By>;
  coverPictureShopifyCdnUrl: InputMaybe<Order_By>;
  createdAt: InputMaybe<Order_By>;
  description: InputMaybe<Order_By>;
  favorites_aggregate: InputMaybe<FavoriteProducts_Aggregate_Order_By>;
  firstName: InputMaybe<Order_By>;
  forcedShippingPriceInCents: InputMaybe<Order_By>;
  isPro: InputMaybe<Order_By>;
  isRefurbisher: InputMaybe<Order_By>;
  lastName: InputMaybe<Order_By>;
  negociationAgreements_aggregate: InputMaybe<NegociationAgreement_Aggregate_Order_By>;
  onlineProducts_aggregate: InputMaybe<Product_Aggregate_Order_By>;
  overridesProductNotation: InputMaybe<Order_By>;
  paymentAccounts_aggregate: InputMaybe<PaymentAccounts_Aggregate_Order_By>;
  phoneNumber: InputMaybe<Order_By>;
  preferredPaymentProvider: InputMaybe<Order_By>;
  profilePictureShopifyCdnUrl: InputMaybe<Order_By>;
  purchasedOrders_aggregate: InputMaybe<Order_Aggregate_Order_By>;
  scoring: InputMaybe<Order_By>;
  sellerName: InputMaybe<Order_By>;
  shipmentTimeframe: InputMaybe<Order_By>;
  shopifyId: InputMaybe<Order_By>;
  shopifySearch: InputMaybe<Order_By>;
  updatedAt: InputMaybe<Order_By>;
  usedShipping: InputMaybe<Order_By>;
  user: InputMaybe<Users_Order_By>;
  vendorSoldOrderLines_aggregate: InputMaybe<OrderLines_Aggregate_Order_By>;
};

/** primary key columns input for table: Customer */
export type Customer_Pk_Columns_Input = {
  authUserId: Scalars['uuid'];
};

/** select columns of table "Customer" */
export enum Customer_Select_Column {
  /** column name */
  AuthUserId = 'authUserId',
  /** column name */
  BuyerCommissionRate = 'buyerCommissionRate',
  /** column name */
  CoverPictureShopifyCdnUrl = 'coverPictureShopifyCdnUrl',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Description = 'description',
  /** column name */
  FirstName = 'firstName',
  /** column name */
  ForcedShippingPriceInCents = 'forcedShippingPriceInCents',
  /** column name */
  IsPro = 'isPro',
  /** column name */
  IsRefurbisher = 'isRefurbisher',
  /** column name */
  LastName = 'lastName',
  /** column name */
  OverridesProductNotation = 'overridesProductNotation',
  /** column name */
  PhoneNumber = 'phoneNumber',
  /** column name */
  PreferredPaymentProvider = 'preferredPaymentProvider',
  /** column name */
  ProfilePictureShopifyCdnUrl = 'profilePictureShopifyCdnUrl',
  /** column name */
  Scoring = 'scoring',
  /** column name */
  SellerName = 'sellerName',
  /** column name */
  ShipmentTimeframe = 'shipmentTimeframe',
  /** column name */
  ShopifyId = 'shopifyId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UsedShipping = 'usedShipping',
}

/** input type for updating data in table "Customer" */
export type Customer_Set_Input = {
  authUserId: InputMaybe<Scalars['uuid']>;
  buyerCommissionRate: InputMaybe<Scalars['Int']>;
  coverPictureShopifyCdnUrl: InputMaybe<Scalars['String']>;
  createdAt: InputMaybe<Scalars['timestamp']>;
  description: InputMaybe<Scalars['String']>;
  firstName: InputMaybe<Scalars['String']>;
  forcedShippingPriceInCents: InputMaybe<Scalars['float8']>;
  isPro: InputMaybe<Scalars['Boolean']>;
  isRefurbisher: InputMaybe<Scalars['Boolean']>;
  lastName: InputMaybe<Scalars['String']>;
  overridesProductNotation: InputMaybe<Scalars['Boolean']>;
  phoneNumber: InputMaybe<Scalars['String']>;
  preferredPaymentProvider: InputMaybe<Scalars['PaymentProvider']>;
  profilePictureShopifyCdnUrl: InputMaybe<Scalars['String']>;
  scoring: InputMaybe<Scalars['CustomerScoring']>;
  sellerName: InputMaybe<Scalars['String']>;
  shipmentTimeframe: InputMaybe<Scalars['ShipmentTimeframe']>;
  shopifyId: InputMaybe<Scalars['bigint']>;
  updatedAt: InputMaybe<Scalars['timestamp']>;
  usedShipping: InputMaybe<Scalars['ShippingType']>;
};

/** aggregate stddev on columns */
export type Customer_Stddev_Fields = {
  __typename?: 'Customer_stddev_fields';
  buyerCommissionRate: Maybe<Scalars['Float']>;
  forcedShippingPriceInCents: Maybe<Scalars['Float']>;
  shopifyId: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Customer_Stddev_Pop_Fields = {
  __typename?: 'Customer_stddev_pop_fields';
  buyerCommissionRate: Maybe<Scalars['Float']>;
  forcedShippingPriceInCents: Maybe<Scalars['Float']>;
  shopifyId: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Customer_Stddev_Samp_Fields = {
  __typename?: 'Customer_stddev_samp_fields';
  buyerCommissionRate: Maybe<Scalars['Float']>;
  forcedShippingPriceInCents: Maybe<Scalars['Float']>;
  shopifyId: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "Customer" */
export type Customer_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Customer_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Customer_Stream_Cursor_Value_Input = {
  authUserId: InputMaybe<Scalars['uuid']>;
  buyerCommissionRate: InputMaybe<Scalars['Int']>;
  coverPictureShopifyCdnUrl: InputMaybe<Scalars['String']>;
  createdAt: InputMaybe<Scalars['timestamp']>;
  description: InputMaybe<Scalars['String']>;
  firstName: InputMaybe<Scalars['String']>;
  forcedShippingPriceInCents: InputMaybe<Scalars['float8']>;
  isPro: InputMaybe<Scalars['Boolean']>;
  isRefurbisher: InputMaybe<Scalars['Boolean']>;
  lastName: InputMaybe<Scalars['String']>;
  overridesProductNotation: InputMaybe<Scalars['Boolean']>;
  phoneNumber: InputMaybe<Scalars['String']>;
  preferredPaymentProvider: InputMaybe<Scalars['PaymentProvider']>;
  profilePictureShopifyCdnUrl: InputMaybe<Scalars['String']>;
  scoring: InputMaybe<Scalars['CustomerScoring']>;
  sellerName: InputMaybe<Scalars['String']>;
  shipmentTimeframe: InputMaybe<Scalars['ShipmentTimeframe']>;
  shopifyId: InputMaybe<Scalars['bigint']>;
  updatedAt: InputMaybe<Scalars['timestamp']>;
  usedShipping: InputMaybe<Scalars['ShippingType']>;
};

/** aggregate sum on columns */
export type Customer_Sum_Fields = {
  __typename?: 'Customer_sum_fields';
  buyerCommissionRate: Maybe<Scalars['Int']>;
  forcedShippingPriceInCents: Maybe<Scalars['float8']>;
  shopifyId: Maybe<Scalars['bigint']>;
};

/** update columns of table "Customer" */
export enum Customer_Update_Column {
  /** column name */
  AuthUserId = 'authUserId',
  /** column name */
  BuyerCommissionRate = 'buyerCommissionRate',
  /** column name */
  CoverPictureShopifyCdnUrl = 'coverPictureShopifyCdnUrl',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Description = 'description',
  /** column name */
  FirstName = 'firstName',
  /** column name */
  ForcedShippingPriceInCents = 'forcedShippingPriceInCents',
  /** column name */
  IsPro = 'isPro',
  /** column name */
  IsRefurbisher = 'isRefurbisher',
  /** column name */
  LastName = 'lastName',
  /** column name */
  OverridesProductNotation = 'overridesProductNotation',
  /** column name */
  PhoneNumber = 'phoneNumber',
  /** column name */
  PreferredPaymentProvider = 'preferredPaymentProvider',
  /** column name */
  ProfilePictureShopifyCdnUrl = 'profilePictureShopifyCdnUrl',
  /** column name */
  Scoring = 'scoring',
  /** column name */
  SellerName = 'sellerName',
  /** column name */
  ShipmentTimeframe = 'shipmentTimeframe',
  /** column name */
  ShopifyId = 'shopifyId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UsedShipping = 'usedShipping',
}

export type Customer_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Customer_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Customer_Set_Input>;
  /** filter the rows which have to be updated */
  where: Customer_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Customer_Var_Pop_Fields = {
  __typename?: 'Customer_var_pop_fields';
  buyerCommissionRate: Maybe<Scalars['Float']>;
  forcedShippingPriceInCents: Maybe<Scalars['Float']>;
  shopifyId: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Customer_Var_Samp_Fields = {
  __typename?: 'Customer_var_samp_fields';
  buyerCommissionRate: Maybe<Scalars['Float']>;
  forcedShippingPriceInCents: Maybe<Scalars['Float']>;
  shopifyId: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Customer_Variance_Fields = {
  __typename?: 'Customer_variance_fields';
  buyerCommissionRate: Maybe<Scalars['Float']>;
  forcedShippingPriceInCents: Maybe<Scalars['Float']>;
  shopifyId: Maybe<Scalars['Float']>;
};

/** columns and relationships of "Dispute" */
export type Dispute = {
  __typename?: 'Dispute';
  /** An array relationship */
  attachments: Array<DisputeAttachment>;
  /** An aggregate relationship */
  attachments_aggregate: DisputeAttachment_Aggregate;
  /** An object relationship */
  author: Customer;
  authorId: Scalars['uuid'];
  canceledAt: Maybe<Scalars['timestamp']>;
  closedAt: Maybe<Scalars['timestamp']>;
  createdAt: Scalars['timestamp'];
  description: Maybe<Scalars['String']>;
  id: Scalars['String'];
  internalComment: Maybe<Scalars['String']>;
  /** An object relationship */
  orderLine: OrderLines;
  orderLineId: Scalars['String'];
  reason: Scalars['DisputeReason'];
  /** An array relationship */
  returns: Array<Return>;
  /** An aggregate relationship */
  returns_aggregate: Return_Aggregate;
  status: Scalars['DisputeStatus'];
};

/** columns and relationships of "Dispute" */
export type DisputeAttachmentsArgs = {
  distinct_on: InputMaybe<Array<DisputeAttachment_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<DisputeAttachment_Order_By>>;
  where: InputMaybe<DisputeAttachment_Bool_Exp>;
};

/** columns and relationships of "Dispute" */
export type DisputeAttachments_AggregateArgs = {
  distinct_on: InputMaybe<Array<DisputeAttachment_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<DisputeAttachment_Order_By>>;
  where: InputMaybe<DisputeAttachment_Bool_Exp>;
};

/** columns and relationships of "Dispute" */
export type DisputeReturnsArgs = {
  distinct_on: InputMaybe<Array<Return_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Return_Order_By>>;
  where: InputMaybe<Return_Bool_Exp>;
};

/** columns and relationships of "Dispute" */
export type DisputeReturns_AggregateArgs = {
  distinct_on: InputMaybe<Array<Return_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Return_Order_By>>;
  where: InputMaybe<Return_Bool_Exp>;
};

/** columns and relationships of "DisputeAttachment" */
export type DisputeAttachment = {
  __typename?: 'DisputeAttachment';
  /** An object relationship */
  author: Customer;
  authorId: Scalars['uuid'];
  disputeId: Scalars['String'];
  filename: Scalars['String'];
  id: Scalars['String'];
  uploadedAt: Scalars['timestamp'];
};

/** aggregated selection of "DisputeAttachment" */
export type DisputeAttachment_Aggregate = {
  __typename?: 'DisputeAttachment_aggregate';
  aggregate: Maybe<DisputeAttachment_Aggregate_Fields>;
  nodes: Array<DisputeAttachment>;
};

export type DisputeAttachment_Aggregate_Bool_Exp = {
  count: InputMaybe<DisputeAttachment_Aggregate_Bool_Exp_Count>;
};

export type DisputeAttachment_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<DisputeAttachment_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<DisputeAttachment_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "DisputeAttachment" */
export type DisputeAttachment_Aggregate_Fields = {
  __typename?: 'DisputeAttachment_aggregate_fields';
  count: Scalars['Int'];
  max: Maybe<DisputeAttachment_Max_Fields>;
  min: Maybe<DisputeAttachment_Min_Fields>;
};

/** aggregate fields of "DisputeAttachment" */
export type DisputeAttachment_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<DisputeAttachment_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "DisputeAttachment" */
export type DisputeAttachment_Aggregate_Order_By = {
  count: InputMaybe<Order_By>;
  max: InputMaybe<DisputeAttachment_Max_Order_By>;
  min: InputMaybe<DisputeAttachment_Min_Order_By>;
};

/** input type for inserting array relation for remote table "DisputeAttachment" */
export type DisputeAttachment_Arr_Rel_Insert_Input = {
  data: Array<DisputeAttachment_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<DisputeAttachment_On_Conflict>;
};

/** Boolean expression to filter rows from the table "DisputeAttachment". All fields are combined with a logical 'AND'. */
export type DisputeAttachment_Bool_Exp = {
  _and: InputMaybe<Array<DisputeAttachment_Bool_Exp>>;
  _not: InputMaybe<DisputeAttachment_Bool_Exp>;
  _or: InputMaybe<Array<DisputeAttachment_Bool_Exp>>;
  author: InputMaybe<Customer_Bool_Exp>;
  authorId: InputMaybe<Uuid_Comparison_Exp>;
  disputeId: InputMaybe<String_Comparison_Exp>;
  filename: InputMaybe<String_Comparison_Exp>;
  id: InputMaybe<String_Comparison_Exp>;
  uploadedAt: InputMaybe<Timestamp_Comparison_Exp>;
};

/** unique or primary key constraints on table "DisputeAttachment" */
export enum DisputeAttachment_Constraint {
  /** unique or primary key constraint on columns "id" */
  DisputeAttachmentPkey = 'DisputeAttachment_pkey',
}

/** input type for inserting data into table "DisputeAttachment" */
export type DisputeAttachment_Insert_Input = {
  author: InputMaybe<Customer_Obj_Rel_Insert_Input>;
  authorId: InputMaybe<Scalars['uuid']>;
  disputeId: InputMaybe<Scalars['String']>;
  filename: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  uploadedAt: InputMaybe<Scalars['timestamp']>;
};

/** aggregate max on columns */
export type DisputeAttachment_Max_Fields = {
  __typename?: 'DisputeAttachment_max_fields';
  authorId: Maybe<Scalars['uuid']>;
  disputeId: Maybe<Scalars['String']>;
  filename: Maybe<Scalars['String']>;
  id: Maybe<Scalars['String']>;
  uploadedAt: Maybe<Scalars['timestamp']>;
};

/** order by max() on columns of table "DisputeAttachment" */
export type DisputeAttachment_Max_Order_By = {
  authorId: InputMaybe<Order_By>;
  disputeId: InputMaybe<Order_By>;
  filename: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  uploadedAt: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type DisputeAttachment_Min_Fields = {
  __typename?: 'DisputeAttachment_min_fields';
  authorId: Maybe<Scalars['uuid']>;
  disputeId: Maybe<Scalars['String']>;
  filename: Maybe<Scalars['String']>;
  id: Maybe<Scalars['String']>;
  uploadedAt: Maybe<Scalars['timestamp']>;
};

/** order by min() on columns of table "DisputeAttachment" */
export type DisputeAttachment_Min_Order_By = {
  authorId: InputMaybe<Order_By>;
  disputeId: InputMaybe<Order_By>;
  filename: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  uploadedAt: InputMaybe<Order_By>;
};

/** response of any mutation on the table "DisputeAttachment" */
export type DisputeAttachment_Mutation_Response = {
  __typename?: 'DisputeAttachment_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<DisputeAttachment>;
};

/** on_conflict condition type for table "DisputeAttachment" */
export type DisputeAttachment_On_Conflict = {
  constraint: DisputeAttachment_Constraint;
  update_columns: Array<DisputeAttachment_Update_Column>;
  where: InputMaybe<DisputeAttachment_Bool_Exp>;
};

/** Ordering options when selecting data from "DisputeAttachment". */
export type DisputeAttachment_Order_By = {
  author: InputMaybe<Customer_Order_By>;
  authorId: InputMaybe<Order_By>;
  disputeId: InputMaybe<Order_By>;
  filename: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  uploadedAt: InputMaybe<Order_By>;
};

/** primary key columns input for table: DisputeAttachment */
export type DisputeAttachment_Pk_Columns_Input = {
  id: Scalars['String'];
};

/** select columns of table "DisputeAttachment" */
export enum DisputeAttachment_Select_Column {
  /** column name */
  AuthorId = 'authorId',
  /** column name */
  DisputeId = 'disputeId',
  /** column name */
  Filename = 'filename',
  /** column name */
  Id = 'id',
  /** column name */
  UploadedAt = 'uploadedAt',
}

/** input type for updating data in table "DisputeAttachment" */
export type DisputeAttachment_Set_Input = {
  authorId: InputMaybe<Scalars['uuid']>;
  disputeId: InputMaybe<Scalars['String']>;
  filename: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  uploadedAt: InputMaybe<Scalars['timestamp']>;
};

/** Streaming cursor of the table "DisputeAttachment" */
export type DisputeAttachment_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: DisputeAttachment_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type DisputeAttachment_Stream_Cursor_Value_Input = {
  authorId: InputMaybe<Scalars['uuid']>;
  disputeId: InputMaybe<Scalars['String']>;
  filename: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  uploadedAt: InputMaybe<Scalars['timestamp']>;
};

/** update columns of table "DisputeAttachment" */
export enum DisputeAttachment_Update_Column {
  /** column name */
  AuthorId = 'authorId',
  /** column name */
  DisputeId = 'disputeId',
  /** column name */
  Filename = 'filename',
  /** column name */
  Id = 'id',
  /** column name */
  UploadedAt = 'uploadedAt',
}

export type DisputeAttachment_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<DisputeAttachment_Set_Input>;
  /** filter the rows which have to be updated */
  where: DisputeAttachment_Bool_Exp;
};

/** Boolean expression to compare columns of type "DisputeReason". All fields are combined with logical 'AND'. */
export type DisputeReason_Comparison_Exp = {
  _eq: InputMaybe<Scalars['DisputeReason']>;
  _gt: InputMaybe<Scalars['DisputeReason']>;
  _gte: InputMaybe<Scalars['DisputeReason']>;
  _in: InputMaybe<Array<Scalars['DisputeReason']>>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  _lt: InputMaybe<Scalars['DisputeReason']>;
  _lte: InputMaybe<Scalars['DisputeReason']>;
  _neq: InputMaybe<Scalars['DisputeReason']>;
  _nin: InputMaybe<Array<Scalars['DisputeReason']>>;
};

/** Boolean expression to compare columns of type "DisputeStatus". All fields are combined with logical 'AND'. */
export type DisputeStatus_Comparison_Exp = {
  _eq: InputMaybe<Scalars['DisputeStatus']>;
  _gt: InputMaybe<Scalars['DisputeStatus']>;
  _gte: InputMaybe<Scalars['DisputeStatus']>;
  _in: InputMaybe<Array<Scalars['DisputeStatus']>>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  _lt: InputMaybe<Scalars['DisputeStatus']>;
  _lte: InputMaybe<Scalars['DisputeStatus']>;
  _neq: InputMaybe<Scalars['DisputeStatus']>;
  _nin: InputMaybe<Array<Scalars['DisputeStatus']>>;
};

/** aggregated selection of "Dispute" */
export type Dispute_Aggregate = {
  __typename?: 'Dispute_aggregate';
  aggregate: Maybe<Dispute_Aggregate_Fields>;
  nodes: Array<Dispute>;
};

export type Dispute_Aggregate_Bool_Exp = {
  count: InputMaybe<Dispute_Aggregate_Bool_Exp_Count>;
};

export type Dispute_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<Dispute_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<Dispute_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "Dispute" */
export type Dispute_Aggregate_Fields = {
  __typename?: 'Dispute_aggregate_fields';
  count: Scalars['Int'];
  max: Maybe<Dispute_Max_Fields>;
  min: Maybe<Dispute_Min_Fields>;
};

/** aggregate fields of "Dispute" */
export type Dispute_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Dispute_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "Dispute" */
export type Dispute_Aggregate_Order_By = {
  count: InputMaybe<Order_By>;
  max: InputMaybe<Dispute_Max_Order_By>;
  min: InputMaybe<Dispute_Min_Order_By>;
};

/** input type for inserting array relation for remote table "Dispute" */
export type Dispute_Arr_Rel_Insert_Input = {
  data: Array<Dispute_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<Dispute_On_Conflict>;
};

/** Boolean expression to filter rows from the table "Dispute". All fields are combined with a logical 'AND'. */
export type Dispute_Bool_Exp = {
  _and: InputMaybe<Array<Dispute_Bool_Exp>>;
  _not: InputMaybe<Dispute_Bool_Exp>;
  _or: InputMaybe<Array<Dispute_Bool_Exp>>;
  attachments: InputMaybe<DisputeAttachment_Bool_Exp>;
  attachments_aggregate: InputMaybe<DisputeAttachment_Aggregate_Bool_Exp>;
  author: InputMaybe<Customer_Bool_Exp>;
  authorId: InputMaybe<Uuid_Comparison_Exp>;
  canceledAt: InputMaybe<Timestamp_Comparison_Exp>;
  closedAt: InputMaybe<Timestamp_Comparison_Exp>;
  createdAt: InputMaybe<Timestamp_Comparison_Exp>;
  description: InputMaybe<String_Comparison_Exp>;
  id: InputMaybe<String_Comparison_Exp>;
  internalComment: InputMaybe<String_Comparison_Exp>;
  orderLine: InputMaybe<OrderLines_Bool_Exp>;
  orderLineId: InputMaybe<String_Comparison_Exp>;
  reason: InputMaybe<DisputeReason_Comparison_Exp>;
  returns: InputMaybe<Return_Bool_Exp>;
  returns_aggregate: InputMaybe<Return_Aggregate_Bool_Exp>;
  status: InputMaybe<DisputeStatus_Comparison_Exp>;
};

/** unique or primary key constraints on table "Dispute" */
export enum Dispute_Constraint {
  /** unique or primary key constraint on columns "id" */
  DisputePkey = 'Dispute_pkey',
}

/** input type for inserting data into table "Dispute" */
export type Dispute_Insert_Input = {
  attachments: InputMaybe<DisputeAttachment_Arr_Rel_Insert_Input>;
  author: InputMaybe<Customer_Obj_Rel_Insert_Input>;
  authorId: InputMaybe<Scalars['uuid']>;
  canceledAt: InputMaybe<Scalars['timestamp']>;
  closedAt: InputMaybe<Scalars['timestamp']>;
  createdAt: InputMaybe<Scalars['timestamp']>;
  description: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  internalComment: InputMaybe<Scalars['String']>;
  orderLine: InputMaybe<OrderLines_Obj_Rel_Insert_Input>;
  orderLineId: InputMaybe<Scalars['String']>;
  reason: InputMaybe<Scalars['DisputeReason']>;
  returns: InputMaybe<Return_Arr_Rel_Insert_Input>;
  status: InputMaybe<Scalars['DisputeStatus']>;
};

/** aggregate max on columns */
export type Dispute_Max_Fields = {
  __typename?: 'Dispute_max_fields';
  authorId: Maybe<Scalars['uuid']>;
  canceledAt: Maybe<Scalars['timestamp']>;
  closedAt: Maybe<Scalars['timestamp']>;
  createdAt: Maybe<Scalars['timestamp']>;
  description: Maybe<Scalars['String']>;
  id: Maybe<Scalars['String']>;
  internalComment: Maybe<Scalars['String']>;
  orderLineId: Maybe<Scalars['String']>;
  reason: Maybe<Scalars['DisputeReason']>;
  status: Maybe<Scalars['DisputeStatus']>;
};

/** order by max() on columns of table "Dispute" */
export type Dispute_Max_Order_By = {
  authorId: InputMaybe<Order_By>;
  canceledAt: InputMaybe<Order_By>;
  closedAt: InputMaybe<Order_By>;
  createdAt: InputMaybe<Order_By>;
  description: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  internalComment: InputMaybe<Order_By>;
  orderLineId: InputMaybe<Order_By>;
  reason: InputMaybe<Order_By>;
  status: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Dispute_Min_Fields = {
  __typename?: 'Dispute_min_fields';
  authorId: Maybe<Scalars['uuid']>;
  canceledAt: Maybe<Scalars['timestamp']>;
  closedAt: Maybe<Scalars['timestamp']>;
  createdAt: Maybe<Scalars['timestamp']>;
  description: Maybe<Scalars['String']>;
  id: Maybe<Scalars['String']>;
  internalComment: Maybe<Scalars['String']>;
  orderLineId: Maybe<Scalars['String']>;
  reason: Maybe<Scalars['DisputeReason']>;
  status: Maybe<Scalars['DisputeStatus']>;
};

/** order by min() on columns of table "Dispute" */
export type Dispute_Min_Order_By = {
  authorId: InputMaybe<Order_By>;
  canceledAt: InputMaybe<Order_By>;
  closedAt: InputMaybe<Order_By>;
  createdAt: InputMaybe<Order_By>;
  description: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  internalComment: InputMaybe<Order_By>;
  orderLineId: InputMaybe<Order_By>;
  reason: InputMaybe<Order_By>;
  status: InputMaybe<Order_By>;
};

/** response of any mutation on the table "Dispute" */
export type Dispute_Mutation_Response = {
  __typename?: 'Dispute_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Dispute>;
};

/** input type for inserting object relation for remote table "Dispute" */
export type Dispute_Obj_Rel_Insert_Input = {
  data: Dispute_Insert_Input;
  /** upsert condition */
  on_conflict: InputMaybe<Dispute_On_Conflict>;
};

/** on_conflict condition type for table "Dispute" */
export type Dispute_On_Conflict = {
  constraint: Dispute_Constraint;
  update_columns: Array<Dispute_Update_Column>;
  where: InputMaybe<Dispute_Bool_Exp>;
};

/** Ordering options when selecting data from "Dispute". */
export type Dispute_Order_By = {
  attachments_aggregate: InputMaybe<DisputeAttachment_Aggregate_Order_By>;
  author: InputMaybe<Customer_Order_By>;
  authorId: InputMaybe<Order_By>;
  canceledAt: InputMaybe<Order_By>;
  closedAt: InputMaybe<Order_By>;
  createdAt: InputMaybe<Order_By>;
  description: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  internalComment: InputMaybe<Order_By>;
  orderLine: InputMaybe<OrderLines_Order_By>;
  orderLineId: InputMaybe<Order_By>;
  reason: InputMaybe<Order_By>;
  returns_aggregate: InputMaybe<Return_Aggregate_Order_By>;
  status: InputMaybe<Order_By>;
};

/** primary key columns input for table: Dispute */
export type Dispute_Pk_Columns_Input = {
  id: Scalars['String'];
};

/** select columns of table "Dispute" */
export enum Dispute_Select_Column {
  /** column name */
  AuthorId = 'authorId',
  /** column name */
  CanceledAt = 'canceledAt',
  /** column name */
  ClosedAt = 'closedAt',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  InternalComment = 'internalComment',
  /** column name */
  OrderLineId = 'orderLineId',
  /** column name */
  Reason = 'reason',
  /** column name */
  Status = 'status',
}

/** input type for updating data in table "Dispute" */
export type Dispute_Set_Input = {
  authorId: InputMaybe<Scalars['uuid']>;
  canceledAt: InputMaybe<Scalars['timestamp']>;
  closedAt: InputMaybe<Scalars['timestamp']>;
  createdAt: InputMaybe<Scalars['timestamp']>;
  description: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  internalComment: InputMaybe<Scalars['String']>;
  orderLineId: InputMaybe<Scalars['String']>;
  reason: InputMaybe<Scalars['DisputeReason']>;
  status: InputMaybe<Scalars['DisputeStatus']>;
};

/** Streaming cursor of the table "Dispute" */
export type Dispute_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Dispute_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Dispute_Stream_Cursor_Value_Input = {
  authorId: InputMaybe<Scalars['uuid']>;
  canceledAt: InputMaybe<Scalars['timestamp']>;
  closedAt: InputMaybe<Scalars['timestamp']>;
  createdAt: InputMaybe<Scalars['timestamp']>;
  description: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  internalComment: InputMaybe<Scalars['String']>;
  orderLineId: InputMaybe<Scalars['String']>;
  reason: InputMaybe<Scalars['DisputeReason']>;
  status: InputMaybe<Scalars['DisputeStatus']>;
};

/** update columns of table "Dispute" */
export enum Dispute_Update_Column {
  /** column name */
  AuthorId = 'authorId',
  /** column name */
  CanceledAt = 'canceledAt',
  /** column name */
  ClosedAt = 'closedAt',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  InternalComment = 'internalComment',
  /** column name */
  OrderLineId = 'orderLineId',
  /** column name */
  Reason = 'reason',
  /** column name */
  Status = 'status',
}

export type Dispute_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Dispute_Set_Input>;
  /** filter the rows which have to be updated */
  where: Dispute_Bool_Exp;
};

/** columns and relationships of "Event" */
export type Event = {
  __typename?: 'Event';
  aggregateId: Scalars['String'];
  aggregateName: Scalars['AggregateName'];
  createdAt: Scalars['timestamp'];
  id: Scalars['String'];
  metadata: Maybe<Scalars['jsonb']>;
  name: Scalars['EventName'];
  payload: Maybe<Scalars['jsonb']>;
};

/** columns and relationships of "Event" */
export type EventMetadataArgs = {
  path: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "Event" */
export type EventPayloadArgs = {
  path: InputMaybe<Scalars['String']>;
};

/** Boolean expression to compare columns of type "EventName". All fields are combined with logical 'AND'. */
export type EventName_Comparison_Exp = {
  _eq: InputMaybe<Scalars['EventName']>;
  _gt: InputMaybe<Scalars['EventName']>;
  _gte: InputMaybe<Scalars['EventName']>;
  _in: InputMaybe<Array<Scalars['EventName']>>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  _lt: InputMaybe<Scalars['EventName']>;
  _lte: InputMaybe<Scalars['EventName']>;
  _neq: InputMaybe<Scalars['EventName']>;
  _nin: InputMaybe<Array<Scalars['EventName']>>;
};

/** aggregated selection of "Event" */
export type Event_Aggregate = {
  __typename?: 'Event_aggregate';
  aggregate: Maybe<Event_Aggregate_Fields>;
  nodes: Array<Event>;
};

/** aggregate fields of "Event" */
export type Event_Aggregate_Fields = {
  __typename?: 'Event_aggregate_fields';
  count: Scalars['Int'];
  max: Maybe<Event_Max_Fields>;
  min: Maybe<Event_Min_Fields>;
};

/** aggregate fields of "Event" */
export type Event_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Event_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Event_Append_Input = {
  metadata: InputMaybe<Scalars['jsonb']>;
  payload: InputMaybe<Scalars['jsonb']>;
};

/** Boolean expression to filter rows from the table "Event". All fields are combined with a logical 'AND'. */
export type Event_Bool_Exp = {
  _and: InputMaybe<Array<Event_Bool_Exp>>;
  _not: InputMaybe<Event_Bool_Exp>;
  _or: InputMaybe<Array<Event_Bool_Exp>>;
  aggregateId: InputMaybe<String_Comparison_Exp>;
  aggregateName: InputMaybe<AggregateName_Comparison_Exp>;
  createdAt: InputMaybe<Timestamp_Comparison_Exp>;
  id: InputMaybe<String_Comparison_Exp>;
  metadata: InputMaybe<Jsonb_Comparison_Exp>;
  name: InputMaybe<EventName_Comparison_Exp>;
  payload: InputMaybe<Jsonb_Comparison_Exp>;
};

/** unique or primary key constraints on table "Event" */
export enum Event_Constraint {
  /** unique or primary key constraint on columns "id" */
  EventPkey = 'Event_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Event_Delete_At_Path_Input = {
  metadata: InputMaybe<Array<Scalars['String']>>;
  payload: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Event_Delete_Elem_Input = {
  metadata: InputMaybe<Scalars['Int']>;
  payload: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Event_Delete_Key_Input = {
  metadata: InputMaybe<Scalars['String']>;
  payload: InputMaybe<Scalars['String']>;
};

/** input type for inserting data into table "Event" */
export type Event_Insert_Input = {
  aggregateId: InputMaybe<Scalars['String']>;
  aggregateName: InputMaybe<Scalars['AggregateName']>;
  createdAt: InputMaybe<Scalars['timestamp']>;
  id: InputMaybe<Scalars['String']>;
  metadata: InputMaybe<Scalars['jsonb']>;
  name: InputMaybe<Scalars['EventName']>;
  payload: InputMaybe<Scalars['jsonb']>;
};

/** aggregate max on columns */
export type Event_Max_Fields = {
  __typename?: 'Event_max_fields';
  aggregateId: Maybe<Scalars['String']>;
  aggregateName: Maybe<Scalars['AggregateName']>;
  createdAt: Maybe<Scalars['timestamp']>;
  id: Maybe<Scalars['String']>;
  name: Maybe<Scalars['EventName']>;
};

/** aggregate min on columns */
export type Event_Min_Fields = {
  __typename?: 'Event_min_fields';
  aggregateId: Maybe<Scalars['String']>;
  aggregateName: Maybe<Scalars['AggregateName']>;
  createdAt: Maybe<Scalars['timestamp']>;
  id: Maybe<Scalars['String']>;
  name: Maybe<Scalars['EventName']>;
};

/** response of any mutation on the table "Event" */
export type Event_Mutation_Response = {
  __typename?: 'Event_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Event>;
};

/** on_conflict condition type for table "Event" */
export type Event_On_Conflict = {
  constraint: Event_Constraint;
  update_columns: Array<Event_Update_Column>;
  where: InputMaybe<Event_Bool_Exp>;
};

/** Ordering options when selecting data from "Event". */
export type Event_Order_By = {
  aggregateId: InputMaybe<Order_By>;
  aggregateName: InputMaybe<Order_By>;
  createdAt: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  metadata: InputMaybe<Order_By>;
  name: InputMaybe<Order_By>;
  payload: InputMaybe<Order_By>;
};

/** primary key columns input for table: Event */
export type Event_Pk_Columns_Input = {
  id: Scalars['String'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Event_Prepend_Input = {
  metadata: InputMaybe<Scalars['jsonb']>;
  payload: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "Event" */
export enum Event_Select_Column {
  /** column name */
  AggregateId = 'aggregateId',
  /** column name */
  AggregateName = 'aggregateName',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Metadata = 'metadata',
  /** column name */
  Name = 'name',
  /** column name */
  Payload = 'payload',
}

/** input type for updating data in table "Event" */
export type Event_Set_Input = {
  aggregateId: InputMaybe<Scalars['String']>;
  aggregateName: InputMaybe<Scalars['AggregateName']>;
  createdAt: InputMaybe<Scalars['timestamp']>;
  id: InputMaybe<Scalars['String']>;
  metadata: InputMaybe<Scalars['jsonb']>;
  name: InputMaybe<Scalars['EventName']>;
  payload: InputMaybe<Scalars['jsonb']>;
};

/** Streaming cursor of the table "Event" */
export type Event_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Event_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Event_Stream_Cursor_Value_Input = {
  aggregateId: InputMaybe<Scalars['String']>;
  aggregateName: InputMaybe<Scalars['AggregateName']>;
  createdAt: InputMaybe<Scalars['timestamp']>;
  id: InputMaybe<Scalars['String']>;
  metadata: InputMaybe<Scalars['jsonb']>;
  name: InputMaybe<Scalars['EventName']>;
  payload: InputMaybe<Scalars['jsonb']>;
};

/** update columns of table "Event" */
export enum Event_Update_Column {
  /** column name */
  AggregateId = 'aggregateId',
  /** column name */
  AggregateName = 'aggregateName',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Metadata = 'metadata',
  /** column name */
  Name = 'name',
  /** column name */
  Payload = 'payload',
}

export type Event_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append: InputMaybe<Event_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path: InputMaybe<Event_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem: InputMaybe<Event_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key: InputMaybe<Event_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend: InputMaybe<Event_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Event_Set_Input>;
  /** filter the rows which have to be updated */
  where: Event_Bool_Exp;
};

/** columns and relationships of "FacetFilter" */
export type FacetFilter = {
  __typename?: 'FacetFilter';
  /** An object relationship */
  SavedSearch: SavedSearch;
  facetName: Scalars['String'];
  id: Scalars['String'];
  label: Scalars['String'];
  searchId: Scalars['String'];
  value: Scalars['String'];
};

/** aggregated selection of "FacetFilter" */
export type FacetFilter_Aggregate = {
  __typename?: 'FacetFilter_aggregate';
  aggregate: Maybe<FacetFilter_Aggregate_Fields>;
  nodes: Array<FacetFilter>;
};

export type FacetFilter_Aggregate_Bool_Exp = {
  count: InputMaybe<FacetFilter_Aggregate_Bool_Exp_Count>;
};

export type FacetFilter_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<FacetFilter_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<FacetFilter_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "FacetFilter" */
export type FacetFilter_Aggregate_Fields = {
  __typename?: 'FacetFilter_aggregate_fields';
  count: Scalars['Int'];
  max: Maybe<FacetFilter_Max_Fields>;
  min: Maybe<FacetFilter_Min_Fields>;
};

/** aggregate fields of "FacetFilter" */
export type FacetFilter_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<FacetFilter_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "FacetFilter" */
export type FacetFilter_Aggregate_Order_By = {
  count: InputMaybe<Order_By>;
  max: InputMaybe<FacetFilter_Max_Order_By>;
  min: InputMaybe<FacetFilter_Min_Order_By>;
};

/** input type for inserting array relation for remote table "FacetFilter" */
export type FacetFilter_Arr_Rel_Insert_Input = {
  data: Array<FacetFilter_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<FacetFilter_On_Conflict>;
};

/** Boolean expression to filter rows from the table "FacetFilter". All fields are combined with a logical 'AND'. */
export type FacetFilter_Bool_Exp = {
  SavedSearch: InputMaybe<SavedSearch_Bool_Exp>;
  _and: InputMaybe<Array<FacetFilter_Bool_Exp>>;
  _not: InputMaybe<FacetFilter_Bool_Exp>;
  _or: InputMaybe<Array<FacetFilter_Bool_Exp>>;
  facetName: InputMaybe<String_Comparison_Exp>;
  id: InputMaybe<String_Comparison_Exp>;
  label: InputMaybe<String_Comparison_Exp>;
  searchId: InputMaybe<String_Comparison_Exp>;
  value: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "FacetFilter" */
export enum FacetFilter_Constraint {
  /** unique or primary key constraint on columns "id" */
  FacetFilterPkey = 'FacetFilter_pkey',
}

/** input type for inserting data into table "FacetFilter" */
export type FacetFilter_Insert_Input = {
  SavedSearch: InputMaybe<SavedSearch_Obj_Rel_Insert_Input>;
  facetName: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  label: InputMaybe<Scalars['String']>;
  searchId: InputMaybe<Scalars['String']>;
  value: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type FacetFilter_Max_Fields = {
  __typename?: 'FacetFilter_max_fields';
  facetName: Maybe<Scalars['String']>;
  id: Maybe<Scalars['String']>;
  label: Maybe<Scalars['String']>;
  searchId: Maybe<Scalars['String']>;
  value: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "FacetFilter" */
export type FacetFilter_Max_Order_By = {
  facetName: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  label: InputMaybe<Order_By>;
  searchId: InputMaybe<Order_By>;
  value: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type FacetFilter_Min_Fields = {
  __typename?: 'FacetFilter_min_fields';
  facetName: Maybe<Scalars['String']>;
  id: Maybe<Scalars['String']>;
  label: Maybe<Scalars['String']>;
  searchId: Maybe<Scalars['String']>;
  value: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "FacetFilter" */
export type FacetFilter_Min_Order_By = {
  facetName: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  label: InputMaybe<Order_By>;
  searchId: InputMaybe<Order_By>;
  value: InputMaybe<Order_By>;
};

/** response of any mutation on the table "FacetFilter" */
export type FacetFilter_Mutation_Response = {
  __typename?: 'FacetFilter_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<FacetFilter>;
};

/** on_conflict condition type for table "FacetFilter" */
export type FacetFilter_On_Conflict = {
  constraint: FacetFilter_Constraint;
  update_columns: Array<FacetFilter_Update_Column>;
  where: InputMaybe<FacetFilter_Bool_Exp>;
};

/** Ordering options when selecting data from "FacetFilter". */
export type FacetFilter_Order_By = {
  SavedSearch: InputMaybe<SavedSearch_Order_By>;
  facetName: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  label: InputMaybe<Order_By>;
  searchId: InputMaybe<Order_By>;
  value: InputMaybe<Order_By>;
};

/** primary key columns input for table: FacetFilter */
export type FacetFilter_Pk_Columns_Input = {
  id: Scalars['String'];
};

/** select columns of table "FacetFilter" */
export enum FacetFilter_Select_Column {
  /** column name */
  FacetName = 'facetName',
  /** column name */
  Id = 'id',
  /** column name */
  Label = 'label',
  /** column name */
  SearchId = 'searchId',
  /** column name */
  Value = 'value',
}

/** input type for updating data in table "FacetFilter" */
export type FacetFilter_Set_Input = {
  facetName: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  label: InputMaybe<Scalars['String']>;
  searchId: InputMaybe<Scalars['String']>;
  value: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "FacetFilter" */
export type FacetFilter_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: FacetFilter_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type FacetFilter_Stream_Cursor_Value_Input = {
  facetName: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  label: InputMaybe<Scalars['String']>;
  searchId: InputMaybe<Scalars['String']>;
  value: InputMaybe<Scalars['String']>;
};

/** update columns of table "FacetFilter" */
export enum FacetFilter_Update_Column {
  /** column name */
  FacetName = 'facetName',
  /** column name */
  Id = 'id',
  /** column name */
  Label = 'label',
  /** column name */
  SearchId = 'searchId',
  /** column name */
  Value = 'value',
}

export type FacetFilter_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<FacetFilter_Set_Input>;
  /** filter the rows which have to be updated */
  where: FacetFilter_Bool_Exp;
};

/** columns and relationships of "FavoriteProducts" */
export type FavoriteProducts = {
  __typename?: 'FavoriteProducts';
  createdAt: Maybe<Scalars['timestamp']>;
  customerId: Maybe<Scalars['uuid']>;
  id: Scalars['String'];
  /** An object relationship */
  product: Maybe<Product>;
  productId: Scalars['bigint'];
};

/** aggregated selection of "FavoriteProducts" */
export type FavoriteProducts_Aggregate = {
  __typename?: 'FavoriteProducts_aggregate';
  aggregate: Maybe<FavoriteProducts_Aggregate_Fields>;
  nodes: Array<FavoriteProducts>;
};

export type FavoriteProducts_Aggregate_Bool_Exp = {
  count: InputMaybe<FavoriteProducts_Aggregate_Bool_Exp_Count>;
};

export type FavoriteProducts_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<FavoriteProducts_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<FavoriteProducts_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "FavoriteProducts" */
export type FavoriteProducts_Aggregate_Fields = {
  __typename?: 'FavoriteProducts_aggregate_fields';
  avg: Maybe<FavoriteProducts_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<FavoriteProducts_Max_Fields>;
  min: Maybe<FavoriteProducts_Min_Fields>;
  stddev: Maybe<FavoriteProducts_Stddev_Fields>;
  stddev_pop: Maybe<FavoriteProducts_Stddev_Pop_Fields>;
  stddev_samp: Maybe<FavoriteProducts_Stddev_Samp_Fields>;
  sum: Maybe<FavoriteProducts_Sum_Fields>;
  var_pop: Maybe<FavoriteProducts_Var_Pop_Fields>;
  var_samp: Maybe<FavoriteProducts_Var_Samp_Fields>;
  variance: Maybe<FavoriteProducts_Variance_Fields>;
};

/** aggregate fields of "FavoriteProducts" */
export type FavoriteProducts_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<FavoriteProducts_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "FavoriteProducts" */
export type FavoriteProducts_Aggregate_Order_By = {
  avg: InputMaybe<FavoriteProducts_Avg_Order_By>;
  count: InputMaybe<Order_By>;
  max: InputMaybe<FavoriteProducts_Max_Order_By>;
  min: InputMaybe<FavoriteProducts_Min_Order_By>;
  stddev: InputMaybe<FavoriteProducts_Stddev_Order_By>;
  stddev_pop: InputMaybe<FavoriteProducts_Stddev_Pop_Order_By>;
  stddev_samp: InputMaybe<FavoriteProducts_Stddev_Samp_Order_By>;
  sum: InputMaybe<FavoriteProducts_Sum_Order_By>;
  var_pop: InputMaybe<FavoriteProducts_Var_Pop_Order_By>;
  var_samp: InputMaybe<FavoriteProducts_Var_Samp_Order_By>;
  variance: InputMaybe<FavoriteProducts_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "FavoriteProducts" */
export type FavoriteProducts_Arr_Rel_Insert_Input = {
  data: Array<FavoriteProducts_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<FavoriteProducts_On_Conflict>;
};

/** aggregate avg on columns */
export type FavoriteProducts_Avg_Fields = {
  __typename?: 'FavoriteProducts_avg_fields';
  productId: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "FavoriteProducts" */
export type FavoriteProducts_Avg_Order_By = {
  productId: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "FavoriteProducts". All fields are combined with a logical 'AND'. */
export type FavoriteProducts_Bool_Exp = {
  _and: InputMaybe<Array<FavoriteProducts_Bool_Exp>>;
  _not: InputMaybe<FavoriteProducts_Bool_Exp>;
  _or: InputMaybe<Array<FavoriteProducts_Bool_Exp>>;
  createdAt: InputMaybe<Timestamp_Comparison_Exp>;
  customerId: InputMaybe<Uuid_Comparison_Exp>;
  id: InputMaybe<String_Comparison_Exp>;
  product: InputMaybe<Product_Bool_Exp>;
  productId: InputMaybe<Bigint_Comparison_Exp>;
};

/** unique or primary key constraints on table "FavoriteProducts" */
export enum FavoriteProducts_Constraint {
  /** unique or primary key constraint on columns "id" */
  FavoriteProductsPkey = 'FavoriteProducts_pkey',
}

/** input type for incrementing numeric columns in table "FavoriteProducts" */
export type FavoriteProducts_Inc_Input = {
  productId: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "FavoriteProducts" */
export type FavoriteProducts_Insert_Input = {
  createdAt: InputMaybe<Scalars['timestamp']>;
  customerId: InputMaybe<Scalars['uuid']>;
  id: InputMaybe<Scalars['String']>;
  product: InputMaybe<Product_Obj_Rel_Insert_Input>;
  productId: InputMaybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type FavoriteProducts_Max_Fields = {
  __typename?: 'FavoriteProducts_max_fields';
  createdAt: Maybe<Scalars['timestamp']>;
  customerId: Maybe<Scalars['uuid']>;
  id: Maybe<Scalars['String']>;
  productId: Maybe<Scalars['bigint']>;
};

/** order by max() on columns of table "FavoriteProducts" */
export type FavoriteProducts_Max_Order_By = {
  createdAt: InputMaybe<Order_By>;
  customerId: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  productId: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type FavoriteProducts_Min_Fields = {
  __typename?: 'FavoriteProducts_min_fields';
  createdAt: Maybe<Scalars['timestamp']>;
  customerId: Maybe<Scalars['uuid']>;
  id: Maybe<Scalars['String']>;
  productId: Maybe<Scalars['bigint']>;
};

/** order by min() on columns of table "FavoriteProducts" */
export type FavoriteProducts_Min_Order_By = {
  createdAt: InputMaybe<Order_By>;
  customerId: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  productId: InputMaybe<Order_By>;
};

/** response of any mutation on the table "FavoriteProducts" */
export type FavoriteProducts_Mutation_Response = {
  __typename?: 'FavoriteProducts_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<FavoriteProducts>;
};

/** on_conflict condition type for table "FavoriteProducts" */
export type FavoriteProducts_On_Conflict = {
  constraint: FavoriteProducts_Constraint;
  update_columns: Array<FavoriteProducts_Update_Column>;
  where: InputMaybe<FavoriteProducts_Bool_Exp>;
};

/** Ordering options when selecting data from "FavoriteProducts". */
export type FavoriteProducts_Order_By = {
  createdAt: InputMaybe<Order_By>;
  customerId: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  product: InputMaybe<Product_Order_By>;
  productId: InputMaybe<Order_By>;
};

/** primary key columns input for table: FavoriteProducts */
export type FavoriteProducts_Pk_Columns_Input = {
  id: Scalars['String'];
};

/** select columns of table "FavoriteProducts" */
export enum FavoriteProducts_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CustomerId = 'customerId',
  /** column name */
  Id = 'id',
  /** column name */
  ProductId = 'productId',
}

/** input type for updating data in table "FavoriteProducts" */
export type FavoriteProducts_Set_Input = {
  createdAt: InputMaybe<Scalars['timestamp']>;
  customerId: InputMaybe<Scalars['uuid']>;
  id: InputMaybe<Scalars['String']>;
  productId: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type FavoriteProducts_Stddev_Fields = {
  __typename?: 'FavoriteProducts_stddev_fields';
  productId: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "FavoriteProducts" */
export type FavoriteProducts_Stddev_Order_By = {
  productId: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type FavoriteProducts_Stddev_Pop_Fields = {
  __typename?: 'FavoriteProducts_stddev_pop_fields';
  productId: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "FavoriteProducts" */
export type FavoriteProducts_Stddev_Pop_Order_By = {
  productId: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type FavoriteProducts_Stddev_Samp_Fields = {
  __typename?: 'FavoriteProducts_stddev_samp_fields';
  productId: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "FavoriteProducts" */
export type FavoriteProducts_Stddev_Samp_Order_By = {
  productId: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "FavoriteProducts" */
export type FavoriteProducts_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: FavoriteProducts_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type FavoriteProducts_Stream_Cursor_Value_Input = {
  createdAt: InputMaybe<Scalars['timestamp']>;
  customerId: InputMaybe<Scalars['uuid']>;
  id: InputMaybe<Scalars['String']>;
  productId: InputMaybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type FavoriteProducts_Sum_Fields = {
  __typename?: 'FavoriteProducts_sum_fields';
  productId: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "FavoriteProducts" */
export type FavoriteProducts_Sum_Order_By = {
  productId: InputMaybe<Order_By>;
};

/** update columns of table "FavoriteProducts" */
export enum FavoriteProducts_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CustomerId = 'customerId',
  /** column name */
  Id = 'id',
  /** column name */
  ProductId = 'productId',
}

export type FavoriteProducts_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<FavoriteProducts_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<FavoriteProducts_Set_Input>;
  /** filter the rows which have to be updated */
  where: FavoriteProducts_Bool_Exp;
};

/** aggregate var_pop on columns */
export type FavoriteProducts_Var_Pop_Fields = {
  __typename?: 'FavoriteProducts_var_pop_fields';
  productId: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "FavoriteProducts" */
export type FavoriteProducts_Var_Pop_Order_By = {
  productId: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type FavoriteProducts_Var_Samp_Fields = {
  __typename?: 'FavoriteProducts_var_samp_fields';
  productId: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "FavoriteProducts" */
export type FavoriteProducts_Var_Samp_Order_By = {
  productId: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type FavoriteProducts_Variance_Fields = {
  __typename?: 'FavoriteProducts_variance_fields';
  productId: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "FavoriteProducts" */
export type FavoriteProducts_Variance_Order_By = {
  productId: InputMaybe<Order_By>;
};

/** columns and relationships of "Fulfillment" */
export type Fulfillment = {
  __typename?: 'Fulfillment';
  createdAt: Scalars['timestamp'];
  /** An array relationship */
  fulfilledItems: Array<FulfillmentItem>;
  /** An aggregate relationship */
  fulfilledItems_aggregate: FulfillmentItem_Aggregate;
  /** An object relationship */
  fulfillmentOrder: Maybe<FulfillmentOrder>;
  fulfillmentOrderId: Scalars['String'];
  id: Scalars['String'];
  shopifyId: Scalars['bigint'];
  status: Scalars['FulfillmentStatus'];
  trackingId: Maybe<Scalars['String']>;
  trackingUrl: Scalars['String'];
};

/** columns and relationships of "Fulfillment" */
export type FulfillmentFulfilledItemsArgs = {
  distinct_on: InputMaybe<Array<FulfillmentItem_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<FulfillmentItem_Order_By>>;
  where: InputMaybe<FulfillmentItem_Bool_Exp>;
};

/** columns and relationships of "Fulfillment" */
export type FulfillmentFulfilledItems_AggregateArgs = {
  distinct_on: InputMaybe<Array<FulfillmentItem_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<FulfillmentItem_Order_By>>;
  where: InputMaybe<FulfillmentItem_Bool_Exp>;
};

/** columns and relationships of "FulfillmentItem" */
export type FulfillmentItem = {
  __typename?: 'FulfillmentItem';
  createdAt: Scalars['timestamp'];
  fulfillmentId: Scalars['String'];
  id: Scalars['String'];
  /** An object relationship */
  productVariant: Maybe<ProductVariant>;
  productVariantId: Scalars['String'];
  quantity: Scalars['Int'];
  shopifyId: Scalars['bigint'];
};

/** aggregated selection of "FulfillmentItem" */
export type FulfillmentItem_Aggregate = {
  __typename?: 'FulfillmentItem_aggregate';
  aggregate: Maybe<FulfillmentItem_Aggregate_Fields>;
  nodes: Array<FulfillmentItem>;
};

export type FulfillmentItem_Aggregate_Bool_Exp = {
  count: InputMaybe<FulfillmentItem_Aggregate_Bool_Exp_Count>;
};

export type FulfillmentItem_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<FulfillmentItem_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<FulfillmentItem_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "FulfillmentItem" */
export type FulfillmentItem_Aggregate_Fields = {
  __typename?: 'FulfillmentItem_aggregate_fields';
  avg: Maybe<FulfillmentItem_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<FulfillmentItem_Max_Fields>;
  min: Maybe<FulfillmentItem_Min_Fields>;
  stddev: Maybe<FulfillmentItem_Stddev_Fields>;
  stddev_pop: Maybe<FulfillmentItem_Stddev_Pop_Fields>;
  stddev_samp: Maybe<FulfillmentItem_Stddev_Samp_Fields>;
  sum: Maybe<FulfillmentItem_Sum_Fields>;
  var_pop: Maybe<FulfillmentItem_Var_Pop_Fields>;
  var_samp: Maybe<FulfillmentItem_Var_Samp_Fields>;
  variance: Maybe<FulfillmentItem_Variance_Fields>;
};

/** aggregate fields of "FulfillmentItem" */
export type FulfillmentItem_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<FulfillmentItem_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "FulfillmentItem" */
export type FulfillmentItem_Aggregate_Order_By = {
  avg: InputMaybe<FulfillmentItem_Avg_Order_By>;
  count: InputMaybe<Order_By>;
  max: InputMaybe<FulfillmentItem_Max_Order_By>;
  min: InputMaybe<FulfillmentItem_Min_Order_By>;
  stddev: InputMaybe<FulfillmentItem_Stddev_Order_By>;
  stddev_pop: InputMaybe<FulfillmentItem_Stddev_Pop_Order_By>;
  stddev_samp: InputMaybe<FulfillmentItem_Stddev_Samp_Order_By>;
  sum: InputMaybe<FulfillmentItem_Sum_Order_By>;
  var_pop: InputMaybe<FulfillmentItem_Var_Pop_Order_By>;
  var_samp: InputMaybe<FulfillmentItem_Var_Samp_Order_By>;
  variance: InputMaybe<FulfillmentItem_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "FulfillmentItem" */
export type FulfillmentItem_Arr_Rel_Insert_Input = {
  data: Array<FulfillmentItem_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<FulfillmentItem_On_Conflict>;
};

/** aggregate avg on columns */
export type FulfillmentItem_Avg_Fields = {
  __typename?: 'FulfillmentItem_avg_fields';
  quantity: Maybe<Scalars['Float']>;
  shopifyId: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "FulfillmentItem" */
export type FulfillmentItem_Avg_Order_By = {
  quantity: InputMaybe<Order_By>;
  shopifyId: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "FulfillmentItem". All fields are combined with a logical 'AND'. */
export type FulfillmentItem_Bool_Exp = {
  _and: InputMaybe<Array<FulfillmentItem_Bool_Exp>>;
  _not: InputMaybe<FulfillmentItem_Bool_Exp>;
  _or: InputMaybe<Array<FulfillmentItem_Bool_Exp>>;
  createdAt: InputMaybe<Timestamp_Comparison_Exp>;
  fulfillmentId: InputMaybe<String_Comparison_Exp>;
  id: InputMaybe<String_Comparison_Exp>;
  productVariant: InputMaybe<ProductVariant_Bool_Exp>;
  productVariantId: InputMaybe<String_Comparison_Exp>;
  quantity: InputMaybe<Int_Comparison_Exp>;
  shopifyId: InputMaybe<Bigint_Comparison_Exp>;
};

/** unique or primary key constraints on table "FulfillmentItem" */
export enum FulfillmentItem_Constraint {
  /** unique or primary key constraint on columns "id" */
  FulfillmentItemPkey = 'FulfillmentItem_pkey',
  /** unique or primary key constraint on columns "shopifyId" */
  FulfillmentItemShopifyIdKey = 'FulfillmentItem_shopifyId_key',
}

/** input type for incrementing numeric columns in table "FulfillmentItem" */
export type FulfillmentItem_Inc_Input = {
  quantity: InputMaybe<Scalars['Int']>;
  shopifyId: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "FulfillmentItem" */
export type FulfillmentItem_Insert_Input = {
  createdAt: InputMaybe<Scalars['timestamp']>;
  fulfillmentId: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  productVariant: InputMaybe<ProductVariant_Obj_Rel_Insert_Input>;
  productVariantId: InputMaybe<Scalars['String']>;
  quantity: InputMaybe<Scalars['Int']>;
  shopifyId: InputMaybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type FulfillmentItem_Max_Fields = {
  __typename?: 'FulfillmentItem_max_fields';
  createdAt: Maybe<Scalars['timestamp']>;
  fulfillmentId: Maybe<Scalars['String']>;
  id: Maybe<Scalars['String']>;
  productVariantId: Maybe<Scalars['String']>;
  quantity: Maybe<Scalars['Int']>;
  shopifyId: Maybe<Scalars['bigint']>;
};

/** order by max() on columns of table "FulfillmentItem" */
export type FulfillmentItem_Max_Order_By = {
  createdAt: InputMaybe<Order_By>;
  fulfillmentId: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  productVariantId: InputMaybe<Order_By>;
  quantity: InputMaybe<Order_By>;
  shopifyId: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type FulfillmentItem_Min_Fields = {
  __typename?: 'FulfillmentItem_min_fields';
  createdAt: Maybe<Scalars['timestamp']>;
  fulfillmentId: Maybe<Scalars['String']>;
  id: Maybe<Scalars['String']>;
  productVariantId: Maybe<Scalars['String']>;
  quantity: Maybe<Scalars['Int']>;
  shopifyId: Maybe<Scalars['bigint']>;
};

/** order by min() on columns of table "FulfillmentItem" */
export type FulfillmentItem_Min_Order_By = {
  createdAt: InputMaybe<Order_By>;
  fulfillmentId: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  productVariantId: InputMaybe<Order_By>;
  quantity: InputMaybe<Order_By>;
  shopifyId: InputMaybe<Order_By>;
};

/** response of any mutation on the table "FulfillmentItem" */
export type FulfillmentItem_Mutation_Response = {
  __typename?: 'FulfillmentItem_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<FulfillmentItem>;
};

/** input type for inserting object relation for remote table "FulfillmentItem" */
export type FulfillmentItem_Obj_Rel_Insert_Input = {
  data: FulfillmentItem_Insert_Input;
  /** upsert condition */
  on_conflict: InputMaybe<FulfillmentItem_On_Conflict>;
};

/** on_conflict condition type for table "FulfillmentItem" */
export type FulfillmentItem_On_Conflict = {
  constraint: FulfillmentItem_Constraint;
  update_columns: Array<FulfillmentItem_Update_Column>;
  where: InputMaybe<FulfillmentItem_Bool_Exp>;
};

/** Ordering options when selecting data from "FulfillmentItem". */
export type FulfillmentItem_Order_By = {
  createdAt: InputMaybe<Order_By>;
  fulfillmentId: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  productVariant: InputMaybe<ProductVariant_Order_By>;
  productVariantId: InputMaybe<Order_By>;
  quantity: InputMaybe<Order_By>;
  shopifyId: InputMaybe<Order_By>;
};

/** primary key columns input for table: FulfillmentItem */
export type FulfillmentItem_Pk_Columns_Input = {
  id: Scalars['String'];
};

/** select columns of table "FulfillmentItem" */
export enum FulfillmentItem_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  FulfillmentId = 'fulfillmentId',
  /** column name */
  Id = 'id',
  /** column name */
  ProductVariantId = 'productVariantId',
  /** column name */
  Quantity = 'quantity',
  /** column name */
  ShopifyId = 'shopifyId',
}

/** input type for updating data in table "FulfillmentItem" */
export type FulfillmentItem_Set_Input = {
  createdAt: InputMaybe<Scalars['timestamp']>;
  fulfillmentId: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  productVariantId: InputMaybe<Scalars['String']>;
  quantity: InputMaybe<Scalars['Int']>;
  shopifyId: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type FulfillmentItem_Stddev_Fields = {
  __typename?: 'FulfillmentItem_stddev_fields';
  quantity: Maybe<Scalars['Float']>;
  shopifyId: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "FulfillmentItem" */
export type FulfillmentItem_Stddev_Order_By = {
  quantity: InputMaybe<Order_By>;
  shopifyId: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type FulfillmentItem_Stddev_Pop_Fields = {
  __typename?: 'FulfillmentItem_stddev_pop_fields';
  quantity: Maybe<Scalars['Float']>;
  shopifyId: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "FulfillmentItem" */
export type FulfillmentItem_Stddev_Pop_Order_By = {
  quantity: InputMaybe<Order_By>;
  shopifyId: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type FulfillmentItem_Stddev_Samp_Fields = {
  __typename?: 'FulfillmentItem_stddev_samp_fields';
  quantity: Maybe<Scalars['Float']>;
  shopifyId: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "FulfillmentItem" */
export type FulfillmentItem_Stddev_Samp_Order_By = {
  quantity: InputMaybe<Order_By>;
  shopifyId: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "FulfillmentItem" */
export type FulfillmentItem_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: FulfillmentItem_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type FulfillmentItem_Stream_Cursor_Value_Input = {
  createdAt: InputMaybe<Scalars['timestamp']>;
  fulfillmentId: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  productVariantId: InputMaybe<Scalars['String']>;
  quantity: InputMaybe<Scalars['Int']>;
  shopifyId: InputMaybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type FulfillmentItem_Sum_Fields = {
  __typename?: 'FulfillmentItem_sum_fields';
  quantity: Maybe<Scalars['Int']>;
  shopifyId: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "FulfillmentItem" */
export type FulfillmentItem_Sum_Order_By = {
  quantity: InputMaybe<Order_By>;
  shopifyId: InputMaybe<Order_By>;
};

/** update columns of table "FulfillmentItem" */
export enum FulfillmentItem_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  FulfillmentId = 'fulfillmentId',
  /** column name */
  Id = 'id',
  /** column name */
  ProductVariantId = 'productVariantId',
  /** column name */
  Quantity = 'quantity',
  /** column name */
  ShopifyId = 'shopifyId',
}

export type FulfillmentItem_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<FulfillmentItem_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<FulfillmentItem_Set_Input>;
  /** filter the rows which have to be updated */
  where: FulfillmentItem_Bool_Exp;
};

/** aggregate var_pop on columns */
export type FulfillmentItem_Var_Pop_Fields = {
  __typename?: 'FulfillmentItem_var_pop_fields';
  quantity: Maybe<Scalars['Float']>;
  shopifyId: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "FulfillmentItem" */
export type FulfillmentItem_Var_Pop_Order_By = {
  quantity: InputMaybe<Order_By>;
  shopifyId: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type FulfillmentItem_Var_Samp_Fields = {
  __typename?: 'FulfillmentItem_var_samp_fields';
  quantity: Maybe<Scalars['Float']>;
  shopifyId: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "FulfillmentItem" */
export type FulfillmentItem_Var_Samp_Order_By = {
  quantity: InputMaybe<Order_By>;
  shopifyId: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type FulfillmentItem_Variance_Fields = {
  __typename?: 'FulfillmentItem_variance_fields';
  quantity: Maybe<Scalars['Float']>;
  shopifyId: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "FulfillmentItem" */
export type FulfillmentItem_Variance_Order_By = {
  quantity: InputMaybe<Order_By>;
  shopifyId: InputMaybe<Order_By>;
};

/** columns and relationships of "FulfillmentOrder" */
export type FulfillmentOrder = {
  __typename?: 'FulfillmentOrder';
  externalOrderId: Maybe<Scalars['String']>;
  /** An array relationship */
  fulfillments: Array<Fulfillment>;
  /** An aggregate relationship */
  fulfillments_aggregate: Fulfillment_Aggregate;
  id: Scalars['String'];
  /** An object relationship */
  order: Maybe<Order>;
  orderId: Scalars['String'];
  /** An array relationship */
  orderLines: Array<OrderLines>;
  /** An aggregate relationship */
  orderLines_aggregate: OrderLines_Aggregate;
  shopifyId: Scalars['bigint'];
  status: Scalars['FulfillmentOrderStatus'];
};

/** columns and relationships of "FulfillmentOrder" */
export type FulfillmentOrderFulfillmentsArgs = {
  distinct_on: InputMaybe<Array<Fulfillment_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Fulfillment_Order_By>>;
  where: InputMaybe<Fulfillment_Bool_Exp>;
};

/** columns and relationships of "FulfillmentOrder" */
export type FulfillmentOrderFulfillments_AggregateArgs = {
  distinct_on: InputMaybe<Array<Fulfillment_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Fulfillment_Order_By>>;
  where: InputMaybe<Fulfillment_Bool_Exp>;
};

/** columns and relationships of "FulfillmentOrder" */
export type FulfillmentOrderOrderLinesArgs = {
  distinct_on: InputMaybe<Array<OrderLines_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<OrderLines_Order_By>>;
  where: InputMaybe<OrderLines_Bool_Exp>;
};

/** columns and relationships of "FulfillmentOrder" */
export type FulfillmentOrderOrderLines_AggregateArgs = {
  distinct_on: InputMaybe<Array<OrderLines_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<OrderLines_Order_By>>;
  where: InputMaybe<OrderLines_Bool_Exp>;
};

/** Boolean expression to compare columns of type "FulfillmentOrderStatus". All fields are combined with logical 'AND'. */
export type FulfillmentOrderStatus_Comparison_Exp = {
  _eq: InputMaybe<Scalars['FulfillmentOrderStatus']>;
  _gt: InputMaybe<Scalars['FulfillmentOrderStatus']>;
  _gte: InputMaybe<Scalars['FulfillmentOrderStatus']>;
  _in: InputMaybe<Array<Scalars['FulfillmentOrderStatus']>>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  _lt: InputMaybe<Scalars['FulfillmentOrderStatus']>;
  _lte: InputMaybe<Scalars['FulfillmentOrderStatus']>;
  _neq: InputMaybe<Scalars['FulfillmentOrderStatus']>;
  _nin: InputMaybe<Array<Scalars['FulfillmentOrderStatus']>>;
};

/** aggregated selection of "FulfillmentOrder" */
export type FulfillmentOrder_Aggregate = {
  __typename?: 'FulfillmentOrder_aggregate';
  aggregate: Maybe<FulfillmentOrder_Aggregate_Fields>;
  nodes: Array<FulfillmentOrder>;
};

export type FulfillmentOrder_Aggregate_Bool_Exp = {
  count: InputMaybe<FulfillmentOrder_Aggregate_Bool_Exp_Count>;
};

export type FulfillmentOrder_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<FulfillmentOrder_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<FulfillmentOrder_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "FulfillmentOrder" */
export type FulfillmentOrder_Aggregate_Fields = {
  __typename?: 'FulfillmentOrder_aggregate_fields';
  avg: Maybe<FulfillmentOrder_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<FulfillmentOrder_Max_Fields>;
  min: Maybe<FulfillmentOrder_Min_Fields>;
  stddev: Maybe<FulfillmentOrder_Stddev_Fields>;
  stddev_pop: Maybe<FulfillmentOrder_Stddev_Pop_Fields>;
  stddev_samp: Maybe<FulfillmentOrder_Stddev_Samp_Fields>;
  sum: Maybe<FulfillmentOrder_Sum_Fields>;
  var_pop: Maybe<FulfillmentOrder_Var_Pop_Fields>;
  var_samp: Maybe<FulfillmentOrder_Var_Samp_Fields>;
  variance: Maybe<FulfillmentOrder_Variance_Fields>;
};

/** aggregate fields of "FulfillmentOrder" */
export type FulfillmentOrder_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<FulfillmentOrder_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "FulfillmentOrder" */
export type FulfillmentOrder_Aggregate_Order_By = {
  avg: InputMaybe<FulfillmentOrder_Avg_Order_By>;
  count: InputMaybe<Order_By>;
  max: InputMaybe<FulfillmentOrder_Max_Order_By>;
  min: InputMaybe<FulfillmentOrder_Min_Order_By>;
  stddev: InputMaybe<FulfillmentOrder_Stddev_Order_By>;
  stddev_pop: InputMaybe<FulfillmentOrder_Stddev_Pop_Order_By>;
  stddev_samp: InputMaybe<FulfillmentOrder_Stddev_Samp_Order_By>;
  sum: InputMaybe<FulfillmentOrder_Sum_Order_By>;
  var_pop: InputMaybe<FulfillmentOrder_Var_Pop_Order_By>;
  var_samp: InputMaybe<FulfillmentOrder_Var_Samp_Order_By>;
  variance: InputMaybe<FulfillmentOrder_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "FulfillmentOrder" */
export type FulfillmentOrder_Arr_Rel_Insert_Input = {
  data: Array<FulfillmentOrder_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<FulfillmentOrder_On_Conflict>;
};

/** aggregate avg on columns */
export type FulfillmentOrder_Avg_Fields = {
  __typename?: 'FulfillmentOrder_avg_fields';
  shopifyId: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "FulfillmentOrder" */
export type FulfillmentOrder_Avg_Order_By = {
  shopifyId: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "FulfillmentOrder". All fields are combined with a logical 'AND'. */
export type FulfillmentOrder_Bool_Exp = {
  _and: InputMaybe<Array<FulfillmentOrder_Bool_Exp>>;
  _not: InputMaybe<FulfillmentOrder_Bool_Exp>;
  _or: InputMaybe<Array<FulfillmentOrder_Bool_Exp>>;
  externalOrderId: InputMaybe<String_Comparison_Exp>;
  fulfillments: InputMaybe<Fulfillment_Bool_Exp>;
  fulfillments_aggregate: InputMaybe<Fulfillment_Aggregate_Bool_Exp>;
  id: InputMaybe<String_Comparison_Exp>;
  order: InputMaybe<Order_Bool_Exp>;
  orderId: InputMaybe<String_Comparison_Exp>;
  orderLines: InputMaybe<OrderLines_Bool_Exp>;
  orderLines_aggregate: InputMaybe<OrderLines_Aggregate_Bool_Exp>;
  shopifyId: InputMaybe<Bigint_Comparison_Exp>;
  status: InputMaybe<FulfillmentOrderStatus_Comparison_Exp>;
};

/** unique or primary key constraints on table "FulfillmentOrder" */
export enum FulfillmentOrder_Constraint {
  /** unique or primary key constraint on columns "id" */
  FulfillmentOrderPkey = 'FulfillmentOrder_pkey',
  /** unique or primary key constraint on columns "shopifyId" */
  FulfillmentOrderShopifyIdKey = 'FulfillmentOrder_shopifyId_key',
}

/** input type for incrementing numeric columns in table "FulfillmentOrder" */
export type FulfillmentOrder_Inc_Input = {
  shopifyId: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "FulfillmentOrder" */
export type FulfillmentOrder_Insert_Input = {
  externalOrderId: InputMaybe<Scalars['String']>;
  fulfillments: InputMaybe<Fulfillment_Arr_Rel_Insert_Input>;
  id: InputMaybe<Scalars['String']>;
  order: InputMaybe<Order_Obj_Rel_Insert_Input>;
  orderId: InputMaybe<Scalars['String']>;
  orderLines: InputMaybe<OrderLines_Arr_Rel_Insert_Input>;
  shopifyId: InputMaybe<Scalars['bigint']>;
  status: InputMaybe<Scalars['FulfillmentOrderStatus']>;
};

/** aggregate max on columns */
export type FulfillmentOrder_Max_Fields = {
  __typename?: 'FulfillmentOrder_max_fields';
  externalOrderId: Maybe<Scalars['String']>;
  id: Maybe<Scalars['String']>;
  orderId: Maybe<Scalars['String']>;
  shopifyId: Maybe<Scalars['bigint']>;
  status: Maybe<Scalars['FulfillmentOrderStatus']>;
};

/** order by max() on columns of table "FulfillmentOrder" */
export type FulfillmentOrder_Max_Order_By = {
  externalOrderId: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  orderId: InputMaybe<Order_By>;
  shopifyId: InputMaybe<Order_By>;
  status: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type FulfillmentOrder_Min_Fields = {
  __typename?: 'FulfillmentOrder_min_fields';
  externalOrderId: Maybe<Scalars['String']>;
  id: Maybe<Scalars['String']>;
  orderId: Maybe<Scalars['String']>;
  shopifyId: Maybe<Scalars['bigint']>;
  status: Maybe<Scalars['FulfillmentOrderStatus']>;
};

/** order by min() on columns of table "FulfillmentOrder" */
export type FulfillmentOrder_Min_Order_By = {
  externalOrderId: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  orderId: InputMaybe<Order_By>;
  shopifyId: InputMaybe<Order_By>;
  status: InputMaybe<Order_By>;
};

/** response of any mutation on the table "FulfillmentOrder" */
export type FulfillmentOrder_Mutation_Response = {
  __typename?: 'FulfillmentOrder_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<FulfillmentOrder>;
};

/** input type for inserting object relation for remote table "FulfillmentOrder" */
export type FulfillmentOrder_Obj_Rel_Insert_Input = {
  data: FulfillmentOrder_Insert_Input;
  /** upsert condition */
  on_conflict: InputMaybe<FulfillmentOrder_On_Conflict>;
};

/** on_conflict condition type for table "FulfillmentOrder" */
export type FulfillmentOrder_On_Conflict = {
  constraint: FulfillmentOrder_Constraint;
  update_columns: Array<FulfillmentOrder_Update_Column>;
  where: InputMaybe<FulfillmentOrder_Bool_Exp>;
};

/** Ordering options when selecting data from "FulfillmentOrder". */
export type FulfillmentOrder_Order_By = {
  externalOrderId: InputMaybe<Order_By>;
  fulfillments_aggregate: InputMaybe<Fulfillment_Aggregate_Order_By>;
  id: InputMaybe<Order_By>;
  order: InputMaybe<Order_Order_By>;
  orderId: InputMaybe<Order_By>;
  orderLines_aggregate: InputMaybe<OrderLines_Aggregate_Order_By>;
  shopifyId: InputMaybe<Order_By>;
  status: InputMaybe<Order_By>;
};

/** primary key columns input for table: FulfillmentOrder */
export type FulfillmentOrder_Pk_Columns_Input = {
  id: Scalars['String'];
};

/** select columns of table "FulfillmentOrder" */
export enum FulfillmentOrder_Select_Column {
  /** column name */
  ExternalOrderId = 'externalOrderId',
  /** column name */
  Id = 'id',
  /** column name */
  OrderId = 'orderId',
  /** column name */
  ShopifyId = 'shopifyId',
  /** column name */
  Status = 'status',
}

/** input type for updating data in table "FulfillmentOrder" */
export type FulfillmentOrder_Set_Input = {
  externalOrderId: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  orderId: InputMaybe<Scalars['String']>;
  shopifyId: InputMaybe<Scalars['bigint']>;
  status: InputMaybe<Scalars['FulfillmentOrderStatus']>;
};

/** aggregate stddev on columns */
export type FulfillmentOrder_Stddev_Fields = {
  __typename?: 'FulfillmentOrder_stddev_fields';
  shopifyId: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "FulfillmentOrder" */
export type FulfillmentOrder_Stddev_Order_By = {
  shopifyId: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type FulfillmentOrder_Stddev_Pop_Fields = {
  __typename?: 'FulfillmentOrder_stddev_pop_fields';
  shopifyId: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "FulfillmentOrder" */
export type FulfillmentOrder_Stddev_Pop_Order_By = {
  shopifyId: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type FulfillmentOrder_Stddev_Samp_Fields = {
  __typename?: 'FulfillmentOrder_stddev_samp_fields';
  shopifyId: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "FulfillmentOrder" */
export type FulfillmentOrder_Stddev_Samp_Order_By = {
  shopifyId: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "FulfillmentOrder" */
export type FulfillmentOrder_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: FulfillmentOrder_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type FulfillmentOrder_Stream_Cursor_Value_Input = {
  externalOrderId: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  orderId: InputMaybe<Scalars['String']>;
  shopifyId: InputMaybe<Scalars['bigint']>;
  status: InputMaybe<Scalars['FulfillmentOrderStatus']>;
};

/** aggregate sum on columns */
export type FulfillmentOrder_Sum_Fields = {
  __typename?: 'FulfillmentOrder_sum_fields';
  shopifyId: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "FulfillmentOrder" */
export type FulfillmentOrder_Sum_Order_By = {
  shopifyId: InputMaybe<Order_By>;
};

/** update columns of table "FulfillmentOrder" */
export enum FulfillmentOrder_Update_Column {
  /** column name */
  ExternalOrderId = 'externalOrderId',
  /** column name */
  Id = 'id',
  /** column name */
  OrderId = 'orderId',
  /** column name */
  ShopifyId = 'shopifyId',
  /** column name */
  Status = 'status',
}

export type FulfillmentOrder_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<FulfillmentOrder_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<FulfillmentOrder_Set_Input>;
  /** filter the rows which have to be updated */
  where: FulfillmentOrder_Bool_Exp;
};

/** aggregate var_pop on columns */
export type FulfillmentOrder_Var_Pop_Fields = {
  __typename?: 'FulfillmentOrder_var_pop_fields';
  shopifyId: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "FulfillmentOrder" */
export type FulfillmentOrder_Var_Pop_Order_By = {
  shopifyId: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type FulfillmentOrder_Var_Samp_Fields = {
  __typename?: 'FulfillmentOrder_var_samp_fields';
  shopifyId: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "FulfillmentOrder" */
export type FulfillmentOrder_Var_Samp_Order_By = {
  shopifyId: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type FulfillmentOrder_Variance_Fields = {
  __typename?: 'FulfillmentOrder_variance_fields';
  shopifyId: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "FulfillmentOrder" */
export type FulfillmentOrder_Variance_Order_By = {
  shopifyId: InputMaybe<Order_By>;
};

/** Boolean expression to compare columns of type "FulfillmentStatus". All fields are combined with logical 'AND'. */
export type FulfillmentStatus_Comparison_Exp = {
  _eq: InputMaybe<Scalars['FulfillmentStatus']>;
  _gt: InputMaybe<Scalars['FulfillmentStatus']>;
  _gte: InputMaybe<Scalars['FulfillmentStatus']>;
  _in: InputMaybe<Array<Scalars['FulfillmentStatus']>>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  _lt: InputMaybe<Scalars['FulfillmentStatus']>;
  _lte: InputMaybe<Scalars['FulfillmentStatus']>;
  _neq: InputMaybe<Scalars['FulfillmentStatus']>;
  _nin: InputMaybe<Array<Scalars['FulfillmentStatus']>>;
};

/** aggregated selection of "Fulfillment" */
export type Fulfillment_Aggregate = {
  __typename?: 'Fulfillment_aggregate';
  aggregate: Maybe<Fulfillment_Aggregate_Fields>;
  nodes: Array<Fulfillment>;
};

export type Fulfillment_Aggregate_Bool_Exp = {
  count: InputMaybe<Fulfillment_Aggregate_Bool_Exp_Count>;
};

export type Fulfillment_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<Fulfillment_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<Fulfillment_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "Fulfillment" */
export type Fulfillment_Aggregate_Fields = {
  __typename?: 'Fulfillment_aggregate_fields';
  avg: Maybe<Fulfillment_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Fulfillment_Max_Fields>;
  min: Maybe<Fulfillment_Min_Fields>;
  stddev: Maybe<Fulfillment_Stddev_Fields>;
  stddev_pop: Maybe<Fulfillment_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Fulfillment_Stddev_Samp_Fields>;
  sum: Maybe<Fulfillment_Sum_Fields>;
  var_pop: Maybe<Fulfillment_Var_Pop_Fields>;
  var_samp: Maybe<Fulfillment_Var_Samp_Fields>;
  variance: Maybe<Fulfillment_Variance_Fields>;
};

/** aggregate fields of "Fulfillment" */
export type Fulfillment_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Fulfillment_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "Fulfillment" */
export type Fulfillment_Aggregate_Order_By = {
  avg: InputMaybe<Fulfillment_Avg_Order_By>;
  count: InputMaybe<Order_By>;
  max: InputMaybe<Fulfillment_Max_Order_By>;
  min: InputMaybe<Fulfillment_Min_Order_By>;
  stddev: InputMaybe<Fulfillment_Stddev_Order_By>;
  stddev_pop: InputMaybe<Fulfillment_Stddev_Pop_Order_By>;
  stddev_samp: InputMaybe<Fulfillment_Stddev_Samp_Order_By>;
  sum: InputMaybe<Fulfillment_Sum_Order_By>;
  var_pop: InputMaybe<Fulfillment_Var_Pop_Order_By>;
  var_samp: InputMaybe<Fulfillment_Var_Samp_Order_By>;
  variance: InputMaybe<Fulfillment_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "Fulfillment" */
export type Fulfillment_Arr_Rel_Insert_Input = {
  data: Array<Fulfillment_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<Fulfillment_On_Conflict>;
};

/** aggregate avg on columns */
export type Fulfillment_Avg_Fields = {
  __typename?: 'Fulfillment_avg_fields';
  shopifyId: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "Fulfillment" */
export type Fulfillment_Avg_Order_By = {
  shopifyId: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "Fulfillment". All fields are combined with a logical 'AND'. */
export type Fulfillment_Bool_Exp = {
  _and: InputMaybe<Array<Fulfillment_Bool_Exp>>;
  _not: InputMaybe<Fulfillment_Bool_Exp>;
  _or: InputMaybe<Array<Fulfillment_Bool_Exp>>;
  createdAt: InputMaybe<Timestamp_Comparison_Exp>;
  fulfilledItems: InputMaybe<FulfillmentItem_Bool_Exp>;
  fulfilledItems_aggregate: InputMaybe<FulfillmentItem_Aggregate_Bool_Exp>;
  fulfillmentOrder: InputMaybe<FulfillmentOrder_Bool_Exp>;
  fulfillmentOrderId: InputMaybe<String_Comparison_Exp>;
  id: InputMaybe<String_Comparison_Exp>;
  shopifyId: InputMaybe<Bigint_Comparison_Exp>;
  status: InputMaybe<FulfillmentStatus_Comparison_Exp>;
  trackingId: InputMaybe<String_Comparison_Exp>;
  trackingUrl: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "Fulfillment" */
export enum Fulfillment_Constraint {
  /** unique or primary key constraint on columns "id" */
  FulfillmentPkey = 'Fulfillment_pkey',
  /** unique or primary key constraint on columns "shopifyId" */
  FulfillmentShopifyIdKey = 'Fulfillment_shopifyId_key',
}

/** input type for incrementing numeric columns in table "Fulfillment" */
export type Fulfillment_Inc_Input = {
  shopifyId: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "Fulfillment" */
export type Fulfillment_Insert_Input = {
  createdAt: InputMaybe<Scalars['timestamp']>;
  fulfilledItems: InputMaybe<FulfillmentItem_Arr_Rel_Insert_Input>;
  fulfillmentOrder: InputMaybe<FulfillmentOrder_Obj_Rel_Insert_Input>;
  fulfillmentOrderId: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  shopifyId: InputMaybe<Scalars['bigint']>;
  status: InputMaybe<Scalars['FulfillmentStatus']>;
  trackingId: InputMaybe<Scalars['String']>;
  trackingUrl: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Fulfillment_Max_Fields = {
  __typename?: 'Fulfillment_max_fields';
  createdAt: Maybe<Scalars['timestamp']>;
  fulfillmentOrderId: Maybe<Scalars['String']>;
  id: Maybe<Scalars['String']>;
  shopifyId: Maybe<Scalars['bigint']>;
  status: Maybe<Scalars['FulfillmentStatus']>;
  trackingId: Maybe<Scalars['String']>;
  trackingUrl: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "Fulfillment" */
export type Fulfillment_Max_Order_By = {
  createdAt: InputMaybe<Order_By>;
  fulfillmentOrderId: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  shopifyId: InputMaybe<Order_By>;
  status: InputMaybe<Order_By>;
  trackingId: InputMaybe<Order_By>;
  trackingUrl: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Fulfillment_Min_Fields = {
  __typename?: 'Fulfillment_min_fields';
  createdAt: Maybe<Scalars['timestamp']>;
  fulfillmentOrderId: Maybe<Scalars['String']>;
  id: Maybe<Scalars['String']>;
  shopifyId: Maybe<Scalars['bigint']>;
  status: Maybe<Scalars['FulfillmentStatus']>;
  trackingId: Maybe<Scalars['String']>;
  trackingUrl: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "Fulfillment" */
export type Fulfillment_Min_Order_By = {
  createdAt: InputMaybe<Order_By>;
  fulfillmentOrderId: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  shopifyId: InputMaybe<Order_By>;
  status: InputMaybe<Order_By>;
  trackingId: InputMaybe<Order_By>;
  trackingUrl: InputMaybe<Order_By>;
};

/** response of any mutation on the table "Fulfillment" */
export type Fulfillment_Mutation_Response = {
  __typename?: 'Fulfillment_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Fulfillment>;
};

/** on_conflict condition type for table "Fulfillment" */
export type Fulfillment_On_Conflict = {
  constraint: Fulfillment_Constraint;
  update_columns: Array<Fulfillment_Update_Column>;
  where: InputMaybe<Fulfillment_Bool_Exp>;
};

/** Ordering options when selecting data from "Fulfillment". */
export type Fulfillment_Order_By = {
  createdAt: InputMaybe<Order_By>;
  fulfilledItems_aggregate: InputMaybe<FulfillmentItem_Aggregate_Order_By>;
  fulfillmentOrder: InputMaybe<FulfillmentOrder_Order_By>;
  fulfillmentOrderId: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  shopifyId: InputMaybe<Order_By>;
  status: InputMaybe<Order_By>;
  trackingId: InputMaybe<Order_By>;
  trackingUrl: InputMaybe<Order_By>;
};

/** primary key columns input for table: Fulfillment */
export type Fulfillment_Pk_Columns_Input = {
  id: Scalars['String'];
};

/** select columns of table "Fulfillment" */
export enum Fulfillment_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  FulfillmentOrderId = 'fulfillmentOrderId',
  /** column name */
  Id = 'id',
  /** column name */
  ShopifyId = 'shopifyId',
  /** column name */
  Status = 'status',
  /** column name */
  TrackingId = 'trackingId',
  /** column name */
  TrackingUrl = 'trackingUrl',
}

/** input type for updating data in table "Fulfillment" */
export type Fulfillment_Set_Input = {
  createdAt: InputMaybe<Scalars['timestamp']>;
  fulfillmentOrderId: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  shopifyId: InputMaybe<Scalars['bigint']>;
  status: InputMaybe<Scalars['FulfillmentStatus']>;
  trackingId: InputMaybe<Scalars['String']>;
  trackingUrl: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Fulfillment_Stddev_Fields = {
  __typename?: 'Fulfillment_stddev_fields';
  shopifyId: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "Fulfillment" */
export type Fulfillment_Stddev_Order_By = {
  shopifyId: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Fulfillment_Stddev_Pop_Fields = {
  __typename?: 'Fulfillment_stddev_pop_fields';
  shopifyId: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "Fulfillment" */
export type Fulfillment_Stddev_Pop_Order_By = {
  shopifyId: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Fulfillment_Stddev_Samp_Fields = {
  __typename?: 'Fulfillment_stddev_samp_fields';
  shopifyId: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "Fulfillment" */
export type Fulfillment_Stddev_Samp_Order_By = {
  shopifyId: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "Fulfillment" */
export type Fulfillment_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Fulfillment_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Fulfillment_Stream_Cursor_Value_Input = {
  createdAt: InputMaybe<Scalars['timestamp']>;
  fulfillmentOrderId: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  shopifyId: InputMaybe<Scalars['bigint']>;
  status: InputMaybe<Scalars['FulfillmentStatus']>;
  trackingId: InputMaybe<Scalars['String']>;
  trackingUrl: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type Fulfillment_Sum_Fields = {
  __typename?: 'Fulfillment_sum_fields';
  shopifyId: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "Fulfillment" */
export type Fulfillment_Sum_Order_By = {
  shopifyId: InputMaybe<Order_By>;
};

/** update columns of table "Fulfillment" */
export enum Fulfillment_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  FulfillmentOrderId = 'fulfillmentOrderId',
  /** column name */
  Id = 'id',
  /** column name */
  ShopifyId = 'shopifyId',
  /** column name */
  Status = 'status',
  /** column name */
  TrackingId = 'trackingId',
  /** column name */
  TrackingUrl = 'trackingUrl',
}

export type Fulfillment_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Fulfillment_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Fulfillment_Set_Input>;
  /** filter the rows which have to be updated */
  where: Fulfillment_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Fulfillment_Var_Pop_Fields = {
  __typename?: 'Fulfillment_var_pop_fields';
  shopifyId: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "Fulfillment" */
export type Fulfillment_Var_Pop_Order_By = {
  shopifyId: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Fulfillment_Var_Samp_Fields = {
  __typename?: 'Fulfillment_var_samp_fields';
  shopifyId: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "Fulfillment" */
export type Fulfillment_Var_Samp_Order_By = {
  shopifyId: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Fulfillment_Variance_Fields = {
  __typename?: 'Fulfillment_variance_fields';
  shopifyId: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "Fulfillment" */
export type Fulfillment_Variance_Order_By = {
  shopifyId: InputMaybe<Order_By>;
};

/** Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'. */
export type Int_Comparison_Exp = {
  _eq: InputMaybe<Scalars['Int']>;
  _gt: InputMaybe<Scalars['Int']>;
  _gte: InputMaybe<Scalars['Int']>;
  _in: InputMaybe<Array<Scalars['Int']>>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  _lt: InputMaybe<Scalars['Int']>;
  _lte: InputMaybe<Scalars['Int']>;
  _neq: InputMaybe<Scalars['Int']>;
  _nin: InputMaybe<Array<Scalars['Int']>>;
};

/** columns and relationships of "NegociationAgreement" */
export type NegociationAgreement = {
  __typename?: 'NegociationAgreement';
  id: Scalars['String'];
  maxAmountPercent: Scalars['Int'];
  priority: Scalars['Int'];
  productType: Maybe<Scalars['String']>;
  /** An object relationship */
  vendor: Customer;
  vendorId: Scalars['uuid'];
};

/** aggregated selection of "NegociationAgreement" */
export type NegociationAgreement_Aggregate = {
  __typename?: 'NegociationAgreement_aggregate';
  aggregate: Maybe<NegociationAgreement_Aggregate_Fields>;
  nodes: Array<NegociationAgreement>;
};

export type NegociationAgreement_Aggregate_Bool_Exp = {
  count: InputMaybe<NegociationAgreement_Aggregate_Bool_Exp_Count>;
};

export type NegociationAgreement_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<NegociationAgreement_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<NegociationAgreement_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "NegociationAgreement" */
export type NegociationAgreement_Aggregate_Fields = {
  __typename?: 'NegociationAgreement_aggregate_fields';
  avg: Maybe<NegociationAgreement_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<NegociationAgreement_Max_Fields>;
  min: Maybe<NegociationAgreement_Min_Fields>;
  stddev: Maybe<NegociationAgreement_Stddev_Fields>;
  stddev_pop: Maybe<NegociationAgreement_Stddev_Pop_Fields>;
  stddev_samp: Maybe<NegociationAgreement_Stddev_Samp_Fields>;
  sum: Maybe<NegociationAgreement_Sum_Fields>;
  var_pop: Maybe<NegociationAgreement_Var_Pop_Fields>;
  var_samp: Maybe<NegociationAgreement_Var_Samp_Fields>;
  variance: Maybe<NegociationAgreement_Variance_Fields>;
};

/** aggregate fields of "NegociationAgreement" */
export type NegociationAgreement_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<NegociationAgreement_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "NegociationAgreement" */
export type NegociationAgreement_Aggregate_Order_By = {
  avg: InputMaybe<NegociationAgreement_Avg_Order_By>;
  count: InputMaybe<Order_By>;
  max: InputMaybe<NegociationAgreement_Max_Order_By>;
  min: InputMaybe<NegociationAgreement_Min_Order_By>;
  stddev: InputMaybe<NegociationAgreement_Stddev_Order_By>;
  stddev_pop: InputMaybe<NegociationAgreement_Stddev_Pop_Order_By>;
  stddev_samp: InputMaybe<NegociationAgreement_Stddev_Samp_Order_By>;
  sum: InputMaybe<NegociationAgreement_Sum_Order_By>;
  var_pop: InputMaybe<NegociationAgreement_Var_Pop_Order_By>;
  var_samp: InputMaybe<NegociationAgreement_Var_Samp_Order_By>;
  variance: InputMaybe<NegociationAgreement_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "NegociationAgreement" */
export type NegociationAgreement_Arr_Rel_Insert_Input = {
  data: Array<NegociationAgreement_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<NegociationAgreement_On_Conflict>;
};

/** aggregate avg on columns */
export type NegociationAgreement_Avg_Fields = {
  __typename?: 'NegociationAgreement_avg_fields';
  maxAmountPercent: Maybe<Scalars['Float']>;
  priority: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "NegociationAgreement" */
export type NegociationAgreement_Avg_Order_By = {
  maxAmountPercent: InputMaybe<Order_By>;
  priority: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "NegociationAgreement". All fields are combined with a logical 'AND'. */
export type NegociationAgreement_Bool_Exp = {
  _and: InputMaybe<Array<NegociationAgreement_Bool_Exp>>;
  _not: InputMaybe<NegociationAgreement_Bool_Exp>;
  _or: InputMaybe<Array<NegociationAgreement_Bool_Exp>>;
  id: InputMaybe<String_Comparison_Exp>;
  maxAmountPercent: InputMaybe<Int_Comparison_Exp>;
  priority: InputMaybe<Int_Comparison_Exp>;
  productType: InputMaybe<String_Comparison_Exp>;
  vendor: InputMaybe<Customer_Bool_Exp>;
  vendorId: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "NegociationAgreement" */
export enum NegociationAgreement_Constraint {
  /** unique or primary key constraint on columns "id" */
  NegociationAgreementPkey = 'NegociationAgreement_pkey',
}

/** input type for incrementing numeric columns in table "NegociationAgreement" */
export type NegociationAgreement_Inc_Input = {
  maxAmountPercent: InputMaybe<Scalars['Int']>;
  priority: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "NegociationAgreement" */
export type NegociationAgreement_Insert_Input = {
  id: InputMaybe<Scalars['String']>;
  maxAmountPercent: InputMaybe<Scalars['Int']>;
  priority: InputMaybe<Scalars['Int']>;
  productType: InputMaybe<Scalars['String']>;
  vendor: InputMaybe<Customer_Obj_Rel_Insert_Input>;
  vendorId: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type NegociationAgreement_Max_Fields = {
  __typename?: 'NegociationAgreement_max_fields';
  id: Maybe<Scalars['String']>;
  maxAmountPercent: Maybe<Scalars['Int']>;
  priority: Maybe<Scalars['Int']>;
  productType: Maybe<Scalars['String']>;
  vendorId: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "NegociationAgreement" */
export type NegociationAgreement_Max_Order_By = {
  id: InputMaybe<Order_By>;
  maxAmountPercent: InputMaybe<Order_By>;
  priority: InputMaybe<Order_By>;
  productType: InputMaybe<Order_By>;
  vendorId: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type NegociationAgreement_Min_Fields = {
  __typename?: 'NegociationAgreement_min_fields';
  id: Maybe<Scalars['String']>;
  maxAmountPercent: Maybe<Scalars['Int']>;
  priority: Maybe<Scalars['Int']>;
  productType: Maybe<Scalars['String']>;
  vendorId: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "NegociationAgreement" */
export type NegociationAgreement_Min_Order_By = {
  id: InputMaybe<Order_By>;
  maxAmountPercent: InputMaybe<Order_By>;
  priority: InputMaybe<Order_By>;
  productType: InputMaybe<Order_By>;
  vendorId: InputMaybe<Order_By>;
};

/** response of any mutation on the table "NegociationAgreement" */
export type NegociationAgreement_Mutation_Response = {
  __typename?: 'NegociationAgreement_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<NegociationAgreement>;
};

/** on_conflict condition type for table "NegociationAgreement" */
export type NegociationAgreement_On_Conflict = {
  constraint: NegociationAgreement_Constraint;
  update_columns: Array<NegociationAgreement_Update_Column>;
  where: InputMaybe<NegociationAgreement_Bool_Exp>;
};

/** Ordering options when selecting data from "NegociationAgreement". */
export type NegociationAgreement_Order_By = {
  id: InputMaybe<Order_By>;
  maxAmountPercent: InputMaybe<Order_By>;
  priority: InputMaybe<Order_By>;
  productType: InputMaybe<Order_By>;
  vendor: InputMaybe<Customer_Order_By>;
  vendorId: InputMaybe<Order_By>;
};

/** primary key columns input for table: NegociationAgreement */
export type NegociationAgreement_Pk_Columns_Input = {
  id: Scalars['String'];
};

/** select columns of table "NegociationAgreement" */
export enum NegociationAgreement_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  MaxAmountPercent = 'maxAmountPercent',
  /** column name */
  Priority = 'priority',
  /** column name */
  ProductType = 'productType',
  /** column name */
  VendorId = 'vendorId',
}

/** input type for updating data in table "NegociationAgreement" */
export type NegociationAgreement_Set_Input = {
  id: InputMaybe<Scalars['String']>;
  maxAmountPercent: InputMaybe<Scalars['Int']>;
  priority: InputMaybe<Scalars['Int']>;
  productType: InputMaybe<Scalars['String']>;
  vendorId: InputMaybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type NegociationAgreement_Stddev_Fields = {
  __typename?: 'NegociationAgreement_stddev_fields';
  maxAmountPercent: Maybe<Scalars['Float']>;
  priority: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "NegociationAgreement" */
export type NegociationAgreement_Stddev_Order_By = {
  maxAmountPercent: InputMaybe<Order_By>;
  priority: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type NegociationAgreement_Stddev_Pop_Fields = {
  __typename?: 'NegociationAgreement_stddev_pop_fields';
  maxAmountPercent: Maybe<Scalars['Float']>;
  priority: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "NegociationAgreement" */
export type NegociationAgreement_Stddev_Pop_Order_By = {
  maxAmountPercent: InputMaybe<Order_By>;
  priority: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type NegociationAgreement_Stddev_Samp_Fields = {
  __typename?: 'NegociationAgreement_stddev_samp_fields';
  maxAmountPercent: Maybe<Scalars['Float']>;
  priority: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "NegociationAgreement" */
export type NegociationAgreement_Stddev_Samp_Order_By = {
  maxAmountPercent: InputMaybe<Order_By>;
  priority: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "NegociationAgreement" */
export type NegociationAgreement_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: NegociationAgreement_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type NegociationAgreement_Stream_Cursor_Value_Input = {
  id: InputMaybe<Scalars['String']>;
  maxAmountPercent: InputMaybe<Scalars['Int']>;
  priority: InputMaybe<Scalars['Int']>;
  productType: InputMaybe<Scalars['String']>;
  vendorId: InputMaybe<Scalars['uuid']>;
};

/** aggregate sum on columns */
export type NegociationAgreement_Sum_Fields = {
  __typename?: 'NegociationAgreement_sum_fields';
  maxAmountPercent: Maybe<Scalars['Int']>;
  priority: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "NegociationAgreement" */
export type NegociationAgreement_Sum_Order_By = {
  maxAmountPercent: InputMaybe<Order_By>;
  priority: InputMaybe<Order_By>;
};

/** update columns of table "NegociationAgreement" */
export enum NegociationAgreement_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  MaxAmountPercent = 'maxAmountPercent',
  /** column name */
  Priority = 'priority',
  /** column name */
  ProductType = 'productType',
  /** column name */
  VendorId = 'vendorId',
}

export type NegociationAgreement_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<NegociationAgreement_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<NegociationAgreement_Set_Input>;
  /** filter the rows which have to be updated */
  where: NegociationAgreement_Bool_Exp;
};

/** aggregate var_pop on columns */
export type NegociationAgreement_Var_Pop_Fields = {
  __typename?: 'NegociationAgreement_var_pop_fields';
  maxAmountPercent: Maybe<Scalars['Float']>;
  priority: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "NegociationAgreement" */
export type NegociationAgreement_Var_Pop_Order_By = {
  maxAmountPercent: InputMaybe<Order_By>;
  priority: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type NegociationAgreement_Var_Samp_Fields = {
  __typename?: 'NegociationAgreement_var_samp_fields';
  maxAmountPercent: Maybe<Scalars['Float']>;
  priority: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "NegociationAgreement" */
export type NegociationAgreement_Var_Samp_Order_By = {
  maxAmountPercent: InputMaybe<Order_By>;
  priority: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type NegociationAgreement_Variance_Fields = {
  __typename?: 'NegociationAgreement_variance_fields';
  maxAmountPercent: Maybe<Scalars['Float']>;
  priority: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "NegociationAgreement" */
export type NegociationAgreement_Variance_Order_By = {
  maxAmountPercent: InputMaybe<Order_By>;
  priority: InputMaybe<Order_By>;
};

/** columns and relationships of "NumericFilter" */
export type NumericFilter = {
  __typename?: 'NumericFilter';
  /** An object relationship */
  SavedSearch: SavedSearch;
  facetName: Scalars['String'];
  id: Scalars['String'];
  operator: Scalars['String'];
  searchId: Scalars['String'];
  value: Scalars['String'];
};

/** aggregated selection of "NumericFilter" */
export type NumericFilter_Aggregate = {
  __typename?: 'NumericFilter_aggregate';
  aggregate: Maybe<NumericFilter_Aggregate_Fields>;
  nodes: Array<NumericFilter>;
};

export type NumericFilter_Aggregate_Bool_Exp = {
  count: InputMaybe<NumericFilter_Aggregate_Bool_Exp_Count>;
};

export type NumericFilter_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<NumericFilter_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<NumericFilter_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "NumericFilter" */
export type NumericFilter_Aggregate_Fields = {
  __typename?: 'NumericFilter_aggregate_fields';
  count: Scalars['Int'];
  max: Maybe<NumericFilter_Max_Fields>;
  min: Maybe<NumericFilter_Min_Fields>;
};

/** aggregate fields of "NumericFilter" */
export type NumericFilter_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<NumericFilter_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "NumericFilter" */
export type NumericFilter_Aggregate_Order_By = {
  count: InputMaybe<Order_By>;
  max: InputMaybe<NumericFilter_Max_Order_By>;
  min: InputMaybe<NumericFilter_Min_Order_By>;
};

/** input type for inserting array relation for remote table "NumericFilter" */
export type NumericFilter_Arr_Rel_Insert_Input = {
  data: Array<NumericFilter_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<NumericFilter_On_Conflict>;
};

/** Boolean expression to filter rows from the table "NumericFilter". All fields are combined with a logical 'AND'. */
export type NumericFilter_Bool_Exp = {
  SavedSearch: InputMaybe<SavedSearch_Bool_Exp>;
  _and: InputMaybe<Array<NumericFilter_Bool_Exp>>;
  _not: InputMaybe<NumericFilter_Bool_Exp>;
  _or: InputMaybe<Array<NumericFilter_Bool_Exp>>;
  facetName: InputMaybe<String_Comparison_Exp>;
  id: InputMaybe<String_Comparison_Exp>;
  operator: InputMaybe<String_Comparison_Exp>;
  searchId: InputMaybe<String_Comparison_Exp>;
  value: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "NumericFilter" */
export enum NumericFilter_Constraint {
  /** unique or primary key constraint on columns "id" */
  NumericFilterPkey = 'NumericFilter_pkey',
}

/** input type for inserting data into table "NumericFilter" */
export type NumericFilter_Insert_Input = {
  SavedSearch: InputMaybe<SavedSearch_Obj_Rel_Insert_Input>;
  facetName: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  operator: InputMaybe<Scalars['String']>;
  searchId: InputMaybe<Scalars['String']>;
  value: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type NumericFilter_Max_Fields = {
  __typename?: 'NumericFilter_max_fields';
  facetName: Maybe<Scalars['String']>;
  id: Maybe<Scalars['String']>;
  operator: Maybe<Scalars['String']>;
  searchId: Maybe<Scalars['String']>;
  value: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "NumericFilter" */
export type NumericFilter_Max_Order_By = {
  facetName: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  operator: InputMaybe<Order_By>;
  searchId: InputMaybe<Order_By>;
  value: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type NumericFilter_Min_Fields = {
  __typename?: 'NumericFilter_min_fields';
  facetName: Maybe<Scalars['String']>;
  id: Maybe<Scalars['String']>;
  operator: Maybe<Scalars['String']>;
  searchId: Maybe<Scalars['String']>;
  value: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "NumericFilter" */
export type NumericFilter_Min_Order_By = {
  facetName: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  operator: InputMaybe<Order_By>;
  searchId: InputMaybe<Order_By>;
  value: InputMaybe<Order_By>;
};

/** response of any mutation on the table "NumericFilter" */
export type NumericFilter_Mutation_Response = {
  __typename?: 'NumericFilter_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<NumericFilter>;
};

/** on_conflict condition type for table "NumericFilter" */
export type NumericFilter_On_Conflict = {
  constraint: NumericFilter_Constraint;
  update_columns: Array<NumericFilter_Update_Column>;
  where: InputMaybe<NumericFilter_Bool_Exp>;
};

/** Ordering options when selecting data from "NumericFilter". */
export type NumericFilter_Order_By = {
  SavedSearch: InputMaybe<SavedSearch_Order_By>;
  facetName: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  operator: InputMaybe<Order_By>;
  searchId: InputMaybe<Order_By>;
  value: InputMaybe<Order_By>;
};

/** primary key columns input for table: NumericFilter */
export type NumericFilter_Pk_Columns_Input = {
  id: Scalars['String'];
};

/** select columns of table "NumericFilter" */
export enum NumericFilter_Select_Column {
  /** column name */
  FacetName = 'facetName',
  /** column name */
  Id = 'id',
  /** column name */
  Operator = 'operator',
  /** column name */
  SearchId = 'searchId',
  /** column name */
  Value = 'value',
}

/** input type for updating data in table "NumericFilter" */
export type NumericFilter_Set_Input = {
  facetName: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  operator: InputMaybe<Scalars['String']>;
  searchId: InputMaybe<Scalars['String']>;
  value: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "NumericFilter" */
export type NumericFilter_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: NumericFilter_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type NumericFilter_Stream_Cursor_Value_Input = {
  facetName: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  operator: InputMaybe<Scalars['String']>;
  searchId: InputMaybe<Scalars['String']>;
  value: InputMaybe<Scalars['String']>;
};

/** update columns of table "NumericFilter" */
export enum NumericFilter_Update_Column {
  /** column name */
  FacetName = 'facetName',
  /** column name */
  Id = 'id',
  /** column name */
  Operator = 'operator',
  /** column name */
  SearchId = 'searchId',
  /** column name */
  Value = 'value',
}

export type NumericFilter_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<NumericFilter_Set_Input>;
  /** filter the rows which have to be updated */
  where: NumericFilter_Bool_Exp;
};

/** columns and relationships of "Order" */
export type Order = {
  __typename?: 'Order';
  /** An object relationship */
  buyerCustomer: Maybe<Customer>;
  checkoutId: Maybe<Scalars['String']>;
  createdAt: Scalars['timestamp'];
  customerEmail: Scalars['String'];
  customerId: Maybe<Scalars['uuid']>;
  /** An array relationship */
  fulfillmentOrders: Array<FulfillmentOrder>;
  /** An aggregate relationship */
  fulfillmentOrders_aggregate: FulfillmentOrder_Aggregate;
  id: Scalars['String'];
  name: Scalars['String'];
  /** An array relationship */
  orderLines: Array<OrderLines>;
  /** An aggregate relationship */
  orderLines_aggregate: OrderLines_Aggregate;
  paidAt: Maybe<Scalars['timestamp']>;
  shippingAddressAddress1: Scalars['String'];
  shippingAddressAddress2: Maybe<Scalars['String']>;
  shippingAddressCity: Scalars['String'];
  shippingAddressCompany: Maybe<Scalars['String']>;
  shippingAddressCountry: Scalars['String'];
  shippingAddressFirstName: Maybe<Scalars['String']>;
  shippingAddressLastName: Scalars['String'];
  shippingAddressPhone: Scalars['String'];
  shippingAddressZip: Scalars['String'];
  shopifyId: Scalars['String'];
  status: Scalars['OrderStatus'];
  totalPriceCurrency: Scalars['Currency'];
  totalPriceInCents: Scalars['float8'];
};

/** columns and relationships of "Order" */
export type OrderFulfillmentOrdersArgs = {
  distinct_on: InputMaybe<Array<FulfillmentOrder_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<FulfillmentOrder_Order_By>>;
  where: InputMaybe<FulfillmentOrder_Bool_Exp>;
};

/** columns and relationships of "Order" */
export type OrderFulfillmentOrders_AggregateArgs = {
  distinct_on: InputMaybe<Array<FulfillmentOrder_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<FulfillmentOrder_Order_By>>;
  where: InputMaybe<FulfillmentOrder_Bool_Exp>;
};

/** columns and relationships of "Order" */
export type OrderOrderLinesArgs = {
  distinct_on: InputMaybe<Array<OrderLines_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<OrderLines_Order_By>>;
  where: InputMaybe<OrderLines_Bool_Exp>;
};

/** columns and relationships of "Order" */
export type OrderOrderLines_AggregateArgs = {
  distinct_on: InputMaybe<Array<OrderLines_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<OrderLines_Order_By>>;
  where: InputMaybe<OrderLines_Bool_Exp>;
};

/** columns and relationships of "OrderLines" */
export type OrderLines = {
  __typename?: 'OrderLines';
  buyerCommission: Maybe<Scalars['float8']>;
  canceledAt: Maybe<Scalars['timestamp']>;
  comment: Maybe<Scalars['String']>;
  createdAt: Scalars['timestamp'];
  deliveredAt: Maybe<Scalars['timestamp']>;
  discountInCents: Scalars['float8'];
  /** An array relationship */
  disputes: Array<Dispute>;
  /** An aggregate relationship */
  disputes_aggregate: Dispute_Aggregate;
  /** An object relationship */
  fulfillmentOrder: Maybe<FulfillmentOrder>;
  fulfillmentOrderId: Maybe<Scalars['String']>;
  id: Scalars['String'];
  name: Scalars['String'];
  /** An object relationship */
  order: Order;
  orderId: Scalars['String'];
  /** An array relationship */
  payouts: Array<Payout>;
  /** An aggregate relationship */
  payouts_aggregate: Payout_Aggregate;
  priceCurrency: Scalars['Currency'];
  priceInCents: Scalars['float8'];
  productBrand: Maybe<Scalars['String']>;
  productGender: Maybe<Scalars['String']>;
  productHandle: Scalars['String'];
  productImage: Maybe<Scalars['String']>;
  productModelYear: Maybe<Scalars['String']>;
  productSize: Maybe<Scalars['String']>;
  productType: Scalars['String'];
  /** An object relationship */
  productVariant: Maybe<ProductVariant>;
  productVariantId: Maybe<Scalars['String']>;
  quantity: Scalars['Int'];
  shippingSolution: Scalars['ShippingSolution'];
  shopifyId: Scalars['String'];
  variantCondition: Maybe<Scalars['Condition']>;
  vendorCommission: Maybe<Scalars['float8']>;
  /** An object relationship */
  vendorCustomer: Maybe<Customer>;
  vendorId: Maybe<Scalars['uuid']>;
  vendorShipping: Maybe<Scalars['float8']>;
};

/** columns and relationships of "OrderLines" */
export type OrderLinesDisputesArgs = {
  distinct_on: InputMaybe<Array<Dispute_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dispute_Order_By>>;
  where: InputMaybe<Dispute_Bool_Exp>;
};

/** columns and relationships of "OrderLines" */
export type OrderLinesDisputes_AggregateArgs = {
  distinct_on: InputMaybe<Array<Dispute_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dispute_Order_By>>;
  where: InputMaybe<Dispute_Bool_Exp>;
};

/** columns and relationships of "OrderLines" */
export type OrderLinesPayoutsArgs = {
  distinct_on: InputMaybe<Array<Payout_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Payout_Order_By>>;
  where: InputMaybe<Payout_Bool_Exp>;
};

/** columns and relationships of "OrderLines" */
export type OrderLinesPayouts_AggregateArgs = {
  distinct_on: InputMaybe<Array<Payout_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Payout_Order_By>>;
  where: InputMaybe<Payout_Bool_Exp>;
};

/** aggregated selection of "OrderLines" */
export type OrderLines_Aggregate = {
  __typename?: 'OrderLines_aggregate';
  aggregate: Maybe<OrderLines_Aggregate_Fields>;
  nodes: Array<OrderLines>;
};

export type OrderLines_Aggregate_Bool_Exp = {
  avg: InputMaybe<OrderLines_Aggregate_Bool_Exp_Avg>;
  corr: InputMaybe<OrderLines_Aggregate_Bool_Exp_Corr>;
  count: InputMaybe<OrderLines_Aggregate_Bool_Exp_Count>;
  covar_samp: InputMaybe<OrderLines_Aggregate_Bool_Exp_Covar_Samp>;
  max: InputMaybe<OrderLines_Aggregate_Bool_Exp_Max>;
  min: InputMaybe<OrderLines_Aggregate_Bool_Exp_Min>;
  stddev_samp: InputMaybe<OrderLines_Aggregate_Bool_Exp_Stddev_Samp>;
  sum: InputMaybe<OrderLines_Aggregate_Bool_Exp_Sum>;
  var_samp: InputMaybe<OrderLines_Aggregate_Bool_Exp_Var_Samp>;
};

export type OrderLines_Aggregate_Bool_Exp_Avg = {
  arguments: OrderLines_Select_Column_OrderLines_Aggregate_Bool_Exp_Avg_Arguments_Columns;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<OrderLines_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type OrderLines_Aggregate_Bool_Exp_Corr = {
  arguments: OrderLines_Aggregate_Bool_Exp_Corr_Arguments;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<OrderLines_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type OrderLines_Aggregate_Bool_Exp_Corr_Arguments = {
  X: OrderLines_Select_Column_OrderLines_Aggregate_Bool_Exp_Corr_Arguments_Columns;
  Y: OrderLines_Select_Column_OrderLines_Aggregate_Bool_Exp_Corr_Arguments_Columns;
};

export type OrderLines_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<OrderLines_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<OrderLines_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

export type OrderLines_Aggregate_Bool_Exp_Covar_Samp = {
  arguments: OrderLines_Aggregate_Bool_Exp_Covar_Samp_Arguments;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<OrderLines_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type OrderLines_Aggregate_Bool_Exp_Covar_Samp_Arguments = {
  X: OrderLines_Select_Column_OrderLines_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns;
  Y: OrderLines_Select_Column_OrderLines_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns;
};

export type OrderLines_Aggregate_Bool_Exp_Max = {
  arguments: OrderLines_Select_Column_OrderLines_Aggregate_Bool_Exp_Max_Arguments_Columns;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<OrderLines_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type OrderLines_Aggregate_Bool_Exp_Min = {
  arguments: OrderLines_Select_Column_OrderLines_Aggregate_Bool_Exp_Min_Arguments_Columns;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<OrderLines_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type OrderLines_Aggregate_Bool_Exp_Stddev_Samp = {
  arguments: OrderLines_Select_Column_OrderLines_Aggregate_Bool_Exp_Stddev_Samp_Arguments_Columns;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<OrderLines_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type OrderLines_Aggregate_Bool_Exp_Sum = {
  arguments: OrderLines_Select_Column_OrderLines_Aggregate_Bool_Exp_Sum_Arguments_Columns;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<OrderLines_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type OrderLines_Aggregate_Bool_Exp_Var_Samp = {
  arguments: OrderLines_Select_Column_OrderLines_Aggregate_Bool_Exp_Var_Samp_Arguments_Columns;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<OrderLines_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

/** aggregate fields of "OrderLines" */
export type OrderLines_Aggregate_Fields = {
  __typename?: 'OrderLines_aggregate_fields';
  avg: Maybe<OrderLines_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<OrderLines_Max_Fields>;
  min: Maybe<OrderLines_Min_Fields>;
  stddev: Maybe<OrderLines_Stddev_Fields>;
  stddev_pop: Maybe<OrderLines_Stddev_Pop_Fields>;
  stddev_samp: Maybe<OrderLines_Stddev_Samp_Fields>;
  sum: Maybe<OrderLines_Sum_Fields>;
  var_pop: Maybe<OrderLines_Var_Pop_Fields>;
  var_samp: Maybe<OrderLines_Var_Samp_Fields>;
  variance: Maybe<OrderLines_Variance_Fields>;
};

/** aggregate fields of "OrderLines" */
export type OrderLines_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<OrderLines_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "OrderLines" */
export type OrderLines_Aggregate_Order_By = {
  avg: InputMaybe<OrderLines_Avg_Order_By>;
  count: InputMaybe<Order_By>;
  max: InputMaybe<OrderLines_Max_Order_By>;
  min: InputMaybe<OrderLines_Min_Order_By>;
  stddev: InputMaybe<OrderLines_Stddev_Order_By>;
  stddev_pop: InputMaybe<OrderLines_Stddev_Pop_Order_By>;
  stddev_samp: InputMaybe<OrderLines_Stddev_Samp_Order_By>;
  sum: InputMaybe<OrderLines_Sum_Order_By>;
  var_pop: InputMaybe<OrderLines_Var_Pop_Order_By>;
  var_samp: InputMaybe<OrderLines_Var_Samp_Order_By>;
  variance: InputMaybe<OrderLines_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "OrderLines" */
export type OrderLines_Arr_Rel_Insert_Input = {
  data: Array<OrderLines_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<OrderLines_On_Conflict>;
};

/** aggregate avg on columns */
export type OrderLines_Avg_Fields = {
  __typename?: 'OrderLines_avg_fields';
  buyerCommission: Maybe<Scalars['Float']>;
  discountInCents: Maybe<Scalars['Float']>;
  priceInCents: Maybe<Scalars['Float']>;
  quantity: Maybe<Scalars['Float']>;
  vendorCommission: Maybe<Scalars['Float']>;
  vendorShipping: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "OrderLines" */
export type OrderLines_Avg_Order_By = {
  buyerCommission: InputMaybe<Order_By>;
  discountInCents: InputMaybe<Order_By>;
  priceInCents: InputMaybe<Order_By>;
  quantity: InputMaybe<Order_By>;
  vendorCommission: InputMaybe<Order_By>;
  vendorShipping: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "OrderLines". All fields are combined with a logical 'AND'. */
export type OrderLines_Bool_Exp = {
  _and: InputMaybe<Array<OrderLines_Bool_Exp>>;
  _not: InputMaybe<OrderLines_Bool_Exp>;
  _or: InputMaybe<Array<OrderLines_Bool_Exp>>;
  buyerCommission: InputMaybe<Float8_Comparison_Exp>;
  canceledAt: InputMaybe<Timestamp_Comparison_Exp>;
  comment: InputMaybe<String_Comparison_Exp>;
  createdAt: InputMaybe<Timestamp_Comparison_Exp>;
  deliveredAt: InputMaybe<Timestamp_Comparison_Exp>;
  discountInCents: InputMaybe<Float8_Comparison_Exp>;
  disputes: InputMaybe<Dispute_Bool_Exp>;
  disputes_aggregate: InputMaybe<Dispute_Aggregate_Bool_Exp>;
  fulfillmentOrder: InputMaybe<FulfillmentOrder_Bool_Exp>;
  fulfillmentOrderId: InputMaybe<String_Comparison_Exp>;
  id: InputMaybe<String_Comparison_Exp>;
  name: InputMaybe<String_Comparison_Exp>;
  order: InputMaybe<Order_Bool_Exp>;
  orderId: InputMaybe<String_Comparison_Exp>;
  payouts: InputMaybe<Payout_Bool_Exp>;
  payouts_aggregate: InputMaybe<Payout_Aggregate_Bool_Exp>;
  priceCurrency: InputMaybe<Currency_Comparison_Exp>;
  priceInCents: InputMaybe<Float8_Comparison_Exp>;
  productBrand: InputMaybe<String_Comparison_Exp>;
  productGender: InputMaybe<String_Comparison_Exp>;
  productHandle: InputMaybe<String_Comparison_Exp>;
  productImage: InputMaybe<String_Comparison_Exp>;
  productModelYear: InputMaybe<String_Comparison_Exp>;
  productSize: InputMaybe<String_Comparison_Exp>;
  productType: InputMaybe<String_Comparison_Exp>;
  productVariant: InputMaybe<ProductVariant_Bool_Exp>;
  productVariantId: InputMaybe<String_Comparison_Exp>;
  quantity: InputMaybe<Int_Comparison_Exp>;
  shippingSolution: InputMaybe<ShippingSolution_Comparison_Exp>;
  shopifyId: InputMaybe<String_Comparison_Exp>;
  variantCondition: InputMaybe<Condition_Comparison_Exp>;
  vendorCommission: InputMaybe<Float8_Comparison_Exp>;
  vendorCustomer: InputMaybe<Customer_Bool_Exp>;
  vendorId: InputMaybe<Uuid_Comparison_Exp>;
  vendorShipping: InputMaybe<Float8_Comparison_Exp>;
};

/** unique or primary key constraints on table "OrderLines" */
export enum OrderLines_Constraint {
  /** unique or primary key constraint on columns "id" */
  OrderLinesPkey = 'OrderLines_pkey',
  /** unique or primary key constraint on columns "shopifyId" */
  OrderLinesShopifyIdKey = 'OrderLines_shopifyId_key',
}

/** input type for incrementing numeric columns in table "OrderLines" */
export type OrderLines_Inc_Input = {
  buyerCommission: InputMaybe<Scalars['float8']>;
  discountInCents: InputMaybe<Scalars['float8']>;
  priceInCents: InputMaybe<Scalars['float8']>;
  quantity: InputMaybe<Scalars['Int']>;
  vendorCommission: InputMaybe<Scalars['float8']>;
  vendorShipping: InputMaybe<Scalars['float8']>;
};

/** input type for inserting data into table "OrderLines" */
export type OrderLines_Insert_Input = {
  buyerCommission: InputMaybe<Scalars['float8']>;
  canceledAt: InputMaybe<Scalars['timestamp']>;
  comment: InputMaybe<Scalars['String']>;
  createdAt: InputMaybe<Scalars['timestamp']>;
  deliveredAt: InputMaybe<Scalars['timestamp']>;
  discountInCents: InputMaybe<Scalars['float8']>;
  disputes: InputMaybe<Dispute_Arr_Rel_Insert_Input>;
  fulfillmentOrder: InputMaybe<FulfillmentOrder_Obj_Rel_Insert_Input>;
  fulfillmentOrderId: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  name: InputMaybe<Scalars['String']>;
  order: InputMaybe<Order_Obj_Rel_Insert_Input>;
  orderId: InputMaybe<Scalars['String']>;
  payouts: InputMaybe<Payout_Arr_Rel_Insert_Input>;
  priceCurrency: InputMaybe<Scalars['Currency']>;
  priceInCents: InputMaybe<Scalars['float8']>;
  productBrand: InputMaybe<Scalars['String']>;
  productGender: InputMaybe<Scalars['String']>;
  productHandle: InputMaybe<Scalars['String']>;
  productImage: InputMaybe<Scalars['String']>;
  productModelYear: InputMaybe<Scalars['String']>;
  productSize: InputMaybe<Scalars['String']>;
  productType: InputMaybe<Scalars['String']>;
  productVariant: InputMaybe<ProductVariant_Obj_Rel_Insert_Input>;
  productVariantId: InputMaybe<Scalars['String']>;
  quantity: InputMaybe<Scalars['Int']>;
  shippingSolution: InputMaybe<Scalars['ShippingSolution']>;
  shopifyId: InputMaybe<Scalars['String']>;
  variantCondition: InputMaybe<Scalars['Condition']>;
  vendorCommission: InputMaybe<Scalars['float8']>;
  vendorCustomer: InputMaybe<Customer_Obj_Rel_Insert_Input>;
  vendorId: InputMaybe<Scalars['uuid']>;
  vendorShipping: InputMaybe<Scalars['float8']>;
};

/** aggregate max on columns */
export type OrderLines_Max_Fields = {
  __typename?: 'OrderLines_max_fields';
  buyerCommission: Maybe<Scalars['float8']>;
  canceledAt: Maybe<Scalars['timestamp']>;
  comment: Maybe<Scalars['String']>;
  createdAt: Maybe<Scalars['timestamp']>;
  deliveredAt: Maybe<Scalars['timestamp']>;
  discountInCents: Maybe<Scalars['float8']>;
  fulfillmentOrderId: Maybe<Scalars['String']>;
  id: Maybe<Scalars['String']>;
  name: Maybe<Scalars['String']>;
  orderId: Maybe<Scalars['String']>;
  priceCurrency: Maybe<Scalars['Currency']>;
  priceInCents: Maybe<Scalars['float8']>;
  productBrand: Maybe<Scalars['String']>;
  productGender: Maybe<Scalars['String']>;
  productHandle: Maybe<Scalars['String']>;
  productImage: Maybe<Scalars['String']>;
  productModelYear: Maybe<Scalars['String']>;
  productSize: Maybe<Scalars['String']>;
  productType: Maybe<Scalars['String']>;
  productVariantId: Maybe<Scalars['String']>;
  quantity: Maybe<Scalars['Int']>;
  shippingSolution: Maybe<Scalars['ShippingSolution']>;
  shopifyId: Maybe<Scalars['String']>;
  variantCondition: Maybe<Scalars['Condition']>;
  vendorCommission: Maybe<Scalars['float8']>;
  vendorId: Maybe<Scalars['uuid']>;
  vendorShipping: Maybe<Scalars['float8']>;
};

/** order by max() on columns of table "OrderLines" */
export type OrderLines_Max_Order_By = {
  buyerCommission: InputMaybe<Order_By>;
  canceledAt: InputMaybe<Order_By>;
  comment: InputMaybe<Order_By>;
  createdAt: InputMaybe<Order_By>;
  deliveredAt: InputMaybe<Order_By>;
  discountInCents: InputMaybe<Order_By>;
  fulfillmentOrderId: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  name: InputMaybe<Order_By>;
  orderId: InputMaybe<Order_By>;
  priceCurrency: InputMaybe<Order_By>;
  priceInCents: InputMaybe<Order_By>;
  productBrand: InputMaybe<Order_By>;
  productGender: InputMaybe<Order_By>;
  productHandle: InputMaybe<Order_By>;
  productImage: InputMaybe<Order_By>;
  productModelYear: InputMaybe<Order_By>;
  productSize: InputMaybe<Order_By>;
  productType: InputMaybe<Order_By>;
  productVariantId: InputMaybe<Order_By>;
  quantity: InputMaybe<Order_By>;
  shippingSolution: InputMaybe<Order_By>;
  shopifyId: InputMaybe<Order_By>;
  variantCondition: InputMaybe<Order_By>;
  vendorCommission: InputMaybe<Order_By>;
  vendorId: InputMaybe<Order_By>;
  vendorShipping: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type OrderLines_Min_Fields = {
  __typename?: 'OrderLines_min_fields';
  buyerCommission: Maybe<Scalars['float8']>;
  canceledAt: Maybe<Scalars['timestamp']>;
  comment: Maybe<Scalars['String']>;
  createdAt: Maybe<Scalars['timestamp']>;
  deliveredAt: Maybe<Scalars['timestamp']>;
  discountInCents: Maybe<Scalars['float8']>;
  fulfillmentOrderId: Maybe<Scalars['String']>;
  id: Maybe<Scalars['String']>;
  name: Maybe<Scalars['String']>;
  orderId: Maybe<Scalars['String']>;
  priceCurrency: Maybe<Scalars['Currency']>;
  priceInCents: Maybe<Scalars['float8']>;
  productBrand: Maybe<Scalars['String']>;
  productGender: Maybe<Scalars['String']>;
  productHandle: Maybe<Scalars['String']>;
  productImage: Maybe<Scalars['String']>;
  productModelYear: Maybe<Scalars['String']>;
  productSize: Maybe<Scalars['String']>;
  productType: Maybe<Scalars['String']>;
  productVariantId: Maybe<Scalars['String']>;
  quantity: Maybe<Scalars['Int']>;
  shippingSolution: Maybe<Scalars['ShippingSolution']>;
  shopifyId: Maybe<Scalars['String']>;
  variantCondition: Maybe<Scalars['Condition']>;
  vendorCommission: Maybe<Scalars['float8']>;
  vendorId: Maybe<Scalars['uuid']>;
  vendorShipping: Maybe<Scalars['float8']>;
};

/** order by min() on columns of table "OrderLines" */
export type OrderLines_Min_Order_By = {
  buyerCommission: InputMaybe<Order_By>;
  canceledAt: InputMaybe<Order_By>;
  comment: InputMaybe<Order_By>;
  createdAt: InputMaybe<Order_By>;
  deliveredAt: InputMaybe<Order_By>;
  discountInCents: InputMaybe<Order_By>;
  fulfillmentOrderId: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  name: InputMaybe<Order_By>;
  orderId: InputMaybe<Order_By>;
  priceCurrency: InputMaybe<Order_By>;
  priceInCents: InputMaybe<Order_By>;
  productBrand: InputMaybe<Order_By>;
  productGender: InputMaybe<Order_By>;
  productHandle: InputMaybe<Order_By>;
  productImage: InputMaybe<Order_By>;
  productModelYear: InputMaybe<Order_By>;
  productSize: InputMaybe<Order_By>;
  productType: InputMaybe<Order_By>;
  productVariantId: InputMaybe<Order_By>;
  quantity: InputMaybe<Order_By>;
  shippingSolution: InputMaybe<Order_By>;
  shopifyId: InputMaybe<Order_By>;
  variantCondition: InputMaybe<Order_By>;
  vendorCommission: InputMaybe<Order_By>;
  vendorId: InputMaybe<Order_By>;
  vendorShipping: InputMaybe<Order_By>;
};

/** response of any mutation on the table "OrderLines" */
export type OrderLines_Mutation_Response = {
  __typename?: 'OrderLines_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<OrderLines>;
};

/** input type for inserting object relation for remote table "OrderLines" */
export type OrderLines_Obj_Rel_Insert_Input = {
  data: OrderLines_Insert_Input;
  /** upsert condition */
  on_conflict: InputMaybe<OrderLines_On_Conflict>;
};

/** on_conflict condition type for table "OrderLines" */
export type OrderLines_On_Conflict = {
  constraint: OrderLines_Constraint;
  update_columns: Array<OrderLines_Update_Column>;
  where: InputMaybe<OrderLines_Bool_Exp>;
};

/** Ordering options when selecting data from "OrderLines". */
export type OrderLines_Order_By = {
  buyerCommission: InputMaybe<Order_By>;
  canceledAt: InputMaybe<Order_By>;
  comment: InputMaybe<Order_By>;
  createdAt: InputMaybe<Order_By>;
  deliveredAt: InputMaybe<Order_By>;
  discountInCents: InputMaybe<Order_By>;
  disputes_aggregate: InputMaybe<Dispute_Aggregate_Order_By>;
  fulfillmentOrder: InputMaybe<FulfillmentOrder_Order_By>;
  fulfillmentOrderId: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  name: InputMaybe<Order_By>;
  order: InputMaybe<Order_Order_By>;
  orderId: InputMaybe<Order_By>;
  payouts_aggregate: InputMaybe<Payout_Aggregate_Order_By>;
  priceCurrency: InputMaybe<Order_By>;
  priceInCents: InputMaybe<Order_By>;
  productBrand: InputMaybe<Order_By>;
  productGender: InputMaybe<Order_By>;
  productHandle: InputMaybe<Order_By>;
  productImage: InputMaybe<Order_By>;
  productModelYear: InputMaybe<Order_By>;
  productSize: InputMaybe<Order_By>;
  productType: InputMaybe<Order_By>;
  productVariant: InputMaybe<ProductVariant_Order_By>;
  productVariantId: InputMaybe<Order_By>;
  quantity: InputMaybe<Order_By>;
  shippingSolution: InputMaybe<Order_By>;
  shopifyId: InputMaybe<Order_By>;
  variantCondition: InputMaybe<Order_By>;
  vendorCommission: InputMaybe<Order_By>;
  vendorCustomer: InputMaybe<Customer_Order_By>;
  vendorId: InputMaybe<Order_By>;
  vendorShipping: InputMaybe<Order_By>;
};

/** primary key columns input for table: OrderLines */
export type OrderLines_Pk_Columns_Input = {
  id: Scalars['String'];
};

/** select columns of table "OrderLines" */
export enum OrderLines_Select_Column {
  /** column name */
  BuyerCommission = 'buyerCommission',
  /** column name */
  CanceledAt = 'canceledAt',
  /** column name */
  Comment = 'comment',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeliveredAt = 'deliveredAt',
  /** column name */
  DiscountInCents = 'discountInCents',
  /** column name */
  FulfillmentOrderId = 'fulfillmentOrderId',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  OrderId = 'orderId',
  /** column name */
  PriceCurrency = 'priceCurrency',
  /** column name */
  PriceInCents = 'priceInCents',
  /** column name */
  ProductBrand = 'productBrand',
  /** column name */
  ProductGender = 'productGender',
  /** column name */
  ProductHandle = 'productHandle',
  /** column name */
  ProductImage = 'productImage',
  /** column name */
  ProductModelYear = 'productModelYear',
  /** column name */
  ProductSize = 'productSize',
  /** column name */
  ProductType = 'productType',
  /** column name */
  ProductVariantId = 'productVariantId',
  /** column name */
  Quantity = 'quantity',
  /** column name */
  ShippingSolution = 'shippingSolution',
  /** column name */
  ShopifyId = 'shopifyId',
  /** column name */
  VariantCondition = 'variantCondition',
  /** column name */
  VendorCommission = 'vendorCommission',
  /** column name */
  VendorId = 'vendorId',
  /** column name */
  VendorShipping = 'vendorShipping',
}

/** select "OrderLines_aggregate_bool_exp_avg_arguments_columns" columns of table "OrderLines" */
export enum OrderLines_Select_Column_OrderLines_Aggregate_Bool_Exp_Avg_Arguments_Columns {
  /** column name */
  BuyerCommission = 'buyerCommission',
  /** column name */
  DiscountInCents = 'discountInCents',
  /** column name */
  PriceInCents = 'priceInCents',
  /** column name */
  VendorCommission = 'vendorCommission',
  /** column name */
  VendorShipping = 'vendorShipping',
}

/** select "OrderLines_aggregate_bool_exp_corr_arguments_columns" columns of table "OrderLines" */
export enum OrderLines_Select_Column_OrderLines_Aggregate_Bool_Exp_Corr_Arguments_Columns {
  /** column name */
  BuyerCommission = 'buyerCommission',
  /** column name */
  DiscountInCents = 'discountInCents',
  /** column name */
  PriceInCents = 'priceInCents',
  /** column name */
  VendorCommission = 'vendorCommission',
  /** column name */
  VendorShipping = 'vendorShipping',
}

/** select "OrderLines_aggregate_bool_exp_covar_samp_arguments_columns" columns of table "OrderLines" */
export enum OrderLines_Select_Column_OrderLines_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns {
  /** column name */
  BuyerCommission = 'buyerCommission',
  /** column name */
  DiscountInCents = 'discountInCents',
  /** column name */
  PriceInCents = 'priceInCents',
  /** column name */
  VendorCommission = 'vendorCommission',
  /** column name */
  VendorShipping = 'vendorShipping',
}

/** select "OrderLines_aggregate_bool_exp_max_arguments_columns" columns of table "OrderLines" */
export enum OrderLines_Select_Column_OrderLines_Aggregate_Bool_Exp_Max_Arguments_Columns {
  /** column name */
  BuyerCommission = 'buyerCommission',
  /** column name */
  DiscountInCents = 'discountInCents',
  /** column name */
  PriceInCents = 'priceInCents',
  /** column name */
  VendorCommission = 'vendorCommission',
  /** column name */
  VendorShipping = 'vendorShipping',
}

/** select "OrderLines_aggregate_bool_exp_min_arguments_columns" columns of table "OrderLines" */
export enum OrderLines_Select_Column_OrderLines_Aggregate_Bool_Exp_Min_Arguments_Columns {
  /** column name */
  BuyerCommission = 'buyerCommission',
  /** column name */
  DiscountInCents = 'discountInCents',
  /** column name */
  PriceInCents = 'priceInCents',
  /** column name */
  VendorCommission = 'vendorCommission',
  /** column name */
  VendorShipping = 'vendorShipping',
}

/** select "OrderLines_aggregate_bool_exp_stddev_samp_arguments_columns" columns of table "OrderLines" */
export enum OrderLines_Select_Column_OrderLines_Aggregate_Bool_Exp_Stddev_Samp_Arguments_Columns {
  /** column name */
  BuyerCommission = 'buyerCommission',
  /** column name */
  DiscountInCents = 'discountInCents',
  /** column name */
  PriceInCents = 'priceInCents',
  /** column name */
  VendorCommission = 'vendorCommission',
  /** column name */
  VendorShipping = 'vendorShipping',
}

/** select "OrderLines_aggregate_bool_exp_sum_arguments_columns" columns of table "OrderLines" */
export enum OrderLines_Select_Column_OrderLines_Aggregate_Bool_Exp_Sum_Arguments_Columns {
  /** column name */
  BuyerCommission = 'buyerCommission',
  /** column name */
  DiscountInCents = 'discountInCents',
  /** column name */
  PriceInCents = 'priceInCents',
  /** column name */
  VendorCommission = 'vendorCommission',
  /** column name */
  VendorShipping = 'vendorShipping',
}

/** select "OrderLines_aggregate_bool_exp_var_samp_arguments_columns" columns of table "OrderLines" */
export enum OrderLines_Select_Column_OrderLines_Aggregate_Bool_Exp_Var_Samp_Arguments_Columns {
  /** column name */
  BuyerCommission = 'buyerCommission',
  /** column name */
  DiscountInCents = 'discountInCents',
  /** column name */
  PriceInCents = 'priceInCents',
  /** column name */
  VendorCommission = 'vendorCommission',
  /** column name */
  VendorShipping = 'vendorShipping',
}

/** input type for updating data in table "OrderLines" */
export type OrderLines_Set_Input = {
  buyerCommission: InputMaybe<Scalars['float8']>;
  canceledAt: InputMaybe<Scalars['timestamp']>;
  comment: InputMaybe<Scalars['String']>;
  createdAt: InputMaybe<Scalars['timestamp']>;
  deliveredAt: InputMaybe<Scalars['timestamp']>;
  discountInCents: InputMaybe<Scalars['float8']>;
  fulfillmentOrderId: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  name: InputMaybe<Scalars['String']>;
  orderId: InputMaybe<Scalars['String']>;
  priceCurrency: InputMaybe<Scalars['Currency']>;
  priceInCents: InputMaybe<Scalars['float8']>;
  productBrand: InputMaybe<Scalars['String']>;
  productGender: InputMaybe<Scalars['String']>;
  productHandle: InputMaybe<Scalars['String']>;
  productImage: InputMaybe<Scalars['String']>;
  productModelYear: InputMaybe<Scalars['String']>;
  productSize: InputMaybe<Scalars['String']>;
  productType: InputMaybe<Scalars['String']>;
  productVariantId: InputMaybe<Scalars['String']>;
  quantity: InputMaybe<Scalars['Int']>;
  shippingSolution: InputMaybe<Scalars['ShippingSolution']>;
  shopifyId: InputMaybe<Scalars['String']>;
  variantCondition: InputMaybe<Scalars['Condition']>;
  vendorCommission: InputMaybe<Scalars['float8']>;
  vendorId: InputMaybe<Scalars['uuid']>;
  vendorShipping: InputMaybe<Scalars['float8']>;
};

/** aggregate stddev on columns */
export type OrderLines_Stddev_Fields = {
  __typename?: 'OrderLines_stddev_fields';
  buyerCommission: Maybe<Scalars['Float']>;
  discountInCents: Maybe<Scalars['Float']>;
  priceInCents: Maybe<Scalars['Float']>;
  quantity: Maybe<Scalars['Float']>;
  vendorCommission: Maybe<Scalars['Float']>;
  vendorShipping: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "OrderLines" */
export type OrderLines_Stddev_Order_By = {
  buyerCommission: InputMaybe<Order_By>;
  discountInCents: InputMaybe<Order_By>;
  priceInCents: InputMaybe<Order_By>;
  quantity: InputMaybe<Order_By>;
  vendorCommission: InputMaybe<Order_By>;
  vendorShipping: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type OrderLines_Stddev_Pop_Fields = {
  __typename?: 'OrderLines_stddev_pop_fields';
  buyerCommission: Maybe<Scalars['Float']>;
  discountInCents: Maybe<Scalars['Float']>;
  priceInCents: Maybe<Scalars['Float']>;
  quantity: Maybe<Scalars['Float']>;
  vendorCommission: Maybe<Scalars['Float']>;
  vendorShipping: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "OrderLines" */
export type OrderLines_Stddev_Pop_Order_By = {
  buyerCommission: InputMaybe<Order_By>;
  discountInCents: InputMaybe<Order_By>;
  priceInCents: InputMaybe<Order_By>;
  quantity: InputMaybe<Order_By>;
  vendorCommission: InputMaybe<Order_By>;
  vendorShipping: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type OrderLines_Stddev_Samp_Fields = {
  __typename?: 'OrderLines_stddev_samp_fields';
  buyerCommission: Maybe<Scalars['Float']>;
  discountInCents: Maybe<Scalars['Float']>;
  priceInCents: Maybe<Scalars['Float']>;
  quantity: Maybe<Scalars['Float']>;
  vendorCommission: Maybe<Scalars['Float']>;
  vendorShipping: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "OrderLines" */
export type OrderLines_Stddev_Samp_Order_By = {
  buyerCommission: InputMaybe<Order_By>;
  discountInCents: InputMaybe<Order_By>;
  priceInCents: InputMaybe<Order_By>;
  quantity: InputMaybe<Order_By>;
  vendorCommission: InputMaybe<Order_By>;
  vendorShipping: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "OrderLines" */
export type OrderLines_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: OrderLines_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type OrderLines_Stream_Cursor_Value_Input = {
  buyerCommission: InputMaybe<Scalars['float8']>;
  canceledAt: InputMaybe<Scalars['timestamp']>;
  comment: InputMaybe<Scalars['String']>;
  createdAt: InputMaybe<Scalars['timestamp']>;
  deliveredAt: InputMaybe<Scalars['timestamp']>;
  discountInCents: InputMaybe<Scalars['float8']>;
  fulfillmentOrderId: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  name: InputMaybe<Scalars['String']>;
  orderId: InputMaybe<Scalars['String']>;
  priceCurrency: InputMaybe<Scalars['Currency']>;
  priceInCents: InputMaybe<Scalars['float8']>;
  productBrand: InputMaybe<Scalars['String']>;
  productGender: InputMaybe<Scalars['String']>;
  productHandle: InputMaybe<Scalars['String']>;
  productImage: InputMaybe<Scalars['String']>;
  productModelYear: InputMaybe<Scalars['String']>;
  productSize: InputMaybe<Scalars['String']>;
  productType: InputMaybe<Scalars['String']>;
  productVariantId: InputMaybe<Scalars['String']>;
  quantity: InputMaybe<Scalars['Int']>;
  shippingSolution: InputMaybe<Scalars['ShippingSolution']>;
  shopifyId: InputMaybe<Scalars['String']>;
  variantCondition: InputMaybe<Scalars['Condition']>;
  vendorCommission: InputMaybe<Scalars['float8']>;
  vendorId: InputMaybe<Scalars['uuid']>;
  vendorShipping: InputMaybe<Scalars['float8']>;
};

/** aggregate sum on columns */
export type OrderLines_Sum_Fields = {
  __typename?: 'OrderLines_sum_fields';
  buyerCommission: Maybe<Scalars['float8']>;
  discountInCents: Maybe<Scalars['float8']>;
  priceInCents: Maybe<Scalars['float8']>;
  quantity: Maybe<Scalars['Int']>;
  vendorCommission: Maybe<Scalars['float8']>;
  vendorShipping: Maybe<Scalars['float8']>;
};

/** order by sum() on columns of table "OrderLines" */
export type OrderLines_Sum_Order_By = {
  buyerCommission: InputMaybe<Order_By>;
  discountInCents: InputMaybe<Order_By>;
  priceInCents: InputMaybe<Order_By>;
  quantity: InputMaybe<Order_By>;
  vendorCommission: InputMaybe<Order_By>;
  vendorShipping: InputMaybe<Order_By>;
};

/** update columns of table "OrderLines" */
export enum OrderLines_Update_Column {
  /** column name */
  BuyerCommission = 'buyerCommission',
  /** column name */
  CanceledAt = 'canceledAt',
  /** column name */
  Comment = 'comment',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeliveredAt = 'deliveredAt',
  /** column name */
  DiscountInCents = 'discountInCents',
  /** column name */
  FulfillmentOrderId = 'fulfillmentOrderId',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  OrderId = 'orderId',
  /** column name */
  PriceCurrency = 'priceCurrency',
  /** column name */
  PriceInCents = 'priceInCents',
  /** column name */
  ProductBrand = 'productBrand',
  /** column name */
  ProductGender = 'productGender',
  /** column name */
  ProductHandle = 'productHandle',
  /** column name */
  ProductImage = 'productImage',
  /** column name */
  ProductModelYear = 'productModelYear',
  /** column name */
  ProductSize = 'productSize',
  /** column name */
  ProductType = 'productType',
  /** column name */
  ProductVariantId = 'productVariantId',
  /** column name */
  Quantity = 'quantity',
  /** column name */
  ShippingSolution = 'shippingSolution',
  /** column name */
  ShopifyId = 'shopifyId',
  /** column name */
  VariantCondition = 'variantCondition',
  /** column name */
  VendorCommission = 'vendorCommission',
  /** column name */
  VendorId = 'vendorId',
  /** column name */
  VendorShipping = 'vendorShipping',
}

export type OrderLines_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<OrderLines_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<OrderLines_Set_Input>;
  /** filter the rows which have to be updated */
  where: OrderLines_Bool_Exp;
};

/** aggregate var_pop on columns */
export type OrderLines_Var_Pop_Fields = {
  __typename?: 'OrderLines_var_pop_fields';
  buyerCommission: Maybe<Scalars['Float']>;
  discountInCents: Maybe<Scalars['Float']>;
  priceInCents: Maybe<Scalars['Float']>;
  quantity: Maybe<Scalars['Float']>;
  vendorCommission: Maybe<Scalars['Float']>;
  vendorShipping: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "OrderLines" */
export type OrderLines_Var_Pop_Order_By = {
  buyerCommission: InputMaybe<Order_By>;
  discountInCents: InputMaybe<Order_By>;
  priceInCents: InputMaybe<Order_By>;
  quantity: InputMaybe<Order_By>;
  vendorCommission: InputMaybe<Order_By>;
  vendorShipping: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type OrderLines_Var_Samp_Fields = {
  __typename?: 'OrderLines_var_samp_fields';
  buyerCommission: Maybe<Scalars['Float']>;
  discountInCents: Maybe<Scalars['Float']>;
  priceInCents: Maybe<Scalars['Float']>;
  quantity: Maybe<Scalars['Float']>;
  vendorCommission: Maybe<Scalars['Float']>;
  vendorShipping: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "OrderLines" */
export type OrderLines_Var_Samp_Order_By = {
  buyerCommission: InputMaybe<Order_By>;
  discountInCents: InputMaybe<Order_By>;
  priceInCents: InputMaybe<Order_By>;
  quantity: InputMaybe<Order_By>;
  vendorCommission: InputMaybe<Order_By>;
  vendorShipping: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type OrderLines_Variance_Fields = {
  __typename?: 'OrderLines_variance_fields';
  buyerCommission: Maybe<Scalars['Float']>;
  discountInCents: Maybe<Scalars['Float']>;
  priceInCents: Maybe<Scalars['Float']>;
  quantity: Maybe<Scalars['Float']>;
  vendorCommission: Maybe<Scalars['Float']>;
  vendorShipping: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "OrderLines" */
export type OrderLines_Variance_Order_By = {
  buyerCommission: InputMaybe<Order_By>;
  discountInCents: InputMaybe<Order_By>;
  priceInCents: InputMaybe<Order_By>;
  quantity: InputMaybe<Order_By>;
  vendorCommission: InputMaybe<Order_By>;
  vendorShipping: InputMaybe<Order_By>;
};

/** Boolean expression to compare columns of type "OrderStatus". All fields are combined with logical 'AND'. */
export type OrderStatus_Comparison_Exp = {
  _eq: InputMaybe<Scalars['OrderStatus']>;
  _gt: InputMaybe<Scalars['OrderStatus']>;
  _gte: InputMaybe<Scalars['OrderStatus']>;
  _in: InputMaybe<Array<Scalars['OrderStatus']>>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  _lt: InputMaybe<Scalars['OrderStatus']>;
  _lte: InputMaybe<Scalars['OrderStatus']>;
  _neq: InputMaybe<Scalars['OrderStatus']>;
  _nin: InputMaybe<Array<Scalars['OrderStatus']>>;
};

/** aggregated selection of "Order" */
export type Order_Aggregate = {
  __typename?: 'Order_aggregate';
  aggregate: Maybe<Order_Aggregate_Fields>;
  nodes: Array<Order>;
};

export type Order_Aggregate_Bool_Exp = {
  avg: InputMaybe<Order_Aggregate_Bool_Exp_Avg>;
  corr: InputMaybe<Order_Aggregate_Bool_Exp_Corr>;
  count: InputMaybe<Order_Aggregate_Bool_Exp_Count>;
  covar_samp: InputMaybe<Order_Aggregate_Bool_Exp_Covar_Samp>;
  max: InputMaybe<Order_Aggregate_Bool_Exp_Max>;
  min: InputMaybe<Order_Aggregate_Bool_Exp_Min>;
  stddev_samp: InputMaybe<Order_Aggregate_Bool_Exp_Stddev_Samp>;
  sum: InputMaybe<Order_Aggregate_Bool_Exp_Sum>;
  var_samp: InputMaybe<Order_Aggregate_Bool_Exp_Var_Samp>;
};

export type Order_Aggregate_Bool_Exp_Avg = {
  arguments: Order_Select_Column_Order_Aggregate_Bool_Exp_Avg_Arguments_Columns;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<Order_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Order_Aggregate_Bool_Exp_Corr = {
  arguments: Order_Aggregate_Bool_Exp_Corr_Arguments;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<Order_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Order_Aggregate_Bool_Exp_Corr_Arguments = {
  X: Order_Select_Column_Order_Aggregate_Bool_Exp_Corr_Arguments_Columns;
  Y: Order_Select_Column_Order_Aggregate_Bool_Exp_Corr_Arguments_Columns;
};

export type Order_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<Order_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<Order_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

export type Order_Aggregate_Bool_Exp_Covar_Samp = {
  arguments: Order_Aggregate_Bool_Exp_Covar_Samp_Arguments;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<Order_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Order_Aggregate_Bool_Exp_Covar_Samp_Arguments = {
  X: Order_Select_Column_Order_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns;
  Y: Order_Select_Column_Order_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns;
};

export type Order_Aggregate_Bool_Exp_Max = {
  arguments: Order_Select_Column_Order_Aggregate_Bool_Exp_Max_Arguments_Columns;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<Order_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Order_Aggregate_Bool_Exp_Min = {
  arguments: Order_Select_Column_Order_Aggregate_Bool_Exp_Min_Arguments_Columns;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<Order_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Order_Aggregate_Bool_Exp_Stddev_Samp = {
  arguments: Order_Select_Column_Order_Aggregate_Bool_Exp_Stddev_Samp_Arguments_Columns;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<Order_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Order_Aggregate_Bool_Exp_Sum = {
  arguments: Order_Select_Column_Order_Aggregate_Bool_Exp_Sum_Arguments_Columns;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<Order_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Order_Aggregate_Bool_Exp_Var_Samp = {
  arguments: Order_Select_Column_Order_Aggregate_Bool_Exp_Var_Samp_Arguments_Columns;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<Order_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

/** aggregate fields of "Order" */
export type Order_Aggregate_Fields = {
  __typename?: 'Order_aggregate_fields';
  avg: Maybe<Order_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Order_Max_Fields>;
  min: Maybe<Order_Min_Fields>;
  stddev: Maybe<Order_Stddev_Fields>;
  stddev_pop: Maybe<Order_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Order_Stddev_Samp_Fields>;
  sum: Maybe<Order_Sum_Fields>;
  var_pop: Maybe<Order_Var_Pop_Fields>;
  var_samp: Maybe<Order_Var_Samp_Fields>;
  variance: Maybe<Order_Variance_Fields>;
};

/** aggregate fields of "Order" */
export type Order_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Order_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "Order" */
export type Order_Aggregate_Order_By = {
  avg: InputMaybe<Order_Avg_Order_By>;
  count: InputMaybe<Order_By>;
  max: InputMaybe<Order_Max_Order_By>;
  min: InputMaybe<Order_Min_Order_By>;
  stddev: InputMaybe<Order_Stddev_Order_By>;
  stddev_pop: InputMaybe<Order_Stddev_Pop_Order_By>;
  stddev_samp: InputMaybe<Order_Stddev_Samp_Order_By>;
  sum: InputMaybe<Order_Sum_Order_By>;
  var_pop: InputMaybe<Order_Var_Pop_Order_By>;
  var_samp: InputMaybe<Order_Var_Samp_Order_By>;
  variance: InputMaybe<Order_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "Order" */
export type Order_Arr_Rel_Insert_Input = {
  data: Array<Order_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<Order_On_Conflict>;
};

/** aggregate avg on columns */
export type Order_Avg_Fields = {
  __typename?: 'Order_avg_fields';
  totalPriceInCents: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "Order" */
export type Order_Avg_Order_By = {
  totalPriceInCents: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "Order". All fields are combined with a logical 'AND'. */
export type Order_Bool_Exp = {
  _and: InputMaybe<Array<Order_Bool_Exp>>;
  _not: InputMaybe<Order_Bool_Exp>;
  _or: InputMaybe<Array<Order_Bool_Exp>>;
  buyerCustomer: InputMaybe<Customer_Bool_Exp>;
  checkoutId: InputMaybe<String_Comparison_Exp>;
  createdAt: InputMaybe<Timestamp_Comparison_Exp>;
  customerEmail: InputMaybe<String_Comparison_Exp>;
  customerId: InputMaybe<Uuid_Comparison_Exp>;
  fulfillmentOrders: InputMaybe<FulfillmentOrder_Bool_Exp>;
  fulfillmentOrders_aggregate: InputMaybe<FulfillmentOrder_Aggregate_Bool_Exp>;
  id: InputMaybe<String_Comparison_Exp>;
  name: InputMaybe<String_Comparison_Exp>;
  orderLines: InputMaybe<OrderLines_Bool_Exp>;
  orderLines_aggregate: InputMaybe<OrderLines_Aggregate_Bool_Exp>;
  paidAt: InputMaybe<Timestamp_Comparison_Exp>;
  shippingAddressAddress1: InputMaybe<String_Comparison_Exp>;
  shippingAddressAddress2: InputMaybe<String_Comparison_Exp>;
  shippingAddressCity: InputMaybe<String_Comparison_Exp>;
  shippingAddressCompany: InputMaybe<String_Comparison_Exp>;
  shippingAddressCountry: InputMaybe<String_Comparison_Exp>;
  shippingAddressFirstName: InputMaybe<String_Comparison_Exp>;
  shippingAddressLastName: InputMaybe<String_Comparison_Exp>;
  shippingAddressPhone: InputMaybe<String_Comparison_Exp>;
  shippingAddressZip: InputMaybe<String_Comparison_Exp>;
  shopifyId: InputMaybe<String_Comparison_Exp>;
  status: InputMaybe<OrderStatus_Comparison_Exp>;
  totalPriceCurrency: InputMaybe<Currency_Comparison_Exp>;
  totalPriceInCents: InputMaybe<Float8_Comparison_Exp>;
};

/** unique or primary key constraints on table "Order" */
export enum Order_Constraint {
  /** unique or primary key constraint on columns "checkoutId" */
  OrderCheckoutIdKey = 'Order_checkoutId_key',
  /** unique or primary key constraint on columns "id" */
  OrderPkey = 'Order_pkey',
  /** unique or primary key constraint on columns "shopifyId" */
  OrderShopifyIdKey = 'Order_shopifyId_key',
}

/** input type for incrementing numeric columns in table "Order" */
export type Order_Inc_Input = {
  totalPriceInCents: InputMaybe<Scalars['float8']>;
};

/** input type for inserting data into table "Order" */
export type Order_Insert_Input = {
  buyerCustomer: InputMaybe<Customer_Obj_Rel_Insert_Input>;
  checkoutId: InputMaybe<Scalars['String']>;
  createdAt: InputMaybe<Scalars['timestamp']>;
  customerEmail: InputMaybe<Scalars['String']>;
  customerId: InputMaybe<Scalars['uuid']>;
  fulfillmentOrders: InputMaybe<FulfillmentOrder_Arr_Rel_Insert_Input>;
  id: InputMaybe<Scalars['String']>;
  name: InputMaybe<Scalars['String']>;
  orderLines: InputMaybe<OrderLines_Arr_Rel_Insert_Input>;
  paidAt: InputMaybe<Scalars['timestamp']>;
  shippingAddressAddress1: InputMaybe<Scalars['String']>;
  shippingAddressAddress2: InputMaybe<Scalars['String']>;
  shippingAddressCity: InputMaybe<Scalars['String']>;
  shippingAddressCompany: InputMaybe<Scalars['String']>;
  shippingAddressCountry: InputMaybe<Scalars['String']>;
  shippingAddressFirstName: InputMaybe<Scalars['String']>;
  shippingAddressLastName: InputMaybe<Scalars['String']>;
  shippingAddressPhone: InputMaybe<Scalars['String']>;
  shippingAddressZip: InputMaybe<Scalars['String']>;
  shopifyId: InputMaybe<Scalars['String']>;
  status: InputMaybe<Scalars['OrderStatus']>;
  totalPriceCurrency: InputMaybe<Scalars['Currency']>;
  totalPriceInCents: InputMaybe<Scalars['float8']>;
};

/** aggregate max on columns */
export type Order_Max_Fields = {
  __typename?: 'Order_max_fields';
  checkoutId: Maybe<Scalars['String']>;
  createdAt: Maybe<Scalars['timestamp']>;
  customerEmail: Maybe<Scalars['String']>;
  customerId: Maybe<Scalars['uuid']>;
  id: Maybe<Scalars['String']>;
  name: Maybe<Scalars['String']>;
  paidAt: Maybe<Scalars['timestamp']>;
  shippingAddressAddress1: Maybe<Scalars['String']>;
  shippingAddressAddress2: Maybe<Scalars['String']>;
  shippingAddressCity: Maybe<Scalars['String']>;
  shippingAddressCompany: Maybe<Scalars['String']>;
  shippingAddressCountry: Maybe<Scalars['String']>;
  shippingAddressFirstName: Maybe<Scalars['String']>;
  shippingAddressLastName: Maybe<Scalars['String']>;
  shippingAddressPhone: Maybe<Scalars['String']>;
  shippingAddressZip: Maybe<Scalars['String']>;
  shopifyId: Maybe<Scalars['String']>;
  status: Maybe<Scalars['OrderStatus']>;
  totalPriceCurrency: Maybe<Scalars['Currency']>;
  totalPriceInCents: Maybe<Scalars['float8']>;
};

/** order by max() on columns of table "Order" */
export type Order_Max_Order_By = {
  checkoutId: InputMaybe<Order_By>;
  createdAt: InputMaybe<Order_By>;
  customerEmail: InputMaybe<Order_By>;
  customerId: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  name: InputMaybe<Order_By>;
  paidAt: InputMaybe<Order_By>;
  shippingAddressAddress1: InputMaybe<Order_By>;
  shippingAddressAddress2: InputMaybe<Order_By>;
  shippingAddressCity: InputMaybe<Order_By>;
  shippingAddressCompany: InputMaybe<Order_By>;
  shippingAddressCountry: InputMaybe<Order_By>;
  shippingAddressFirstName: InputMaybe<Order_By>;
  shippingAddressLastName: InputMaybe<Order_By>;
  shippingAddressPhone: InputMaybe<Order_By>;
  shippingAddressZip: InputMaybe<Order_By>;
  shopifyId: InputMaybe<Order_By>;
  status: InputMaybe<Order_By>;
  totalPriceCurrency: InputMaybe<Order_By>;
  totalPriceInCents: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Order_Min_Fields = {
  __typename?: 'Order_min_fields';
  checkoutId: Maybe<Scalars['String']>;
  createdAt: Maybe<Scalars['timestamp']>;
  customerEmail: Maybe<Scalars['String']>;
  customerId: Maybe<Scalars['uuid']>;
  id: Maybe<Scalars['String']>;
  name: Maybe<Scalars['String']>;
  paidAt: Maybe<Scalars['timestamp']>;
  shippingAddressAddress1: Maybe<Scalars['String']>;
  shippingAddressAddress2: Maybe<Scalars['String']>;
  shippingAddressCity: Maybe<Scalars['String']>;
  shippingAddressCompany: Maybe<Scalars['String']>;
  shippingAddressCountry: Maybe<Scalars['String']>;
  shippingAddressFirstName: Maybe<Scalars['String']>;
  shippingAddressLastName: Maybe<Scalars['String']>;
  shippingAddressPhone: Maybe<Scalars['String']>;
  shippingAddressZip: Maybe<Scalars['String']>;
  shopifyId: Maybe<Scalars['String']>;
  status: Maybe<Scalars['OrderStatus']>;
  totalPriceCurrency: Maybe<Scalars['Currency']>;
  totalPriceInCents: Maybe<Scalars['float8']>;
};

/** order by min() on columns of table "Order" */
export type Order_Min_Order_By = {
  checkoutId: InputMaybe<Order_By>;
  createdAt: InputMaybe<Order_By>;
  customerEmail: InputMaybe<Order_By>;
  customerId: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  name: InputMaybe<Order_By>;
  paidAt: InputMaybe<Order_By>;
  shippingAddressAddress1: InputMaybe<Order_By>;
  shippingAddressAddress2: InputMaybe<Order_By>;
  shippingAddressCity: InputMaybe<Order_By>;
  shippingAddressCompany: InputMaybe<Order_By>;
  shippingAddressCountry: InputMaybe<Order_By>;
  shippingAddressFirstName: InputMaybe<Order_By>;
  shippingAddressLastName: InputMaybe<Order_By>;
  shippingAddressPhone: InputMaybe<Order_By>;
  shippingAddressZip: InputMaybe<Order_By>;
  shopifyId: InputMaybe<Order_By>;
  status: InputMaybe<Order_By>;
  totalPriceCurrency: InputMaybe<Order_By>;
  totalPriceInCents: InputMaybe<Order_By>;
};

/** response of any mutation on the table "Order" */
export type Order_Mutation_Response = {
  __typename?: 'Order_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Order>;
};

/** input type for inserting object relation for remote table "Order" */
export type Order_Obj_Rel_Insert_Input = {
  data: Order_Insert_Input;
  /** upsert condition */
  on_conflict: InputMaybe<Order_On_Conflict>;
};

/** on_conflict condition type for table "Order" */
export type Order_On_Conflict = {
  constraint: Order_Constraint;
  update_columns: Array<Order_Update_Column>;
  where: InputMaybe<Order_Bool_Exp>;
};

/** Ordering options when selecting data from "Order". */
export type Order_Order_By = {
  buyerCustomer: InputMaybe<Customer_Order_By>;
  checkoutId: InputMaybe<Order_By>;
  createdAt: InputMaybe<Order_By>;
  customerEmail: InputMaybe<Order_By>;
  customerId: InputMaybe<Order_By>;
  fulfillmentOrders_aggregate: InputMaybe<FulfillmentOrder_Aggregate_Order_By>;
  id: InputMaybe<Order_By>;
  name: InputMaybe<Order_By>;
  orderLines_aggregate: InputMaybe<OrderLines_Aggregate_Order_By>;
  paidAt: InputMaybe<Order_By>;
  shippingAddressAddress1: InputMaybe<Order_By>;
  shippingAddressAddress2: InputMaybe<Order_By>;
  shippingAddressCity: InputMaybe<Order_By>;
  shippingAddressCompany: InputMaybe<Order_By>;
  shippingAddressCountry: InputMaybe<Order_By>;
  shippingAddressFirstName: InputMaybe<Order_By>;
  shippingAddressLastName: InputMaybe<Order_By>;
  shippingAddressPhone: InputMaybe<Order_By>;
  shippingAddressZip: InputMaybe<Order_By>;
  shopifyId: InputMaybe<Order_By>;
  status: InputMaybe<Order_By>;
  totalPriceCurrency: InputMaybe<Order_By>;
  totalPriceInCents: InputMaybe<Order_By>;
};

/** primary key columns input for table: Order */
export type Order_Pk_Columns_Input = {
  id: Scalars['String'];
};

/** select columns of table "Order" */
export enum Order_Select_Column {
  /** column name */
  CheckoutId = 'checkoutId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CustomerEmail = 'customerEmail',
  /** column name */
  CustomerId = 'customerId',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  PaidAt = 'paidAt',
  /** column name */
  ShippingAddressAddress1 = 'shippingAddressAddress1',
  /** column name */
  ShippingAddressAddress2 = 'shippingAddressAddress2',
  /** column name */
  ShippingAddressCity = 'shippingAddressCity',
  /** column name */
  ShippingAddressCompany = 'shippingAddressCompany',
  /** column name */
  ShippingAddressCountry = 'shippingAddressCountry',
  /** column name */
  ShippingAddressFirstName = 'shippingAddressFirstName',
  /** column name */
  ShippingAddressLastName = 'shippingAddressLastName',
  /** column name */
  ShippingAddressPhone = 'shippingAddressPhone',
  /** column name */
  ShippingAddressZip = 'shippingAddressZip',
  /** column name */
  ShopifyId = 'shopifyId',
  /** column name */
  Status = 'status',
  /** column name */
  TotalPriceCurrency = 'totalPriceCurrency',
  /** column name */
  TotalPriceInCents = 'totalPriceInCents',
}

/** select "Order_aggregate_bool_exp_avg_arguments_columns" columns of table "Order" */
export enum Order_Select_Column_Order_Aggregate_Bool_Exp_Avg_Arguments_Columns {
  /** column name */
  TotalPriceInCents = 'totalPriceInCents',
}

/** select "Order_aggregate_bool_exp_corr_arguments_columns" columns of table "Order" */
export enum Order_Select_Column_Order_Aggregate_Bool_Exp_Corr_Arguments_Columns {
  /** column name */
  TotalPriceInCents = 'totalPriceInCents',
}

/** select "Order_aggregate_bool_exp_covar_samp_arguments_columns" columns of table "Order" */
export enum Order_Select_Column_Order_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns {
  /** column name */
  TotalPriceInCents = 'totalPriceInCents',
}

/** select "Order_aggregate_bool_exp_max_arguments_columns" columns of table "Order" */
export enum Order_Select_Column_Order_Aggregate_Bool_Exp_Max_Arguments_Columns {
  /** column name */
  TotalPriceInCents = 'totalPriceInCents',
}

/** select "Order_aggregate_bool_exp_min_arguments_columns" columns of table "Order" */
export enum Order_Select_Column_Order_Aggregate_Bool_Exp_Min_Arguments_Columns {
  /** column name */
  TotalPriceInCents = 'totalPriceInCents',
}

/** select "Order_aggregate_bool_exp_stddev_samp_arguments_columns" columns of table "Order" */
export enum Order_Select_Column_Order_Aggregate_Bool_Exp_Stddev_Samp_Arguments_Columns {
  /** column name */
  TotalPriceInCents = 'totalPriceInCents',
}

/** select "Order_aggregate_bool_exp_sum_arguments_columns" columns of table "Order" */
export enum Order_Select_Column_Order_Aggregate_Bool_Exp_Sum_Arguments_Columns {
  /** column name */
  TotalPriceInCents = 'totalPriceInCents',
}

/** select "Order_aggregate_bool_exp_var_samp_arguments_columns" columns of table "Order" */
export enum Order_Select_Column_Order_Aggregate_Bool_Exp_Var_Samp_Arguments_Columns {
  /** column name */
  TotalPriceInCents = 'totalPriceInCents',
}

/** input type for updating data in table "Order" */
export type Order_Set_Input = {
  checkoutId: InputMaybe<Scalars['String']>;
  createdAt: InputMaybe<Scalars['timestamp']>;
  customerEmail: InputMaybe<Scalars['String']>;
  customerId: InputMaybe<Scalars['uuid']>;
  id: InputMaybe<Scalars['String']>;
  name: InputMaybe<Scalars['String']>;
  paidAt: InputMaybe<Scalars['timestamp']>;
  shippingAddressAddress1: InputMaybe<Scalars['String']>;
  shippingAddressAddress2: InputMaybe<Scalars['String']>;
  shippingAddressCity: InputMaybe<Scalars['String']>;
  shippingAddressCompany: InputMaybe<Scalars['String']>;
  shippingAddressCountry: InputMaybe<Scalars['String']>;
  shippingAddressFirstName: InputMaybe<Scalars['String']>;
  shippingAddressLastName: InputMaybe<Scalars['String']>;
  shippingAddressPhone: InputMaybe<Scalars['String']>;
  shippingAddressZip: InputMaybe<Scalars['String']>;
  shopifyId: InputMaybe<Scalars['String']>;
  status: InputMaybe<Scalars['OrderStatus']>;
  totalPriceCurrency: InputMaybe<Scalars['Currency']>;
  totalPriceInCents: InputMaybe<Scalars['float8']>;
};

/** aggregate stddev on columns */
export type Order_Stddev_Fields = {
  __typename?: 'Order_stddev_fields';
  totalPriceInCents: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "Order" */
export type Order_Stddev_Order_By = {
  totalPriceInCents: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Order_Stddev_Pop_Fields = {
  __typename?: 'Order_stddev_pop_fields';
  totalPriceInCents: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "Order" */
export type Order_Stddev_Pop_Order_By = {
  totalPriceInCents: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Order_Stddev_Samp_Fields = {
  __typename?: 'Order_stddev_samp_fields';
  totalPriceInCents: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "Order" */
export type Order_Stddev_Samp_Order_By = {
  totalPriceInCents: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "Order" */
export type Order_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Order_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Order_Stream_Cursor_Value_Input = {
  checkoutId: InputMaybe<Scalars['String']>;
  createdAt: InputMaybe<Scalars['timestamp']>;
  customerEmail: InputMaybe<Scalars['String']>;
  customerId: InputMaybe<Scalars['uuid']>;
  id: InputMaybe<Scalars['String']>;
  name: InputMaybe<Scalars['String']>;
  paidAt: InputMaybe<Scalars['timestamp']>;
  shippingAddressAddress1: InputMaybe<Scalars['String']>;
  shippingAddressAddress2: InputMaybe<Scalars['String']>;
  shippingAddressCity: InputMaybe<Scalars['String']>;
  shippingAddressCompany: InputMaybe<Scalars['String']>;
  shippingAddressCountry: InputMaybe<Scalars['String']>;
  shippingAddressFirstName: InputMaybe<Scalars['String']>;
  shippingAddressLastName: InputMaybe<Scalars['String']>;
  shippingAddressPhone: InputMaybe<Scalars['String']>;
  shippingAddressZip: InputMaybe<Scalars['String']>;
  shopifyId: InputMaybe<Scalars['String']>;
  status: InputMaybe<Scalars['OrderStatus']>;
  totalPriceCurrency: InputMaybe<Scalars['Currency']>;
  totalPriceInCents: InputMaybe<Scalars['float8']>;
};

/** aggregate sum on columns */
export type Order_Sum_Fields = {
  __typename?: 'Order_sum_fields';
  totalPriceInCents: Maybe<Scalars['float8']>;
};

/** order by sum() on columns of table "Order" */
export type Order_Sum_Order_By = {
  totalPriceInCents: InputMaybe<Order_By>;
};

/** update columns of table "Order" */
export enum Order_Update_Column {
  /** column name */
  CheckoutId = 'checkoutId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CustomerEmail = 'customerEmail',
  /** column name */
  CustomerId = 'customerId',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  PaidAt = 'paidAt',
  /** column name */
  ShippingAddressAddress1 = 'shippingAddressAddress1',
  /** column name */
  ShippingAddressAddress2 = 'shippingAddressAddress2',
  /** column name */
  ShippingAddressCity = 'shippingAddressCity',
  /** column name */
  ShippingAddressCompany = 'shippingAddressCompany',
  /** column name */
  ShippingAddressCountry = 'shippingAddressCountry',
  /** column name */
  ShippingAddressFirstName = 'shippingAddressFirstName',
  /** column name */
  ShippingAddressLastName = 'shippingAddressLastName',
  /** column name */
  ShippingAddressPhone = 'shippingAddressPhone',
  /** column name */
  ShippingAddressZip = 'shippingAddressZip',
  /** column name */
  ShopifyId = 'shopifyId',
  /** column name */
  Status = 'status',
  /** column name */
  TotalPriceCurrency = 'totalPriceCurrency',
  /** column name */
  TotalPriceInCents = 'totalPriceInCents',
}

export type Order_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Order_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Order_Set_Input>;
  /** filter the rows which have to be updated */
  where: Order_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Order_Var_Pop_Fields = {
  __typename?: 'Order_var_pop_fields';
  totalPriceInCents: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "Order" */
export type Order_Var_Pop_Order_By = {
  totalPriceInCents: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Order_Var_Samp_Fields = {
  __typename?: 'Order_var_samp_fields';
  totalPriceInCents: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "Order" */
export type Order_Var_Samp_Order_By = {
  totalPriceInCents: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Order_Variance_Fields = {
  __typename?: 'Order_variance_fields';
  totalPriceInCents: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "Order" */
export type Order_Variance_Order_By = {
  totalPriceInCents: InputMaybe<Order_By>;
};

/** columns and relationships of "Payment" */
export type Payment = {
  __typename?: 'Payment';
  /** An object relationship */
  Payment_Checkout: Checkout;
  amountInCents: Scalars['Int'];
  checkoutId: Scalars['String'];
  createdAt: Scalars['timestamp'];
  currency: Scalars['String'];
  id: Scalars['String'];
  paymentAccountId: Maybe<Scalars['String']>;
  paymentSolutionCode: Scalars['PaymentSolutionCode'];
  paymentUrl: Maybe<Scalars['String']>;
  status: Scalars['PaymentStatusType'];
  token: Maybe<Scalars['String']>;
  updatedAt: Maybe<Scalars['timestamp']>;
};

/** Boolean expression to compare columns of type "PaymentAccountType". All fields are combined with logical 'AND'. */
export type PaymentAccountType_Comparison_Exp = {
  _eq: InputMaybe<Scalars['PaymentAccountType']>;
  _gt: InputMaybe<Scalars['PaymentAccountType']>;
  _gte: InputMaybe<Scalars['PaymentAccountType']>;
  _in: InputMaybe<Array<Scalars['PaymentAccountType']>>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  _lt: InputMaybe<Scalars['PaymentAccountType']>;
  _lte: InputMaybe<Scalars['PaymentAccountType']>;
  _neq: InputMaybe<Scalars['PaymentAccountType']>;
  _nin: InputMaybe<Array<Scalars['PaymentAccountType']>>;
};

/** columns and relationships of "PaymentAccounts" */
export type PaymentAccounts = {
  __typename?: 'PaymentAccounts';
  accountId: Scalars['String'];
  customerId: Maybe<Scalars['uuid']>;
  email: Maybe<Scalars['String']>;
  id: Scalars['String'];
  provider: Scalars['PaymentProvider'];
  type: Scalars['PaymentAccountType'];
};

/** aggregated selection of "PaymentAccounts" */
export type PaymentAccounts_Aggregate = {
  __typename?: 'PaymentAccounts_aggregate';
  aggregate: Maybe<PaymentAccounts_Aggregate_Fields>;
  nodes: Array<PaymentAccounts>;
};

export type PaymentAccounts_Aggregate_Bool_Exp = {
  count: InputMaybe<PaymentAccounts_Aggregate_Bool_Exp_Count>;
};

export type PaymentAccounts_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<PaymentAccounts_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<PaymentAccounts_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "PaymentAccounts" */
export type PaymentAccounts_Aggregate_Fields = {
  __typename?: 'PaymentAccounts_aggregate_fields';
  count: Scalars['Int'];
  max: Maybe<PaymentAccounts_Max_Fields>;
  min: Maybe<PaymentAccounts_Min_Fields>;
};

/** aggregate fields of "PaymentAccounts" */
export type PaymentAccounts_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<PaymentAccounts_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "PaymentAccounts" */
export type PaymentAccounts_Aggregate_Order_By = {
  count: InputMaybe<Order_By>;
  max: InputMaybe<PaymentAccounts_Max_Order_By>;
  min: InputMaybe<PaymentAccounts_Min_Order_By>;
};

/** input type for inserting array relation for remote table "PaymentAccounts" */
export type PaymentAccounts_Arr_Rel_Insert_Input = {
  data: Array<PaymentAccounts_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<PaymentAccounts_On_Conflict>;
};

/** Boolean expression to filter rows from the table "PaymentAccounts". All fields are combined with a logical 'AND'. */
export type PaymentAccounts_Bool_Exp = {
  _and: InputMaybe<Array<PaymentAccounts_Bool_Exp>>;
  _not: InputMaybe<PaymentAccounts_Bool_Exp>;
  _or: InputMaybe<Array<PaymentAccounts_Bool_Exp>>;
  accountId: InputMaybe<String_Comparison_Exp>;
  customerId: InputMaybe<Uuid_Comparison_Exp>;
  email: InputMaybe<String_Comparison_Exp>;
  id: InputMaybe<String_Comparison_Exp>;
  provider: InputMaybe<PaymentProvider_Comparison_Exp>;
  type: InputMaybe<PaymentAccountType_Comparison_Exp>;
};

/** unique or primary key constraints on table "PaymentAccounts" */
export enum PaymentAccounts_Constraint {
  /** unique or primary key constraint on columns "id" */
  PaymentAccountsPkey = 'PaymentAccounts_pkey',
}

/** input type for inserting data into table "PaymentAccounts" */
export type PaymentAccounts_Insert_Input = {
  accountId: InputMaybe<Scalars['String']>;
  customerId: InputMaybe<Scalars['uuid']>;
  email: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  provider: InputMaybe<Scalars['PaymentProvider']>;
  type: InputMaybe<Scalars['PaymentAccountType']>;
};

/** aggregate max on columns */
export type PaymentAccounts_Max_Fields = {
  __typename?: 'PaymentAccounts_max_fields';
  accountId: Maybe<Scalars['String']>;
  customerId: Maybe<Scalars['uuid']>;
  email: Maybe<Scalars['String']>;
  id: Maybe<Scalars['String']>;
  provider: Maybe<Scalars['PaymentProvider']>;
  type: Maybe<Scalars['PaymentAccountType']>;
};

/** order by max() on columns of table "PaymentAccounts" */
export type PaymentAccounts_Max_Order_By = {
  accountId: InputMaybe<Order_By>;
  customerId: InputMaybe<Order_By>;
  email: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  provider: InputMaybe<Order_By>;
  type: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type PaymentAccounts_Min_Fields = {
  __typename?: 'PaymentAccounts_min_fields';
  accountId: Maybe<Scalars['String']>;
  customerId: Maybe<Scalars['uuid']>;
  email: Maybe<Scalars['String']>;
  id: Maybe<Scalars['String']>;
  provider: Maybe<Scalars['PaymentProvider']>;
  type: Maybe<Scalars['PaymentAccountType']>;
};

/** order by min() on columns of table "PaymentAccounts" */
export type PaymentAccounts_Min_Order_By = {
  accountId: InputMaybe<Order_By>;
  customerId: InputMaybe<Order_By>;
  email: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  provider: InputMaybe<Order_By>;
  type: InputMaybe<Order_By>;
};

/** response of any mutation on the table "PaymentAccounts" */
export type PaymentAccounts_Mutation_Response = {
  __typename?: 'PaymentAccounts_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<PaymentAccounts>;
};

/** on_conflict condition type for table "PaymentAccounts" */
export type PaymentAccounts_On_Conflict = {
  constraint: PaymentAccounts_Constraint;
  update_columns: Array<PaymentAccounts_Update_Column>;
  where: InputMaybe<PaymentAccounts_Bool_Exp>;
};

/** Ordering options when selecting data from "PaymentAccounts". */
export type PaymentAccounts_Order_By = {
  accountId: InputMaybe<Order_By>;
  customerId: InputMaybe<Order_By>;
  email: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  provider: InputMaybe<Order_By>;
  type: InputMaybe<Order_By>;
};

/** primary key columns input for table: PaymentAccounts */
export type PaymentAccounts_Pk_Columns_Input = {
  id: Scalars['String'];
};

/** select columns of table "PaymentAccounts" */
export enum PaymentAccounts_Select_Column {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  CustomerId = 'customerId',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  Provider = 'provider',
  /** column name */
  Type = 'type',
}

/** input type for updating data in table "PaymentAccounts" */
export type PaymentAccounts_Set_Input = {
  accountId: InputMaybe<Scalars['String']>;
  customerId: InputMaybe<Scalars['uuid']>;
  email: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  provider: InputMaybe<Scalars['PaymentProvider']>;
  type: InputMaybe<Scalars['PaymentAccountType']>;
};

/** Streaming cursor of the table "PaymentAccounts" */
export type PaymentAccounts_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: PaymentAccounts_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type PaymentAccounts_Stream_Cursor_Value_Input = {
  accountId: InputMaybe<Scalars['String']>;
  customerId: InputMaybe<Scalars['uuid']>;
  email: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  provider: InputMaybe<Scalars['PaymentProvider']>;
  type: InputMaybe<Scalars['PaymentAccountType']>;
};

/** update columns of table "PaymentAccounts" */
export enum PaymentAccounts_Update_Column {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  CustomerId = 'customerId',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  Provider = 'provider',
  /** column name */
  Type = 'type',
}

export type PaymentAccounts_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<PaymentAccounts_Set_Input>;
  /** filter the rows which have to be updated */
  where: PaymentAccounts_Bool_Exp;
};

/** Boolean expression to compare columns of type "PaymentProvider". All fields are combined with logical 'AND'. */
export type PaymentProvider_Comparison_Exp = {
  _eq: InputMaybe<Scalars['PaymentProvider']>;
  _gt: InputMaybe<Scalars['PaymentProvider']>;
  _gte: InputMaybe<Scalars['PaymentProvider']>;
  _in: InputMaybe<Array<Scalars['PaymentProvider']>>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  _lt: InputMaybe<Scalars['PaymentProvider']>;
  _lte: InputMaybe<Scalars['PaymentProvider']>;
  _neq: InputMaybe<Scalars['PaymentProvider']>;
  _nin: InputMaybe<Array<Scalars['PaymentProvider']>>;
};

/** Boolean expression to compare columns of type "PaymentSolutionCode". All fields are combined with logical 'AND'. */
export type PaymentSolutionCode_Comparison_Exp = {
  _eq: InputMaybe<Scalars['PaymentSolutionCode']>;
  _gt: InputMaybe<Scalars['PaymentSolutionCode']>;
  _gte: InputMaybe<Scalars['PaymentSolutionCode']>;
  _in: InputMaybe<Array<Scalars['PaymentSolutionCode']>>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  _lt: InputMaybe<Scalars['PaymentSolutionCode']>;
  _lte: InputMaybe<Scalars['PaymentSolutionCode']>;
  _neq: InputMaybe<Scalars['PaymentSolutionCode']>;
  _nin: InputMaybe<Array<Scalars['PaymentSolutionCode']>>;
};

/** Boolean expression to compare columns of type "PaymentStatusType". All fields are combined with logical 'AND'. */
export type PaymentStatusType_Comparison_Exp = {
  _eq: InputMaybe<Scalars['PaymentStatusType']>;
  _gt: InputMaybe<Scalars['PaymentStatusType']>;
  _gte: InputMaybe<Scalars['PaymentStatusType']>;
  _in: InputMaybe<Array<Scalars['PaymentStatusType']>>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  _lt: InputMaybe<Scalars['PaymentStatusType']>;
  _lte: InputMaybe<Scalars['PaymentStatusType']>;
  _neq: InputMaybe<Scalars['PaymentStatusType']>;
  _nin: InputMaybe<Array<Scalars['PaymentStatusType']>>;
};

/** aggregated selection of "Payment" */
export type Payment_Aggregate = {
  __typename?: 'Payment_aggregate';
  aggregate: Maybe<Payment_Aggregate_Fields>;
  nodes: Array<Payment>;
};

export type Payment_Aggregate_Bool_Exp = {
  count: InputMaybe<Payment_Aggregate_Bool_Exp_Count>;
};

export type Payment_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<Payment_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<Payment_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "Payment" */
export type Payment_Aggregate_Fields = {
  __typename?: 'Payment_aggregate_fields';
  avg: Maybe<Payment_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Payment_Max_Fields>;
  min: Maybe<Payment_Min_Fields>;
  stddev: Maybe<Payment_Stddev_Fields>;
  stddev_pop: Maybe<Payment_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Payment_Stddev_Samp_Fields>;
  sum: Maybe<Payment_Sum_Fields>;
  var_pop: Maybe<Payment_Var_Pop_Fields>;
  var_samp: Maybe<Payment_Var_Samp_Fields>;
  variance: Maybe<Payment_Variance_Fields>;
};

/** aggregate fields of "Payment" */
export type Payment_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Payment_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "Payment" */
export type Payment_Aggregate_Order_By = {
  avg: InputMaybe<Payment_Avg_Order_By>;
  count: InputMaybe<Order_By>;
  max: InputMaybe<Payment_Max_Order_By>;
  min: InputMaybe<Payment_Min_Order_By>;
  stddev: InputMaybe<Payment_Stddev_Order_By>;
  stddev_pop: InputMaybe<Payment_Stddev_Pop_Order_By>;
  stddev_samp: InputMaybe<Payment_Stddev_Samp_Order_By>;
  sum: InputMaybe<Payment_Sum_Order_By>;
  var_pop: InputMaybe<Payment_Var_Pop_Order_By>;
  var_samp: InputMaybe<Payment_Var_Samp_Order_By>;
  variance: InputMaybe<Payment_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "Payment" */
export type Payment_Arr_Rel_Insert_Input = {
  data: Array<Payment_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<Payment_On_Conflict>;
};

/** aggregate avg on columns */
export type Payment_Avg_Fields = {
  __typename?: 'Payment_avg_fields';
  amountInCents: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "Payment" */
export type Payment_Avg_Order_By = {
  amountInCents: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "Payment". All fields are combined with a logical 'AND'. */
export type Payment_Bool_Exp = {
  Payment_Checkout: InputMaybe<Checkout_Bool_Exp>;
  _and: InputMaybe<Array<Payment_Bool_Exp>>;
  _not: InputMaybe<Payment_Bool_Exp>;
  _or: InputMaybe<Array<Payment_Bool_Exp>>;
  amountInCents: InputMaybe<Int_Comparison_Exp>;
  checkoutId: InputMaybe<String_Comparison_Exp>;
  createdAt: InputMaybe<Timestamp_Comparison_Exp>;
  currency: InputMaybe<String_Comparison_Exp>;
  id: InputMaybe<String_Comparison_Exp>;
  paymentAccountId: InputMaybe<String_Comparison_Exp>;
  paymentSolutionCode: InputMaybe<PaymentSolutionCode_Comparison_Exp>;
  paymentUrl: InputMaybe<String_Comparison_Exp>;
  status: InputMaybe<PaymentStatusType_Comparison_Exp>;
  token: InputMaybe<String_Comparison_Exp>;
  updatedAt: InputMaybe<Timestamp_Comparison_Exp>;
};

/** unique or primary key constraints on table "Payment" */
export enum Payment_Constraint {
  /** unique or primary key constraint on columns "id" */
  PaymentPkey = 'Payment_pkey',
}

/** input type for incrementing numeric columns in table "Payment" */
export type Payment_Inc_Input = {
  amountInCents: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "Payment" */
export type Payment_Insert_Input = {
  Payment_Checkout: InputMaybe<Checkout_Obj_Rel_Insert_Input>;
  amountInCents: InputMaybe<Scalars['Int']>;
  checkoutId: InputMaybe<Scalars['String']>;
  createdAt: InputMaybe<Scalars['timestamp']>;
  currency: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  paymentAccountId: InputMaybe<Scalars['String']>;
  paymentSolutionCode: InputMaybe<Scalars['PaymentSolutionCode']>;
  paymentUrl: InputMaybe<Scalars['String']>;
  status: InputMaybe<Scalars['PaymentStatusType']>;
  token: InputMaybe<Scalars['String']>;
  updatedAt: InputMaybe<Scalars['timestamp']>;
};

/** aggregate max on columns */
export type Payment_Max_Fields = {
  __typename?: 'Payment_max_fields';
  amountInCents: Maybe<Scalars['Int']>;
  checkoutId: Maybe<Scalars['String']>;
  createdAt: Maybe<Scalars['timestamp']>;
  currency: Maybe<Scalars['String']>;
  id: Maybe<Scalars['String']>;
  paymentAccountId: Maybe<Scalars['String']>;
  paymentSolutionCode: Maybe<Scalars['PaymentSolutionCode']>;
  paymentUrl: Maybe<Scalars['String']>;
  status: Maybe<Scalars['PaymentStatusType']>;
  token: Maybe<Scalars['String']>;
  updatedAt: Maybe<Scalars['timestamp']>;
};

/** order by max() on columns of table "Payment" */
export type Payment_Max_Order_By = {
  amountInCents: InputMaybe<Order_By>;
  checkoutId: InputMaybe<Order_By>;
  createdAt: InputMaybe<Order_By>;
  currency: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  paymentAccountId: InputMaybe<Order_By>;
  paymentSolutionCode: InputMaybe<Order_By>;
  paymentUrl: InputMaybe<Order_By>;
  status: InputMaybe<Order_By>;
  token: InputMaybe<Order_By>;
  updatedAt: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Payment_Min_Fields = {
  __typename?: 'Payment_min_fields';
  amountInCents: Maybe<Scalars['Int']>;
  checkoutId: Maybe<Scalars['String']>;
  createdAt: Maybe<Scalars['timestamp']>;
  currency: Maybe<Scalars['String']>;
  id: Maybe<Scalars['String']>;
  paymentAccountId: Maybe<Scalars['String']>;
  paymentSolutionCode: Maybe<Scalars['PaymentSolutionCode']>;
  paymentUrl: Maybe<Scalars['String']>;
  status: Maybe<Scalars['PaymentStatusType']>;
  token: Maybe<Scalars['String']>;
  updatedAt: Maybe<Scalars['timestamp']>;
};

/** order by min() on columns of table "Payment" */
export type Payment_Min_Order_By = {
  amountInCents: InputMaybe<Order_By>;
  checkoutId: InputMaybe<Order_By>;
  createdAt: InputMaybe<Order_By>;
  currency: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  paymentAccountId: InputMaybe<Order_By>;
  paymentSolutionCode: InputMaybe<Order_By>;
  paymentUrl: InputMaybe<Order_By>;
  status: InputMaybe<Order_By>;
  token: InputMaybe<Order_By>;
  updatedAt: InputMaybe<Order_By>;
};

/** response of any mutation on the table "Payment" */
export type Payment_Mutation_Response = {
  __typename?: 'Payment_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Payment>;
};

/** on_conflict condition type for table "Payment" */
export type Payment_On_Conflict = {
  constraint: Payment_Constraint;
  update_columns: Array<Payment_Update_Column>;
  where: InputMaybe<Payment_Bool_Exp>;
};

/** Ordering options when selecting data from "Payment". */
export type Payment_Order_By = {
  Payment_Checkout: InputMaybe<Checkout_Order_By>;
  amountInCents: InputMaybe<Order_By>;
  checkoutId: InputMaybe<Order_By>;
  createdAt: InputMaybe<Order_By>;
  currency: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  paymentAccountId: InputMaybe<Order_By>;
  paymentSolutionCode: InputMaybe<Order_By>;
  paymentUrl: InputMaybe<Order_By>;
  status: InputMaybe<Order_By>;
  token: InputMaybe<Order_By>;
  updatedAt: InputMaybe<Order_By>;
};

/** primary key columns input for table: Payment */
export type Payment_Pk_Columns_Input = {
  id: Scalars['String'];
};

/** select columns of table "Payment" */
export enum Payment_Select_Column {
  /** column name */
  AmountInCents = 'amountInCents',
  /** column name */
  CheckoutId = 'checkoutId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Currency = 'currency',
  /** column name */
  Id = 'id',
  /** column name */
  PaymentAccountId = 'paymentAccountId',
  /** column name */
  PaymentSolutionCode = 'paymentSolutionCode',
  /** column name */
  PaymentUrl = 'paymentUrl',
  /** column name */
  Status = 'status',
  /** column name */
  Token = 'token',
  /** column name */
  UpdatedAt = 'updatedAt',
}

/** input type for updating data in table "Payment" */
export type Payment_Set_Input = {
  amountInCents: InputMaybe<Scalars['Int']>;
  checkoutId: InputMaybe<Scalars['String']>;
  createdAt: InputMaybe<Scalars['timestamp']>;
  currency: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  paymentAccountId: InputMaybe<Scalars['String']>;
  paymentSolutionCode: InputMaybe<Scalars['PaymentSolutionCode']>;
  paymentUrl: InputMaybe<Scalars['String']>;
  status: InputMaybe<Scalars['PaymentStatusType']>;
  token: InputMaybe<Scalars['String']>;
  updatedAt: InputMaybe<Scalars['timestamp']>;
};

/** aggregate stddev on columns */
export type Payment_Stddev_Fields = {
  __typename?: 'Payment_stddev_fields';
  amountInCents: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "Payment" */
export type Payment_Stddev_Order_By = {
  amountInCents: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Payment_Stddev_Pop_Fields = {
  __typename?: 'Payment_stddev_pop_fields';
  amountInCents: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "Payment" */
export type Payment_Stddev_Pop_Order_By = {
  amountInCents: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Payment_Stddev_Samp_Fields = {
  __typename?: 'Payment_stddev_samp_fields';
  amountInCents: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "Payment" */
export type Payment_Stddev_Samp_Order_By = {
  amountInCents: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "Payment" */
export type Payment_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Payment_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Payment_Stream_Cursor_Value_Input = {
  amountInCents: InputMaybe<Scalars['Int']>;
  checkoutId: InputMaybe<Scalars['String']>;
  createdAt: InputMaybe<Scalars['timestamp']>;
  currency: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  paymentAccountId: InputMaybe<Scalars['String']>;
  paymentSolutionCode: InputMaybe<Scalars['PaymentSolutionCode']>;
  paymentUrl: InputMaybe<Scalars['String']>;
  status: InputMaybe<Scalars['PaymentStatusType']>;
  token: InputMaybe<Scalars['String']>;
  updatedAt: InputMaybe<Scalars['timestamp']>;
};

/** aggregate sum on columns */
export type Payment_Sum_Fields = {
  __typename?: 'Payment_sum_fields';
  amountInCents: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "Payment" */
export type Payment_Sum_Order_By = {
  amountInCents: InputMaybe<Order_By>;
};

/** update columns of table "Payment" */
export enum Payment_Update_Column {
  /** column name */
  AmountInCents = 'amountInCents',
  /** column name */
  CheckoutId = 'checkoutId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Currency = 'currency',
  /** column name */
  Id = 'id',
  /** column name */
  PaymentAccountId = 'paymentAccountId',
  /** column name */
  PaymentSolutionCode = 'paymentSolutionCode',
  /** column name */
  PaymentUrl = 'paymentUrl',
  /** column name */
  Status = 'status',
  /** column name */
  Token = 'token',
  /** column name */
  UpdatedAt = 'updatedAt',
}

export type Payment_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Payment_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Payment_Set_Input>;
  /** filter the rows which have to be updated */
  where: Payment_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Payment_Var_Pop_Fields = {
  __typename?: 'Payment_var_pop_fields';
  amountInCents: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "Payment" */
export type Payment_Var_Pop_Order_By = {
  amountInCents: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Payment_Var_Samp_Fields = {
  __typename?: 'Payment_var_samp_fields';
  amountInCents: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "Payment" */
export type Payment_Var_Samp_Order_By = {
  amountInCents: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Payment_Variance_Fields = {
  __typename?: 'Payment_variance_fields';
  amountInCents: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "Payment" */
export type Payment_Variance_Order_By = {
  amountInCents: InputMaybe<Order_By>;
};

/** columns and relationships of "Payout" */
export type Payout = {
  __typename?: 'Payout';
  amountInCents: Scalars['Int'];
  createdAt: Scalars['timestamp'];
  currency: Scalars['Currency'];
  destinationAccountId: Scalars['String'];
  id: Scalars['String'];
  orderLineId: Scalars['String'];
};

/** aggregated selection of "Payout" */
export type Payout_Aggregate = {
  __typename?: 'Payout_aggregate';
  aggregate: Maybe<Payout_Aggregate_Fields>;
  nodes: Array<Payout>;
};

export type Payout_Aggregate_Bool_Exp = {
  count: InputMaybe<Payout_Aggregate_Bool_Exp_Count>;
};

export type Payout_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<Payout_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<Payout_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "Payout" */
export type Payout_Aggregate_Fields = {
  __typename?: 'Payout_aggregate_fields';
  avg: Maybe<Payout_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Payout_Max_Fields>;
  min: Maybe<Payout_Min_Fields>;
  stddev: Maybe<Payout_Stddev_Fields>;
  stddev_pop: Maybe<Payout_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Payout_Stddev_Samp_Fields>;
  sum: Maybe<Payout_Sum_Fields>;
  var_pop: Maybe<Payout_Var_Pop_Fields>;
  var_samp: Maybe<Payout_Var_Samp_Fields>;
  variance: Maybe<Payout_Variance_Fields>;
};

/** aggregate fields of "Payout" */
export type Payout_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Payout_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "Payout" */
export type Payout_Aggregate_Order_By = {
  avg: InputMaybe<Payout_Avg_Order_By>;
  count: InputMaybe<Order_By>;
  max: InputMaybe<Payout_Max_Order_By>;
  min: InputMaybe<Payout_Min_Order_By>;
  stddev: InputMaybe<Payout_Stddev_Order_By>;
  stddev_pop: InputMaybe<Payout_Stddev_Pop_Order_By>;
  stddev_samp: InputMaybe<Payout_Stddev_Samp_Order_By>;
  sum: InputMaybe<Payout_Sum_Order_By>;
  var_pop: InputMaybe<Payout_Var_Pop_Order_By>;
  var_samp: InputMaybe<Payout_Var_Samp_Order_By>;
  variance: InputMaybe<Payout_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "Payout" */
export type Payout_Arr_Rel_Insert_Input = {
  data: Array<Payout_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<Payout_On_Conflict>;
};

/** aggregate avg on columns */
export type Payout_Avg_Fields = {
  __typename?: 'Payout_avg_fields';
  amountInCents: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "Payout" */
export type Payout_Avg_Order_By = {
  amountInCents: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "Payout". All fields are combined with a logical 'AND'. */
export type Payout_Bool_Exp = {
  _and: InputMaybe<Array<Payout_Bool_Exp>>;
  _not: InputMaybe<Payout_Bool_Exp>;
  _or: InputMaybe<Array<Payout_Bool_Exp>>;
  amountInCents: InputMaybe<Int_Comparison_Exp>;
  createdAt: InputMaybe<Timestamp_Comparison_Exp>;
  currency: InputMaybe<Currency_Comparison_Exp>;
  destinationAccountId: InputMaybe<String_Comparison_Exp>;
  id: InputMaybe<String_Comparison_Exp>;
  orderLineId: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "Payout" */
export enum Payout_Constraint {
  /** unique or primary key constraint on columns "id" */
  PayoutPkey = 'Payout_pkey',
}

/** input type for incrementing numeric columns in table "Payout" */
export type Payout_Inc_Input = {
  amountInCents: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "Payout" */
export type Payout_Insert_Input = {
  amountInCents: InputMaybe<Scalars['Int']>;
  createdAt: InputMaybe<Scalars['timestamp']>;
  currency: InputMaybe<Scalars['Currency']>;
  destinationAccountId: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  orderLineId: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Payout_Max_Fields = {
  __typename?: 'Payout_max_fields';
  amountInCents: Maybe<Scalars['Int']>;
  createdAt: Maybe<Scalars['timestamp']>;
  currency: Maybe<Scalars['Currency']>;
  destinationAccountId: Maybe<Scalars['String']>;
  id: Maybe<Scalars['String']>;
  orderLineId: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "Payout" */
export type Payout_Max_Order_By = {
  amountInCents: InputMaybe<Order_By>;
  createdAt: InputMaybe<Order_By>;
  currency: InputMaybe<Order_By>;
  destinationAccountId: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  orderLineId: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Payout_Min_Fields = {
  __typename?: 'Payout_min_fields';
  amountInCents: Maybe<Scalars['Int']>;
  createdAt: Maybe<Scalars['timestamp']>;
  currency: Maybe<Scalars['Currency']>;
  destinationAccountId: Maybe<Scalars['String']>;
  id: Maybe<Scalars['String']>;
  orderLineId: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "Payout" */
export type Payout_Min_Order_By = {
  amountInCents: InputMaybe<Order_By>;
  createdAt: InputMaybe<Order_By>;
  currency: InputMaybe<Order_By>;
  destinationAccountId: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  orderLineId: InputMaybe<Order_By>;
};

/** response of any mutation on the table "Payout" */
export type Payout_Mutation_Response = {
  __typename?: 'Payout_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Payout>;
};

/** on_conflict condition type for table "Payout" */
export type Payout_On_Conflict = {
  constraint: Payout_Constraint;
  update_columns: Array<Payout_Update_Column>;
  where: InputMaybe<Payout_Bool_Exp>;
};

/** Ordering options when selecting data from "Payout". */
export type Payout_Order_By = {
  amountInCents: InputMaybe<Order_By>;
  createdAt: InputMaybe<Order_By>;
  currency: InputMaybe<Order_By>;
  destinationAccountId: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  orderLineId: InputMaybe<Order_By>;
};

/** primary key columns input for table: Payout */
export type Payout_Pk_Columns_Input = {
  id: Scalars['String'];
};

/** select columns of table "Payout" */
export enum Payout_Select_Column {
  /** column name */
  AmountInCents = 'amountInCents',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Currency = 'currency',
  /** column name */
  DestinationAccountId = 'destinationAccountId',
  /** column name */
  Id = 'id',
  /** column name */
  OrderLineId = 'orderLineId',
}

/** input type for updating data in table "Payout" */
export type Payout_Set_Input = {
  amountInCents: InputMaybe<Scalars['Int']>;
  createdAt: InputMaybe<Scalars['timestamp']>;
  currency: InputMaybe<Scalars['Currency']>;
  destinationAccountId: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  orderLineId: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Payout_Stddev_Fields = {
  __typename?: 'Payout_stddev_fields';
  amountInCents: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "Payout" */
export type Payout_Stddev_Order_By = {
  amountInCents: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Payout_Stddev_Pop_Fields = {
  __typename?: 'Payout_stddev_pop_fields';
  amountInCents: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "Payout" */
export type Payout_Stddev_Pop_Order_By = {
  amountInCents: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Payout_Stddev_Samp_Fields = {
  __typename?: 'Payout_stddev_samp_fields';
  amountInCents: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "Payout" */
export type Payout_Stddev_Samp_Order_By = {
  amountInCents: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "Payout" */
export type Payout_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Payout_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Payout_Stream_Cursor_Value_Input = {
  amountInCents: InputMaybe<Scalars['Int']>;
  createdAt: InputMaybe<Scalars['timestamp']>;
  currency: InputMaybe<Scalars['Currency']>;
  destinationAccountId: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  orderLineId: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type Payout_Sum_Fields = {
  __typename?: 'Payout_sum_fields';
  amountInCents: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "Payout" */
export type Payout_Sum_Order_By = {
  amountInCents: InputMaybe<Order_By>;
};

/** update columns of table "Payout" */
export enum Payout_Update_Column {
  /** column name */
  AmountInCents = 'amountInCents',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Currency = 'currency',
  /** column name */
  DestinationAccountId = 'destinationAccountId',
  /** column name */
  Id = 'id',
  /** column name */
  OrderLineId = 'orderLineId',
}

export type Payout_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Payout_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Payout_Set_Input>;
  /** filter the rows which have to be updated */
  where: Payout_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Payout_Var_Pop_Fields = {
  __typename?: 'Payout_var_pop_fields';
  amountInCents: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "Payout" */
export type Payout_Var_Pop_Order_By = {
  amountInCents: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Payout_Var_Samp_Fields = {
  __typename?: 'Payout_var_samp_fields';
  amountInCents: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "Payout" */
export type Payout_Var_Samp_Order_By = {
  amountInCents: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Payout_Variance_Fields = {
  __typename?: 'Payout_variance_fields';
  amountInCents: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "Payout" */
export type Payout_Variance_Order_By = {
  amountInCents: InputMaybe<Order_By>;
};

/** columns and relationships of "PriceOffer" */
export type PriceOffer = {
  __typename?: 'PriceOffer';
  /** An object relationship */
  buyer: Customer;
  buyerId: Scalars['uuid'];
  createdAt: Scalars['timestamp'];
  discountCode: Maybe<Scalars['String']>;
  id: Scalars['String'];
  initiatedBy: Scalars['uuid'];
  /** An object relationship */
  initiator: Customer;
  newPriceInCents: Scalars['bigint'];
  /** An object relationship */
  product: Product;
  productId: Scalars['String'];
  /** An object relationship */
  productVariant: Maybe<ProductVariant>;
  productVariantId: Maybe<Scalars['String']>;
  status: Scalars['PriceOfferStatus'];
};

/** Boolean expression to compare columns of type "PriceOfferStatus". All fields are combined with logical 'AND'. */
export type PriceOfferStatus_Comparison_Exp = {
  _eq: InputMaybe<Scalars['PriceOfferStatus']>;
  _gt: InputMaybe<Scalars['PriceOfferStatus']>;
  _gte: InputMaybe<Scalars['PriceOfferStatus']>;
  _in: InputMaybe<Array<Scalars['PriceOfferStatus']>>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  _lt: InputMaybe<Scalars['PriceOfferStatus']>;
  _lte: InputMaybe<Scalars['PriceOfferStatus']>;
  _neq: InputMaybe<Scalars['PriceOfferStatus']>;
  _nin: InputMaybe<Array<Scalars['PriceOfferStatus']>>;
};

/** aggregated selection of "PriceOffer" */
export type PriceOffer_Aggregate = {
  __typename?: 'PriceOffer_aggregate';
  aggregate: Maybe<PriceOffer_Aggregate_Fields>;
  nodes: Array<PriceOffer>;
};

/** aggregate fields of "PriceOffer" */
export type PriceOffer_Aggregate_Fields = {
  __typename?: 'PriceOffer_aggregate_fields';
  avg: Maybe<PriceOffer_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<PriceOffer_Max_Fields>;
  min: Maybe<PriceOffer_Min_Fields>;
  stddev: Maybe<PriceOffer_Stddev_Fields>;
  stddev_pop: Maybe<PriceOffer_Stddev_Pop_Fields>;
  stddev_samp: Maybe<PriceOffer_Stddev_Samp_Fields>;
  sum: Maybe<PriceOffer_Sum_Fields>;
  var_pop: Maybe<PriceOffer_Var_Pop_Fields>;
  var_samp: Maybe<PriceOffer_Var_Samp_Fields>;
  variance: Maybe<PriceOffer_Variance_Fields>;
};

/** aggregate fields of "PriceOffer" */
export type PriceOffer_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<PriceOffer_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type PriceOffer_Avg_Fields = {
  __typename?: 'PriceOffer_avg_fields';
  newPriceInCents: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "PriceOffer". All fields are combined with a logical 'AND'. */
export type PriceOffer_Bool_Exp = {
  _and: InputMaybe<Array<PriceOffer_Bool_Exp>>;
  _not: InputMaybe<PriceOffer_Bool_Exp>;
  _or: InputMaybe<Array<PriceOffer_Bool_Exp>>;
  buyer: InputMaybe<Customer_Bool_Exp>;
  buyerId: InputMaybe<Uuid_Comparison_Exp>;
  createdAt: InputMaybe<Timestamp_Comparison_Exp>;
  discountCode: InputMaybe<String_Comparison_Exp>;
  id: InputMaybe<String_Comparison_Exp>;
  initiatedBy: InputMaybe<Uuid_Comparison_Exp>;
  initiator: InputMaybe<Customer_Bool_Exp>;
  newPriceInCents: InputMaybe<Bigint_Comparison_Exp>;
  product: InputMaybe<Product_Bool_Exp>;
  productId: InputMaybe<String_Comparison_Exp>;
  productVariant: InputMaybe<ProductVariant_Bool_Exp>;
  productVariantId: InputMaybe<String_Comparison_Exp>;
  status: InputMaybe<PriceOfferStatus_Comparison_Exp>;
};

/** unique or primary key constraints on table "PriceOffer" */
export enum PriceOffer_Constraint {
  /** unique or primary key constraint on columns "id" */
  PriceOfferPkey = 'PriceOffer_pkey',
}

/** input type for incrementing numeric columns in table "PriceOffer" */
export type PriceOffer_Inc_Input = {
  newPriceInCents: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "PriceOffer" */
export type PriceOffer_Insert_Input = {
  buyer: InputMaybe<Customer_Obj_Rel_Insert_Input>;
  buyerId: InputMaybe<Scalars['uuid']>;
  createdAt: InputMaybe<Scalars['timestamp']>;
  discountCode: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  initiatedBy: InputMaybe<Scalars['uuid']>;
  initiator: InputMaybe<Customer_Obj_Rel_Insert_Input>;
  newPriceInCents: InputMaybe<Scalars['bigint']>;
  product: InputMaybe<Product_Obj_Rel_Insert_Input>;
  productId: InputMaybe<Scalars['String']>;
  productVariant: InputMaybe<ProductVariant_Obj_Rel_Insert_Input>;
  productVariantId: InputMaybe<Scalars['String']>;
  status: InputMaybe<Scalars['PriceOfferStatus']>;
};

/** aggregate max on columns */
export type PriceOffer_Max_Fields = {
  __typename?: 'PriceOffer_max_fields';
  buyerId: Maybe<Scalars['uuid']>;
  createdAt: Maybe<Scalars['timestamp']>;
  discountCode: Maybe<Scalars['String']>;
  id: Maybe<Scalars['String']>;
  initiatedBy: Maybe<Scalars['uuid']>;
  newPriceInCents: Maybe<Scalars['bigint']>;
  productId: Maybe<Scalars['String']>;
  productVariantId: Maybe<Scalars['String']>;
  status: Maybe<Scalars['PriceOfferStatus']>;
};

/** aggregate min on columns */
export type PriceOffer_Min_Fields = {
  __typename?: 'PriceOffer_min_fields';
  buyerId: Maybe<Scalars['uuid']>;
  createdAt: Maybe<Scalars['timestamp']>;
  discountCode: Maybe<Scalars['String']>;
  id: Maybe<Scalars['String']>;
  initiatedBy: Maybe<Scalars['uuid']>;
  newPriceInCents: Maybe<Scalars['bigint']>;
  productId: Maybe<Scalars['String']>;
  productVariantId: Maybe<Scalars['String']>;
  status: Maybe<Scalars['PriceOfferStatus']>;
};

/** response of any mutation on the table "PriceOffer" */
export type PriceOffer_Mutation_Response = {
  __typename?: 'PriceOffer_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<PriceOffer>;
};

/** on_conflict condition type for table "PriceOffer" */
export type PriceOffer_On_Conflict = {
  constraint: PriceOffer_Constraint;
  update_columns: Array<PriceOffer_Update_Column>;
  where: InputMaybe<PriceOffer_Bool_Exp>;
};

/** Ordering options when selecting data from "PriceOffer". */
export type PriceOffer_Order_By = {
  buyer: InputMaybe<Customer_Order_By>;
  buyerId: InputMaybe<Order_By>;
  createdAt: InputMaybe<Order_By>;
  discountCode: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  initiatedBy: InputMaybe<Order_By>;
  initiator: InputMaybe<Customer_Order_By>;
  newPriceInCents: InputMaybe<Order_By>;
  product: InputMaybe<Product_Order_By>;
  productId: InputMaybe<Order_By>;
  productVariant: InputMaybe<ProductVariant_Order_By>;
  productVariantId: InputMaybe<Order_By>;
  status: InputMaybe<Order_By>;
};

/** primary key columns input for table: PriceOffer */
export type PriceOffer_Pk_Columns_Input = {
  id: Scalars['String'];
};

/** select columns of table "PriceOffer" */
export enum PriceOffer_Select_Column {
  /** column name */
  BuyerId = 'buyerId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DiscountCode = 'discountCode',
  /** column name */
  Id = 'id',
  /** column name */
  InitiatedBy = 'initiatedBy',
  /** column name */
  NewPriceInCents = 'newPriceInCents',
  /** column name */
  ProductId = 'productId',
  /** column name */
  ProductVariantId = 'productVariantId',
  /** column name */
  Status = 'status',
}

/** input type for updating data in table "PriceOffer" */
export type PriceOffer_Set_Input = {
  buyerId: InputMaybe<Scalars['uuid']>;
  createdAt: InputMaybe<Scalars['timestamp']>;
  discountCode: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  initiatedBy: InputMaybe<Scalars['uuid']>;
  newPriceInCents: InputMaybe<Scalars['bigint']>;
  productId: InputMaybe<Scalars['String']>;
  productVariantId: InputMaybe<Scalars['String']>;
  status: InputMaybe<Scalars['PriceOfferStatus']>;
};

/** aggregate stddev on columns */
export type PriceOffer_Stddev_Fields = {
  __typename?: 'PriceOffer_stddev_fields';
  newPriceInCents: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type PriceOffer_Stddev_Pop_Fields = {
  __typename?: 'PriceOffer_stddev_pop_fields';
  newPriceInCents: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type PriceOffer_Stddev_Samp_Fields = {
  __typename?: 'PriceOffer_stddev_samp_fields';
  newPriceInCents: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "PriceOffer" */
export type PriceOffer_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: PriceOffer_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type PriceOffer_Stream_Cursor_Value_Input = {
  buyerId: InputMaybe<Scalars['uuid']>;
  createdAt: InputMaybe<Scalars['timestamp']>;
  discountCode: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  initiatedBy: InputMaybe<Scalars['uuid']>;
  newPriceInCents: InputMaybe<Scalars['bigint']>;
  productId: InputMaybe<Scalars['String']>;
  productVariantId: InputMaybe<Scalars['String']>;
  status: InputMaybe<Scalars['PriceOfferStatus']>;
};

/** aggregate sum on columns */
export type PriceOffer_Sum_Fields = {
  __typename?: 'PriceOffer_sum_fields';
  newPriceInCents: Maybe<Scalars['bigint']>;
};

/** update columns of table "PriceOffer" */
export enum PriceOffer_Update_Column {
  /** column name */
  BuyerId = 'buyerId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DiscountCode = 'discountCode',
  /** column name */
  Id = 'id',
  /** column name */
  InitiatedBy = 'initiatedBy',
  /** column name */
  NewPriceInCents = 'newPriceInCents',
  /** column name */
  ProductId = 'productId',
  /** column name */
  ProductVariantId = 'productVariantId',
  /** column name */
  Status = 'status',
}

export type PriceOffer_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<PriceOffer_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<PriceOffer_Set_Input>;
  /** filter the rows which have to be updated */
  where: PriceOffer_Bool_Exp;
};

/** aggregate var_pop on columns */
export type PriceOffer_Var_Pop_Fields = {
  __typename?: 'PriceOffer_var_pop_fields';
  newPriceInCents: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type PriceOffer_Var_Samp_Fields = {
  __typename?: 'PriceOffer_var_samp_fields';
  newPriceInCents: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type PriceOffer_Variance_Fields = {
  __typename?: 'PriceOffer_variance_fields';
  newPriceInCents: Maybe<Scalars['Float']>;
};

/** columns and relationships of "Product" */
export type Product = {
  __typename?: 'Product';
  EANCode: Maybe<Scalars['String']>;
  GTINCode: Maybe<Scalars['String']>;
  /** An object relationship */
  Vendor: Customer;
  createdAt: Scalars['timestamp'];
  handle: Maybe<Scalars['String']>;
  id: Scalars['String'];
  manualNotation: Maybe<Scalars['ProductNotation']>;
  productType: Maybe<Scalars['String']>;
  shopifyId: Scalars['bigint'];
  source: Maybe<Scalars['String']>;
  sourceUrl: Maybe<Scalars['String']>;
  status: Scalars['ProductStatus'];
  /** An object relationship */
  storeExposedProduct: Maybe<Dbt_Store_Exposed_Product>;
  /** An array relationship */
  variants: Array<ProductVariant>;
  /** An aggregate relationship */
  variants_aggregate: ProductVariant_Aggregate;
  vendorId: Scalars['uuid'];
};

/** columns and relationships of "Product" */
export type ProductVariantsArgs = {
  distinct_on: InputMaybe<Array<ProductVariant_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<ProductVariant_Order_By>>;
  where: InputMaybe<ProductVariant_Bool_Exp>;
};

/** columns and relationships of "Product" */
export type ProductVariants_AggregateArgs = {
  distinct_on: InputMaybe<Array<ProductVariant_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<ProductVariant_Order_By>>;
  where: InputMaybe<ProductVariant_Bool_Exp>;
};

/** Boolean expression to compare columns of type "ProductNotation". All fields are combined with logical 'AND'. */
export type ProductNotation_Comparison_Exp = {
  _eq: InputMaybe<Scalars['ProductNotation']>;
  _gt: InputMaybe<Scalars['ProductNotation']>;
  _gte: InputMaybe<Scalars['ProductNotation']>;
  _in: InputMaybe<Array<Scalars['ProductNotation']>>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  _lt: InputMaybe<Scalars['ProductNotation']>;
  _lte: InputMaybe<Scalars['ProductNotation']>;
  _neq: InputMaybe<Scalars['ProductNotation']>;
  _nin: InputMaybe<Array<Scalars['ProductNotation']>>;
};

/** Boolean expression to compare columns of type "ProductStatus". All fields are combined with logical 'AND'. */
export type ProductStatus_Comparison_Exp = {
  _eq: InputMaybe<Scalars['ProductStatus']>;
  _gt: InputMaybe<Scalars['ProductStatus']>;
  _gte: InputMaybe<Scalars['ProductStatus']>;
  _in: InputMaybe<Array<Scalars['ProductStatus']>>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  _lt: InputMaybe<Scalars['ProductStatus']>;
  _lte: InputMaybe<Scalars['ProductStatus']>;
  _neq: InputMaybe<Scalars['ProductStatus']>;
  _nin: InputMaybe<Array<Scalars['ProductStatus']>>;
};

/** columns and relationships of "ProductVariant" */
export type ProductVariant = {
  __typename?: 'ProductVariant';
  condition: Maybe<Scalars['Condition']>;
  createdAt: Scalars['timestamp'];
  id: Scalars['String'];
  priceInCents: Maybe<Scalars['bigint']>;
  /** An object relationship */
  product: Product;
  productId: Scalars['String'];
  quantity: Scalars['Int'];
  shopifyId: Scalars['bigint'];
  /** An object relationship */
  storeExposedVariant: Maybe<Dbt_Store_Exposed_Product_Variant>;
};

/** aggregated selection of "ProductVariant" */
export type ProductVariant_Aggregate = {
  __typename?: 'ProductVariant_aggregate';
  aggregate: Maybe<ProductVariant_Aggregate_Fields>;
  nodes: Array<ProductVariant>;
};

export type ProductVariant_Aggregate_Bool_Exp = {
  count: InputMaybe<ProductVariant_Aggregate_Bool_Exp_Count>;
};

export type ProductVariant_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<ProductVariant_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<ProductVariant_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "ProductVariant" */
export type ProductVariant_Aggregate_Fields = {
  __typename?: 'ProductVariant_aggregate_fields';
  avg: Maybe<ProductVariant_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<ProductVariant_Max_Fields>;
  min: Maybe<ProductVariant_Min_Fields>;
  stddev: Maybe<ProductVariant_Stddev_Fields>;
  stddev_pop: Maybe<ProductVariant_Stddev_Pop_Fields>;
  stddev_samp: Maybe<ProductVariant_Stddev_Samp_Fields>;
  sum: Maybe<ProductVariant_Sum_Fields>;
  var_pop: Maybe<ProductVariant_Var_Pop_Fields>;
  var_samp: Maybe<ProductVariant_Var_Samp_Fields>;
  variance: Maybe<ProductVariant_Variance_Fields>;
};

/** aggregate fields of "ProductVariant" */
export type ProductVariant_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<ProductVariant_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "ProductVariant" */
export type ProductVariant_Aggregate_Order_By = {
  avg: InputMaybe<ProductVariant_Avg_Order_By>;
  count: InputMaybe<Order_By>;
  max: InputMaybe<ProductVariant_Max_Order_By>;
  min: InputMaybe<ProductVariant_Min_Order_By>;
  stddev: InputMaybe<ProductVariant_Stddev_Order_By>;
  stddev_pop: InputMaybe<ProductVariant_Stddev_Pop_Order_By>;
  stddev_samp: InputMaybe<ProductVariant_Stddev_Samp_Order_By>;
  sum: InputMaybe<ProductVariant_Sum_Order_By>;
  var_pop: InputMaybe<ProductVariant_Var_Pop_Order_By>;
  var_samp: InputMaybe<ProductVariant_Var_Samp_Order_By>;
  variance: InputMaybe<ProductVariant_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "ProductVariant" */
export type ProductVariant_Arr_Rel_Insert_Input = {
  data: Array<ProductVariant_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<ProductVariant_On_Conflict>;
};

/** aggregate avg on columns */
export type ProductVariant_Avg_Fields = {
  __typename?: 'ProductVariant_avg_fields';
  priceInCents: Maybe<Scalars['Float']>;
  quantity: Maybe<Scalars['Float']>;
  shopifyId: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "ProductVariant" */
export type ProductVariant_Avg_Order_By = {
  priceInCents: InputMaybe<Order_By>;
  quantity: InputMaybe<Order_By>;
  shopifyId: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "ProductVariant". All fields are combined with a logical 'AND'. */
export type ProductVariant_Bool_Exp = {
  _and: InputMaybe<Array<ProductVariant_Bool_Exp>>;
  _not: InputMaybe<ProductVariant_Bool_Exp>;
  _or: InputMaybe<Array<ProductVariant_Bool_Exp>>;
  condition: InputMaybe<Condition_Comparison_Exp>;
  createdAt: InputMaybe<Timestamp_Comparison_Exp>;
  id: InputMaybe<String_Comparison_Exp>;
  priceInCents: InputMaybe<Bigint_Comparison_Exp>;
  product: InputMaybe<Product_Bool_Exp>;
  productId: InputMaybe<String_Comparison_Exp>;
  quantity: InputMaybe<Int_Comparison_Exp>;
  shopifyId: InputMaybe<Bigint_Comparison_Exp>;
  storeExposedVariant: InputMaybe<Dbt_Store_Exposed_Product_Variant_Bool_Exp>;
};

/** unique or primary key constraints on table "ProductVariant" */
export enum ProductVariant_Constraint {
  /** unique or primary key constraint on columns "id" */
  ProductVariantPkey = 'ProductVariant_pkey',
  /** unique or primary key constraint on columns "shopifyId" */
  ProductVariantShopifyIdKey = 'ProductVariant_shopifyId_key',
}

/** input type for incrementing numeric columns in table "ProductVariant" */
export type ProductVariant_Inc_Input = {
  priceInCents: InputMaybe<Scalars['bigint']>;
  quantity: InputMaybe<Scalars['Int']>;
  shopifyId: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "ProductVariant" */
export type ProductVariant_Insert_Input = {
  condition: InputMaybe<Scalars['Condition']>;
  createdAt: InputMaybe<Scalars['timestamp']>;
  id: InputMaybe<Scalars['String']>;
  priceInCents: InputMaybe<Scalars['bigint']>;
  product: InputMaybe<Product_Obj_Rel_Insert_Input>;
  productId: InputMaybe<Scalars['String']>;
  quantity: InputMaybe<Scalars['Int']>;
  shopifyId: InputMaybe<Scalars['bigint']>;
  storeExposedVariant: InputMaybe<Dbt_Store_Exposed_Product_Variant_Obj_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type ProductVariant_Max_Fields = {
  __typename?: 'ProductVariant_max_fields';
  condition: Maybe<Scalars['Condition']>;
  createdAt: Maybe<Scalars['timestamp']>;
  id: Maybe<Scalars['String']>;
  priceInCents: Maybe<Scalars['bigint']>;
  productId: Maybe<Scalars['String']>;
  quantity: Maybe<Scalars['Int']>;
  shopifyId: Maybe<Scalars['bigint']>;
};

/** order by max() on columns of table "ProductVariant" */
export type ProductVariant_Max_Order_By = {
  condition: InputMaybe<Order_By>;
  createdAt: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  priceInCents: InputMaybe<Order_By>;
  productId: InputMaybe<Order_By>;
  quantity: InputMaybe<Order_By>;
  shopifyId: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type ProductVariant_Min_Fields = {
  __typename?: 'ProductVariant_min_fields';
  condition: Maybe<Scalars['Condition']>;
  createdAt: Maybe<Scalars['timestamp']>;
  id: Maybe<Scalars['String']>;
  priceInCents: Maybe<Scalars['bigint']>;
  productId: Maybe<Scalars['String']>;
  quantity: Maybe<Scalars['Int']>;
  shopifyId: Maybe<Scalars['bigint']>;
};

/** order by min() on columns of table "ProductVariant" */
export type ProductVariant_Min_Order_By = {
  condition: InputMaybe<Order_By>;
  createdAt: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  priceInCents: InputMaybe<Order_By>;
  productId: InputMaybe<Order_By>;
  quantity: InputMaybe<Order_By>;
  shopifyId: InputMaybe<Order_By>;
};

/** response of any mutation on the table "ProductVariant" */
export type ProductVariant_Mutation_Response = {
  __typename?: 'ProductVariant_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<ProductVariant>;
};

/** input type for inserting object relation for remote table "ProductVariant" */
export type ProductVariant_Obj_Rel_Insert_Input = {
  data: ProductVariant_Insert_Input;
  /** upsert condition */
  on_conflict: InputMaybe<ProductVariant_On_Conflict>;
};

/** on_conflict condition type for table "ProductVariant" */
export type ProductVariant_On_Conflict = {
  constraint: ProductVariant_Constraint;
  update_columns: Array<ProductVariant_Update_Column>;
  where: InputMaybe<ProductVariant_Bool_Exp>;
};

/** Ordering options when selecting data from "ProductVariant". */
export type ProductVariant_Order_By = {
  condition: InputMaybe<Order_By>;
  createdAt: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  priceInCents: InputMaybe<Order_By>;
  product: InputMaybe<Product_Order_By>;
  productId: InputMaybe<Order_By>;
  quantity: InputMaybe<Order_By>;
  shopifyId: InputMaybe<Order_By>;
  storeExposedVariant: InputMaybe<Dbt_Store_Exposed_Product_Variant_Order_By>;
};

/** primary key columns input for table: ProductVariant */
export type ProductVariant_Pk_Columns_Input = {
  id: Scalars['String'];
};

/** select columns of table "ProductVariant" */
export enum ProductVariant_Select_Column {
  /** column name */
  Condition = 'condition',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  PriceInCents = 'priceInCents',
  /** column name */
  ProductId = 'productId',
  /** column name */
  Quantity = 'quantity',
  /** column name */
  ShopifyId = 'shopifyId',
}

/** input type for updating data in table "ProductVariant" */
export type ProductVariant_Set_Input = {
  condition: InputMaybe<Scalars['Condition']>;
  createdAt: InputMaybe<Scalars['timestamp']>;
  id: InputMaybe<Scalars['String']>;
  priceInCents: InputMaybe<Scalars['bigint']>;
  productId: InputMaybe<Scalars['String']>;
  quantity: InputMaybe<Scalars['Int']>;
  shopifyId: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type ProductVariant_Stddev_Fields = {
  __typename?: 'ProductVariant_stddev_fields';
  priceInCents: Maybe<Scalars['Float']>;
  quantity: Maybe<Scalars['Float']>;
  shopifyId: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "ProductVariant" */
export type ProductVariant_Stddev_Order_By = {
  priceInCents: InputMaybe<Order_By>;
  quantity: InputMaybe<Order_By>;
  shopifyId: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type ProductVariant_Stddev_Pop_Fields = {
  __typename?: 'ProductVariant_stddev_pop_fields';
  priceInCents: Maybe<Scalars['Float']>;
  quantity: Maybe<Scalars['Float']>;
  shopifyId: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "ProductVariant" */
export type ProductVariant_Stddev_Pop_Order_By = {
  priceInCents: InputMaybe<Order_By>;
  quantity: InputMaybe<Order_By>;
  shopifyId: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type ProductVariant_Stddev_Samp_Fields = {
  __typename?: 'ProductVariant_stddev_samp_fields';
  priceInCents: Maybe<Scalars['Float']>;
  quantity: Maybe<Scalars['Float']>;
  shopifyId: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "ProductVariant" */
export type ProductVariant_Stddev_Samp_Order_By = {
  priceInCents: InputMaybe<Order_By>;
  quantity: InputMaybe<Order_By>;
  shopifyId: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "ProductVariant" */
export type ProductVariant_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: ProductVariant_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type ProductVariant_Stream_Cursor_Value_Input = {
  condition: InputMaybe<Scalars['Condition']>;
  createdAt: InputMaybe<Scalars['timestamp']>;
  id: InputMaybe<Scalars['String']>;
  priceInCents: InputMaybe<Scalars['bigint']>;
  productId: InputMaybe<Scalars['String']>;
  quantity: InputMaybe<Scalars['Int']>;
  shopifyId: InputMaybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type ProductVariant_Sum_Fields = {
  __typename?: 'ProductVariant_sum_fields';
  priceInCents: Maybe<Scalars['bigint']>;
  quantity: Maybe<Scalars['Int']>;
  shopifyId: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "ProductVariant" */
export type ProductVariant_Sum_Order_By = {
  priceInCents: InputMaybe<Order_By>;
  quantity: InputMaybe<Order_By>;
  shopifyId: InputMaybe<Order_By>;
};

/** update columns of table "ProductVariant" */
export enum ProductVariant_Update_Column {
  /** column name */
  Condition = 'condition',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  PriceInCents = 'priceInCents',
  /** column name */
  ProductId = 'productId',
  /** column name */
  Quantity = 'quantity',
  /** column name */
  ShopifyId = 'shopifyId',
}

export type ProductVariant_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<ProductVariant_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<ProductVariant_Set_Input>;
  /** filter the rows which have to be updated */
  where: ProductVariant_Bool_Exp;
};

/** aggregate var_pop on columns */
export type ProductVariant_Var_Pop_Fields = {
  __typename?: 'ProductVariant_var_pop_fields';
  priceInCents: Maybe<Scalars['Float']>;
  quantity: Maybe<Scalars['Float']>;
  shopifyId: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "ProductVariant" */
export type ProductVariant_Var_Pop_Order_By = {
  priceInCents: InputMaybe<Order_By>;
  quantity: InputMaybe<Order_By>;
  shopifyId: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type ProductVariant_Var_Samp_Fields = {
  __typename?: 'ProductVariant_var_samp_fields';
  priceInCents: Maybe<Scalars['Float']>;
  quantity: Maybe<Scalars['Float']>;
  shopifyId: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "ProductVariant" */
export type ProductVariant_Var_Samp_Order_By = {
  priceInCents: InputMaybe<Order_By>;
  quantity: InputMaybe<Order_By>;
  shopifyId: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type ProductVariant_Variance_Fields = {
  __typename?: 'ProductVariant_variance_fields';
  priceInCents: Maybe<Scalars['Float']>;
  quantity: Maybe<Scalars['Float']>;
  shopifyId: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "ProductVariant" */
export type ProductVariant_Variance_Order_By = {
  priceInCents: InputMaybe<Order_By>;
  quantity: InputMaybe<Order_By>;
  shopifyId: InputMaybe<Order_By>;
};

/** aggregated selection of "Product" */
export type Product_Aggregate = {
  __typename?: 'Product_aggregate';
  aggregate: Maybe<Product_Aggregate_Fields>;
  nodes: Array<Product>;
};

export type Product_Aggregate_Bool_Exp = {
  count: InputMaybe<Product_Aggregate_Bool_Exp_Count>;
};

export type Product_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<Product_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<Product_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "Product" */
export type Product_Aggregate_Fields = {
  __typename?: 'Product_aggregate_fields';
  avg: Maybe<Product_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Product_Max_Fields>;
  min: Maybe<Product_Min_Fields>;
  stddev: Maybe<Product_Stddev_Fields>;
  stddev_pop: Maybe<Product_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Product_Stddev_Samp_Fields>;
  sum: Maybe<Product_Sum_Fields>;
  var_pop: Maybe<Product_Var_Pop_Fields>;
  var_samp: Maybe<Product_Var_Samp_Fields>;
  variance: Maybe<Product_Variance_Fields>;
};

/** aggregate fields of "Product" */
export type Product_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Product_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "Product" */
export type Product_Aggregate_Order_By = {
  avg: InputMaybe<Product_Avg_Order_By>;
  count: InputMaybe<Order_By>;
  max: InputMaybe<Product_Max_Order_By>;
  min: InputMaybe<Product_Min_Order_By>;
  stddev: InputMaybe<Product_Stddev_Order_By>;
  stddev_pop: InputMaybe<Product_Stddev_Pop_Order_By>;
  stddev_samp: InputMaybe<Product_Stddev_Samp_Order_By>;
  sum: InputMaybe<Product_Sum_Order_By>;
  var_pop: InputMaybe<Product_Var_Pop_Order_By>;
  var_samp: InputMaybe<Product_Var_Samp_Order_By>;
  variance: InputMaybe<Product_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "Product" */
export type Product_Arr_Rel_Insert_Input = {
  data: Array<Product_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<Product_On_Conflict>;
};

/** aggregate avg on columns */
export type Product_Avg_Fields = {
  __typename?: 'Product_avg_fields';
  shopifyId: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "Product" */
export type Product_Avg_Order_By = {
  shopifyId: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "Product". All fields are combined with a logical 'AND'. */
export type Product_Bool_Exp = {
  EANCode: InputMaybe<String_Comparison_Exp>;
  GTINCode: InputMaybe<String_Comparison_Exp>;
  Vendor: InputMaybe<Customer_Bool_Exp>;
  _and: InputMaybe<Array<Product_Bool_Exp>>;
  _not: InputMaybe<Product_Bool_Exp>;
  _or: InputMaybe<Array<Product_Bool_Exp>>;
  createdAt: InputMaybe<Timestamp_Comparison_Exp>;
  handle: InputMaybe<String_Comparison_Exp>;
  id: InputMaybe<String_Comparison_Exp>;
  manualNotation: InputMaybe<ProductNotation_Comparison_Exp>;
  productType: InputMaybe<String_Comparison_Exp>;
  shopifyId: InputMaybe<Bigint_Comparison_Exp>;
  source: InputMaybe<String_Comparison_Exp>;
  sourceUrl: InputMaybe<String_Comparison_Exp>;
  status: InputMaybe<ProductStatus_Comparison_Exp>;
  storeExposedProduct: InputMaybe<Dbt_Store_Exposed_Product_Bool_Exp>;
  variants: InputMaybe<ProductVariant_Bool_Exp>;
  variants_aggregate: InputMaybe<ProductVariant_Aggregate_Bool_Exp>;
  vendorId: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "Product" */
export enum Product_Constraint {
  /** unique or primary key constraint on columns "handle" */
  ProductHandleKey = 'Product_handle_key',
  /** unique or primary key constraint on columns "id" */
  ProductPkey = 'Product_pkey',
  /** unique or primary key constraint on columns "shopifyId" */
  ProductShopifyIdKey = 'Product_shopifyId_key',
}

/** input type for incrementing numeric columns in table "Product" */
export type Product_Inc_Input = {
  shopifyId: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "Product" */
export type Product_Insert_Input = {
  EANCode: InputMaybe<Scalars['String']>;
  GTINCode: InputMaybe<Scalars['String']>;
  Vendor: InputMaybe<Customer_Obj_Rel_Insert_Input>;
  createdAt: InputMaybe<Scalars['timestamp']>;
  handle: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  manualNotation: InputMaybe<Scalars['ProductNotation']>;
  productType: InputMaybe<Scalars['String']>;
  shopifyId: InputMaybe<Scalars['bigint']>;
  source: InputMaybe<Scalars['String']>;
  sourceUrl: InputMaybe<Scalars['String']>;
  status: InputMaybe<Scalars['ProductStatus']>;
  storeExposedProduct: InputMaybe<Dbt_Store_Exposed_Product_Obj_Rel_Insert_Input>;
  variants: InputMaybe<ProductVariant_Arr_Rel_Insert_Input>;
  vendorId: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Product_Max_Fields = {
  __typename?: 'Product_max_fields';
  EANCode: Maybe<Scalars['String']>;
  GTINCode: Maybe<Scalars['String']>;
  createdAt: Maybe<Scalars['timestamp']>;
  handle: Maybe<Scalars['String']>;
  id: Maybe<Scalars['String']>;
  manualNotation: Maybe<Scalars['ProductNotation']>;
  productType: Maybe<Scalars['String']>;
  shopifyId: Maybe<Scalars['bigint']>;
  source: Maybe<Scalars['String']>;
  sourceUrl: Maybe<Scalars['String']>;
  status: Maybe<Scalars['ProductStatus']>;
  vendorId: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "Product" */
export type Product_Max_Order_By = {
  EANCode: InputMaybe<Order_By>;
  GTINCode: InputMaybe<Order_By>;
  createdAt: InputMaybe<Order_By>;
  handle: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  manualNotation: InputMaybe<Order_By>;
  productType: InputMaybe<Order_By>;
  shopifyId: InputMaybe<Order_By>;
  source: InputMaybe<Order_By>;
  sourceUrl: InputMaybe<Order_By>;
  status: InputMaybe<Order_By>;
  vendorId: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Product_Min_Fields = {
  __typename?: 'Product_min_fields';
  EANCode: Maybe<Scalars['String']>;
  GTINCode: Maybe<Scalars['String']>;
  createdAt: Maybe<Scalars['timestamp']>;
  handle: Maybe<Scalars['String']>;
  id: Maybe<Scalars['String']>;
  manualNotation: Maybe<Scalars['ProductNotation']>;
  productType: Maybe<Scalars['String']>;
  shopifyId: Maybe<Scalars['bigint']>;
  source: Maybe<Scalars['String']>;
  sourceUrl: Maybe<Scalars['String']>;
  status: Maybe<Scalars['ProductStatus']>;
  vendorId: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "Product" */
export type Product_Min_Order_By = {
  EANCode: InputMaybe<Order_By>;
  GTINCode: InputMaybe<Order_By>;
  createdAt: InputMaybe<Order_By>;
  handle: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  manualNotation: InputMaybe<Order_By>;
  productType: InputMaybe<Order_By>;
  shopifyId: InputMaybe<Order_By>;
  source: InputMaybe<Order_By>;
  sourceUrl: InputMaybe<Order_By>;
  status: InputMaybe<Order_By>;
  vendorId: InputMaybe<Order_By>;
};

/** response of any mutation on the table "Product" */
export type Product_Mutation_Response = {
  __typename?: 'Product_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Product>;
};

/** input type for inserting object relation for remote table "Product" */
export type Product_Obj_Rel_Insert_Input = {
  data: Product_Insert_Input;
  /** upsert condition */
  on_conflict: InputMaybe<Product_On_Conflict>;
};

/** on_conflict condition type for table "Product" */
export type Product_On_Conflict = {
  constraint: Product_Constraint;
  update_columns: Array<Product_Update_Column>;
  where: InputMaybe<Product_Bool_Exp>;
};

/** Ordering options when selecting data from "Product". */
export type Product_Order_By = {
  EANCode: InputMaybe<Order_By>;
  GTINCode: InputMaybe<Order_By>;
  Vendor: InputMaybe<Customer_Order_By>;
  createdAt: InputMaybe<Order_By>;
  handle: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  manualNotation: InputMaybe<Order_By>;
  productType: InputMaybe<Order_By>;
  shopifyId: InputMaybe<Order_By>;
  source: InputMaybe<Order_By>;
  sourceUrl: InputMaybe<Order_By>;
  status: InputMaybe<Order_By>;
  storeExposedProduct: InputMaybe<Dbt_Store_Exposed_Product_Order_By>;
  variants_aggregate: InputMaybe<ProductVariant_Aggregate_Order_By>;
  vendorId: InputMaybe<Order_By>;
};

/** primary key columns input for table: Product */
export type Product_Pk_Columns_Input = {
  id: Scalars['String'];
};

/** select columns of table "Product" */
export enum Product_Select_Column {
  /** column name */
  EanCode = 'EANCode',
  /** column name */
  GtinCode = 'GTINCode',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Handle = 'handle',
  /** column name */
  Id = 'id',
  /** column name */
  ManualNotation = 'manualNotation',
  /** column name */
  ProductType = 'productType',
  /** column name */
  ShopifyId = 'shopifyId',
  /** column name */
  Source = 'source',
  /** column name */
  SourceUrl = 'sourceUrl',
  /** column name */
  Status = 'status',
  /** column name */
  VendorId = 'vendorId',
}

/** input type for updating data in table "Product" */
export type Product_Set_Input = {
  EANCode: InputMaybe<Scalars['String']>;
  GTINCode: InputMaybe<Scalars['String']>;
  createdAt: InputMaybe<Scalars['timestamp']>;
  handle: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  manualNotation: InputMaybe<Scalars['ProductNotation']>;
  productType: InputMaybe<Scalars['String']>;
  shopifyId: InputMaybe<Scalars['bigint']>;
  source: InputMaybe<Scalars['String']>;
  sourceUrl: InputMaybe<Scalars['String']>;
  status: InputMaybe<Scalars['ProductStatus']>;
  vendorId: InputMaybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type Product_Stddev_Fields = {
  __typename?: 'Product_stddev_fields';
  shopifyId: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "Product" */
export type Product_Stddev_Order_By = {
  shopifyId: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Product_Stddev_Pop_Fields = {
  __typename?: 'Product_stddev_pop_fields';
  shopifyId: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "Product" */
export type Product_Stddev_Pop_Order_By = {
  shopifyId: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Product_Stddev_Samp_Fields = {
  __typename?: 'Product_stddev_samp_fields';
  shopifyId: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "Product" */
export type Product_Stddev_Samp_Order_By = {
  shopifyId: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "Product" */
export type Product_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Product_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Product_Stream_Cursor_Value_Input = {
  EANCode: InputMaybe<Scalars['String']>;
  GTINCode: InputMaybe<Scalars['String']>;
  createdAt: InputMaybe<Scalars['timestamp']>;
  handle: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  manualNotation: InputMaybe<Scalars['ProductNotation']>;
  productType: InputMaybe<Scalars['String']>;
  shopifyId: InputMaybe<Scalars['bigint']>;
  source: InputMaybe<Scalars['String']>;
  sourceUrl: InputMaybe<Scalars['String']>;
  status: InputMaybe<Scalars['ProductStatus']>;
  vendorId: InputMaybe<Scalars['uuid']>;
};

/** aggregate sum on columns */
export type Product_Sum_Fields = {
  __typename?: 'Product_sum_fields';
  shopifyId: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "Product" */
export type Product_Sum_Order_By = {
  shopifyId: InputMaybe<Order_By>;
};

/** update columns of table "Product" */
export enum Product_Update_Column {
  /** column name */
  EanCode = 'EANCode',
  /** column name */
  GtinCode = 'GTINCode',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Handle = 'handle',
  /** column name */
  Id = 'id',
  /** column name */
  ManualNotation = 'manualNotation',
  /** column name */
  ProductType = 'productType',
  /** column name */
  ShopifyId = 'shopifyId',
  /** column name */
  Source = 'source',
  /** column name */
  SourceUrl = 'sourceUrl',
  /** column name */
  Status = 'status',
  /** column name */
  VendorId = 'vendorId',
}

export type Product_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Product_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Product_Set_Input>;
  /** filter the rows which have to be updated */
  where: Product_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Product_Var_Pop_Fields = {
  __typename?: 'Product_var_pop_fields';
  shopifyId: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "Product" */
export type Product_Var_Pop_Order_By = {
  shopifyId: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Product_Var_Samp_Fields = {
  __typename?: 'Product_var_samp_fields';
  shopifyId: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "Product" */
export type Product_Var_Samp_Order_By = {
  shopifyId: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Product_Variance_Fields = {
  __typename?: 'Product_variance_fields';
  shopifyId: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "Product" */
export type Product_Variance_Order_By = {
  shopifyId: InputMaybe<Order_By>;
};

/** columns and relationships of "Return" */
export type Return = {
  __typename?: 'Return';
  createdAt: Scalars['timestamp'];
  /** An object relationship */
  dispute: Dispute;
  disputeId: Scalars['String'];
  id: Scalars['String'];
  /** An array relationship */
  returnItems: Array<ReturnItem>;
  /** An aggregate relationship */
  returnItems_aggregate: ReturnItem_Aggregate;
  status: Scalars['ReturnStatus'];
  trackingUrl: Maybe<Scalars['String']>;
};

/** columns and relationships of "Return" */
export type ReturnReturnItemsArgs = {
  distinct_on: InputMaybe<Array<ReturnItem_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<ReturnItem_Order_By>>;
  where: InputMaybe<ReturnItem_Bool_Exp>;
};

/** columns and relationships of "Return" */
export type ReturnReturnItems_AggregateArgs = {
  distinct_on: InputMaybe<Array<ReturnItem_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<ReturnItem_Order_By>>;
  where: InputMaybe<ReturnItem_Bool_Exp>;
};

/** columns and relationships of "ReturnItem" */
export type ReturnItem = {
  __typename?: 'ReturnItem';
  createdAt: Scalars['timestamp'];
  /** An object relationship */
  fulfillmentItem: FulfillmentItem;
  fulfillmentItemId: Scalars['String'];
  id: Scalars['String'];
  quantity: Scalars['Int'];
  /** An object relationship */
  return: Return;
  returnId: Scalars['String'];
};

/** aggregated selection of "ReturnItem" */
export type ReturnItem_Aggregate = {
  __typename?: 'ReturnItem_aggregate';
  aggregate: Maybe<ReturnItem_Aggregate_Fields>;
  nodes: Array<ReturnItem>;
};

export type ReturnItem_Aggregate_Bool_Exp = {
  count: InputMaybe<ReturnItem_Aggregate_Bool_Exp_Count>;
};

export type ReturnItem_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<ReturnItem_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<ReturnItem_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "ReturnItem" */
export type ReturnItem_Aggregate_Fields = {
  __typename?: 'ReturnItem_aggregate_fields';
  avg: Maybe<ReturnItem_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<ReturnItem_Max_Fields>;
  min: Maybe<ReturnItem_Min_Fields>;
  stddev: Maybe<ReturnItem_Stddev_Fields>;
  stddev_pop: Maybe<ReturnItem_Stddev_Pop_Fields>;
  stddev_samp: Maybe<ReturnItem_Stddev_Samp_Fields>;
  sum: Maybe<ReturnItem_Sum_Fields>;
  var_pop: Maybe<ReturnItem_Var_Pop_Fields>;
  var_samp: Maybe<ReturnItem_Var_Samp_Fields>;
  variance: Maybe<ReturnItem_Variance_Fields>;
};

/** aggregate fields of "ReturnItem" */
export type ReturnItem_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<ReturnItem_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "ReturnItem" */
export type ReturnItem_Aggregate_Order_By = {
  avg: InputMaybe<ReturnItem_Avg_Order_By>;
  count: InputMaybe<Order_By>;
  max: InputMaybe<ReturnItem_Max_Order_By>;
  min: InputMaybe<ReturnItem_Min_Order_By>;
  stddev: InputMaybe<ReturnItem_Stddev_Order_By>;
  stddev_pop: InputMaybe<ReturnItem_Stddev_Pop_Order_By>;
  stddev_samp: InputMaybe<ReturnItem_Stddev_Samp_Order_By>;
  sum: InputMaybe<ReturnItem_Sum_Order_By>;
  var_pop: InputMaybe<ReturnItem_Var_Pop_Order_By>;
  var_samp: InputMaybe<ReturnItem_Var_Samp_Order_By>;
  variance: InputMaybe<ReturnItem_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "ReturnItem" */
export type ReturnItem_Arr_Rel_Insert_Input = {
  data: Array<ReturnItem_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<ReturnItem_On_Conflict>;
};

/** aggregate avg on columns */
export type ReturnItem_Avg_Fields = {
  __typename?: 'ReturnItem_avg_fields';
  quantity: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "ReturnItem" */
export type ReturnItem_Avg_Order_By = {
  quantity: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "ReturnItem". All fields are combined with a logical 'AND'. */
export type ReturnItem_Bool_Exp = {
  _and: InputMaybe<Array<ReturnItem_Bool_Exp>>;
  _not: InputMaybe<ReturnItem_Bool_Exp>;
  _or: InputMaybe<Array<ReturnItem_Bool_Exp>>;
  createdAt: InputMaybe<Timestamp_Comparison_Exp>;
  fulfillmentItem: InputMaybe<FulfillmentItem_Bool_Exp>;
  fulfillmentItemId: InputMaybe<String_Comparison_Exp>;
  id: InputMaybe<String_Comparison_Exp>;
  quantity: InputMaybe<Int_Comparison_Exp>;
  return: InputMaybe<Return_Bool_Exp>;
  returnId: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "ReturnItem" */
export enum ReturnItem_Constraint {
  /** unique or primary key constraint on columns "id" */
  ReturnItemPkey = 'ReturnItem_pkey',
}

/** input type for incrementing numeric columns in table "ReturnItem" */
export type ReturnItem_Inc_Input = {
  quantity: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "ReturnItem" */
export type ReturnItem_Insert_Input = {
  createdAt: InputMaybe<Scalars['timestamp']>;
  fulfillmentItem: InputMaybe<FulfillmentItem_Obj_Rel_Insert_Input>;
  fulfillmentItemId: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  quantity: InputMaybe<Scalars['Int']>;
  return: InputMaybe<Return_Obj_Rel_Insert_Input>;
  returnId: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type ReturnItem_Max_Fields = {
  __typename?: 'ReturnItem_max_fields';
  createdAt: Maybe<Scalars['timestamp']>;
  fulfillmentItemId: Maybe<Scalars['String']>;
  id: Maybe<Scalars['String']>;
  quantity: Maybe<Scalars['Int']>;
  returnId: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "ReturnItem" */
export type ReturnItem_Max_Order_By = {
  createdAt: InputMaybe<Order_By>;
  fulfillmentItemId: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  quantity: InputMaybe<Order_By>;
  returnId: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type ReturnItem_Min_Fields = {
  __typename?: 'ReturnItem_min_fields';
  createdAt: Maybe<Scalars['timestamp']>;
  fulfillmentItemId: Maybe<Scalars['String']>;
  id: Maybe<Scalars['String']>;
  quantity: Maybe<Scalars['Int']>;
  returnId: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "ReturnItem" */
export type ReturnItem_Min_Order_By = {
  createdAt: InputMaybe<Order_By>;
  fulfillmentItemId: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  quantity: InputMaybe<Order_By>;
  returnId: InputMaybe<Order_By>;
};

/** response of any mutation on the table "ReturnItem" */
export type ReturnItem_Mutation_Response = {
  __typename?: 'ReturnItem_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<ReturnItem>;
};

/** on_conflict condition type for table "ReturnItem" */
export type ReturnItem_On_Conflict = {
  constraint: ReturnItem_Constraint;
  update_columns: Array<ReturnItem_Update_Column>;
  where: InputMaybe<ReturnItem_Bool_Exp>;
};

/** Ordering options when selecting data from "ReturnItem". */
export type ReturnItem_Order_By = {
  createdAt: InputMaybe<Order_By>;
  fulfillmentItem: InputMaybe<FulfillmentItem_Order_By>;
  fulfillmentItemId: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  quantity: InputMaybe<Order_By>;
  return: InputMaybe<Return_Order_By>;
  returnId: InputMaybe<Order_By>;
};

/** primary key columns input for table: ReturnItem */
export type ReturnItem_Pk_Columns_Input = {
  id: Scalars['String'];
};

/** select columns of table "ReturnItem" */
export enum ReturnItem_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  FulfillmentItemId = 'fulfillmentItemId',
  /** column name */
  Id = 'id',
  /** column name */
  Quantity = 'quantity',
  /** column name */
  ReturnId = 'returnId',
}

/** input type for updating data in table "ReturnItem" */
export type ReturnItem_Set_Input = {
  createdAt: InputMaybe<Scalars['timestamp']>;
  fulfillmentItemId: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  quantity: InputMaybe<Scalars['Int']>;
  returnId: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type ReturnItem_Stddev_Fields = {
  __typename?: 'ReturnItem_stddev_fields';
  quantity: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "ReturnItem" */
export type ReturnItem_Stddev_Order_By = {
  quantity: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type ReturnItem_Stddev_Pop_Fields = {
  __typename?: 'ReturnItem_stddev_pop_fields';
  quantity: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "ReturnItem" */
export type ReturnItem_Stddev_Pop_Order_By = {
  quantity: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type ReturnItem_Stddev_Samp_Fields = {
  __typename?: 'ReturnItem_stddev_samp_fields';
  quantity: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "ReturnItem" */
export type ReturnItem_Stddev_Samp_Order_By = {
  quantity: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "ReturnItem" */
export type ReturnItem_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: ReturnItem_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type ReturnItem_Stream_Cursor_Value_Input = {
  createdAt: InputMaybe<Scalars['timestamp']>;
  fulfillmentItemId: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  quantity: InputMaybe<Scalars['Int']>;
  returnId: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type ReturnItem_Sum_Fields = {
  __typename?: 'ReturnItem_sum_fields';
  quantity: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "ReturnItem" */
export type ReturnItem_Sum_Order_By = {
  quantity: InputMaybe<Order_By>;
};

/** update columns of table "ReturnItem" */
export enum ReturnItem_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  FulfillmentItemId = 'fulfillmentItemId',
  /** column name */
  Id = 'id',
  /** column name */
  Quantity = 'quantity',
  /** column name */
  ReturnId = 'returnId',
}

export type ReturnItem_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<ReturnItem_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<ReturnItem_Set_Input>;
  /** filter the rows which have to be updated */
  where: ReturnItem_Bool_Exp;
};

/** aggregate var_pop on columns */
export type ReturnItem_Var_Pop_Fields = {
  __typename?: 'ReturnItem_var_pop_fields';
  quantity: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "ReturnItem" */
export type ReturnItem_Var_Pop_Order_By = {
  quantity: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type ReturnItem_Var_Samp_Fields = {
  __typename?: 'ReturnItem_var_samp_fields';
  quantity: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "ReturnItem" */
export type ReturnItem_Var_Samp_Order_By = {
  quantity: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type ReturnItem_Variance_Fields = {
  __typename?: 'ReturnItem_variance_fields';
  quantity: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "ReturnItem" */
export type ReturnItem_Variance_Order_By = {
  quantity: InputMaybe<Order_By>;
};

/** Boolean expression to compare columns of type "ReturnStatus". All fields are combined with logical 'AND'. */
export type ReturnStatus_Comparison_Exp = {
  _eq: InputMaybe<Scalars['ReturnStatus']>;
  _gt: InputMaybe<Scalars['ReturnStatus']>;
  _gte: InputMaybe<Scalars['ReturnStatus']>;
  _in: InputMaybe<Array<Scalars['ReturnStatus']>>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  _lt: InputMaybe<Scalars['ReturnStatus']>;
  _lte: InputMaybe<Scalars['ReturnStatus']>;
  _neq: InputMaybe<Scalars['ReturnStatus']>;
  _nin: InputMaybe<Array<Scalars['ReturnStatus']>>;
};

/** aggregated selection of "Return" */
export type Return_Aggregate = {
  __typename?: 'Return_aggregate';
  aggregate: Maybe<Return_Aggregate_Fields>;
  nodes: Array<Return>;
};

export type Return_Aggregate_Bool_Exp = {
  count: InputMaybe<Return_Aggregate_Bool_Exp_Count>;
};

export type Return_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<Return_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<Return_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "Return" */
export type Return_Aggregate_Fields = {
  __typename?: 'Return_aggregate_fields';
  count: Scalars['Int'];
  max: Maybe<Return_Max_Fields>;
  min: Maybe<Return_Min_Fields>;
};

/** aggregate fields of "Return" */
export type Return_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Return_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "Return" */
export type Return_Aggregate_Order_By = {
  count: InputMaybe<Order_By>;
  max: InputMaybe<Return_Max_Order_By>;
  min: InputMaybe<Return_Min_Order_By>;
};

/** input type for inserting array relation for remote table "Return" */
export type Return_Arr_Rel_Insert_Input = {
  data: Array<Return_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<Return_On_Conflict>;
};

/** Boolean expression to filter rows from the table "Return". All fields are combined with a logical 'AND'. */
export type Return_Bool_Exp = {
  _and: InputMaybe<Array<Return_Bool_Exp>>;
  _not: InputMaybe<Return_Bool_Exp>;
  _or: InputMaybe<Array<Return_Bool_Exp>>;
  createdAt: InputMaybe<Timestamp_Comparison_Exp>;
  dispute: InputMaybe<Dispute_Bool_Exp>;
  disputeId: InputMaybe<String_Comparison_Exp>;
  id: InputMaybe<String_Comparison_Exp>;
  returnItems: InputMaybe<ReturnItem_Bool_Exp>;
  returnItems_aggregate: InputMaybe<ReturnItem_Aggregate_Bool_Exp>;
  status: InputMaybe<ReturnStatus_Comparison_Exp>;
  trackingUrl: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "Return" */
export enum Return_Constraint {
  /** unique or primary key constraint on columns "id" */
  ReturnPkey = 'Return_pkey',
}

/** input type for inserting data into table "Return" */
export type Return_Insert_Input = {
  createdAt: InputMaybe<Scalars['timestamp']>;
  dispute: InputMaybe<Dispute_Obj_Rel_Insert_Input>;
  disputeId: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  returnItems: InputMaybe<ReturnItem_Arr_Rel_Insert_Input>;
  status: InputMaybe<Scalars['ReturnStatus']>;
  trackingUrl: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Return_Max_Fields = {
  __typename?: 'Return_max_fields';
  createdAt: Maybe<Scalars['timestamp']>;
  disputeId: Maybe<Scalars['String']>;
  id: Maybe<Scalars['String']>;
  status: Maybe<Scalars['ReturnStatus']>;
  trackingUrl: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "Return" */
export type Return_Max_Order_By = {
  createdAt: InputMaybe<Order_By>;
  disputeId: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  status: InputMaybe<Order_By>;
  trackingUrl: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Return_Min_Fields = {
  __typename?: 'Return_min_fields';
  createdAt: Maybe<Scalars['timestamp']>;
  disputeId: Maybe<Scalars['String']>;
  id: Maybe<Scalars['String']>;
  status: Maybe<Scalars['ReturnStatus']>;
  trackingUrl: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "Return" */
export type Return_Min_Order_By = {
  createdAt: InputMaybe<Order_By>;
  disputeId: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  status: InputMaybe<Order_By>;
  trackingUrl: InputMaybe<Order_By>;
};

/** response of any mutation on the table "Return" */
export type Return_Mutation_Response = {
  __typename?: 'Return_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Return>;
};

/** input type for inserting object relation for remote table "Return" */
export type Return_Obj_Rel_Insert_Input = {
  data: Return_Insert_Input;
  /** upsert condition */
  on_conflict: InputMaybe<Return_On_Conflict>;
};

/** on_conflict condition type for table "Return" */
export type Return_On_Conflict = {
  constraint: Return_Constraint;
  update_columns: Array<Return_Update_Column>;
  where: InputMaybe<Return_Bool_Exp>;
};

/** Ordering options when selecting data from "Return". */
export type Return_Order_By = {
  createdAt: InputMaybe<Order_By>;
  dispute: InputMaybe<Dispute_Order_By>;
  disputeId: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  returnItems_aggregate: InputMaybe<ReturnItem_Aggregate_Order_By>;
  status: InputMaybe<Order_By>;
  trackingUrl: InputMaybe<Order_By>;
};

/** primary key columns input for table: Return */
export type Return_Pk_Columns_Input = {
  id: Scalars['String'];
};

/** select columns of table "Return" */
export enum Return_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DisputeId = 'disputeId',
  /** column name */
  Id = 'id',
  /** column name */
  Status = 'status',
  /** column name */
  TrackingUrl = 'trackingUrl',
}

/** input type for updating data in table "Return" */
export type Return_Set_Input = {
  createdAt: InputMaybe<Scalars['timestamp']>;
  disputeId: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  status: InputMaybe<Scalars['ReturnStatus']>;
  trackingUrl: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "Return" */
export type Return_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Return_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Return_Stream_Cursor_Value_Input = {
  createdAt: InputMaybe<Scalars['timestamp']>;
  disputeId: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  status: InputMaybe<Scalars['ReturnStatus']>;
  trackingUrl: InputMaybe<Scalars['String']>;
};

/** update columns of table "Return" */
export enum Return_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DisputeId = 'disputeId',
  /** column name */
  Id = 'id',
  /** column name */
  Status = 'status',
  /** column name */
  TrackingUrl = 'trackingUrl',
}

export type Return_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Return_Set_Input>;
  /** filter the rows which have to be updated */
  where: Return_Bool_Exp;
};

/** columns and relationships of "Review" */
export type Review = {
  __typename?: 'Review';
  /** An object relationship */
  Customer: Customer;
  /** An object relationship */
  Order: Maybe<Order>;
  /** An array relationship */
  VendorReview: Array<VendorReview>;
  /** An aggregate relationship */
  VendorReview_aggregate: VendorReview_Aggregate;
  authorNickname: Maybe<Scalars['String']>;
  content: Maybe<Scalars['String']>;
  createdAt: Scalars['timestamp'];
  customerId: Scalars['uuid'];
  id: Scalars['String'];
  orderId: Maybe<Scalars['String']>;
  rating: Scalars['Int'];
  title: Scalars['String'];
};

/** columns and relationships of "Review" */
export type ReviewVendorReviewArgs = {
  distinct_on: InputMaybe<Array<VendorReview_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<VendorReview_Order_By>>;
  where: InputMaybe<VendorReview_Bool_Exp>;
};

/** columns and relationships of "Review" */
export type ReviewVendorReview_AggregateArgs = {
  distinct_on: InputMaybe<Array<VendorReview_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<VendorReview_Order_By>>;
  where: InputMaybe<VendorReview_Bool_Exp>;
};

/** aggregated selection of "Review" */
export type Review_Aggregate = {
  __typename?: 'Review_aggregate';
  aggregate: Maybe<Review_Aggregate_Fields>;
  nodes: Array<Review>;
};

export type Review_Aggregate_Bool_Exp = {
  count: InputMaybe<Review_Aggregate_Bool_Exp_Count>;
};

export type Review_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<Review_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<Review_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "Review" */
export type Review_Aggregate_Fields = {
  __typename?: 'Review_aggregate_fields';
  avg: Maybe<Review_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Review_Max_Fields>;
  min: Maybe<Review_Min_Fields>;
  stddev: Maybe<Review_Stddev_Fields>;
  stddev_pop: Maybe<Review_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Review_Stddev_Samp_Fields>;
  sum: Maybe<Review_Sum_Fields>;
  var_pop: Maybe<Review_Var_Pop_Fields>;
  var_samp: Maybe<Review_Var_Samp_Fields>;
  variance: Maybe<Review_Variance_Fields>;
};

/** aggregate fields of "Review" */
export type Review_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Review_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "Review" */
export type Review_Aggregate_Order_By = {
  avg: InputMaybe<Review_Avg_Order_By>;
  count: InputMaybe<Order_By>;
  max: InputMaybe<Review_Max_Order_By>;
  min: InputMaybe<Review_Min_Order_By>;
  stddev: InputMaybe<Review_Stddev_Order_By>;
  stddev_pop: InputMaybe<Review_Stddev_Pop_Order_By>;
  stddev_samp: InputMaybe<Review_Stddev_Samp_Order_By>;
  sum: InputMaybe<Review_Sum_Order_By>;
  var_pop: InputMaybe<Review_Var_Pop_Order_By>;
  var_samp: InputMaybe<Review_Var_Samp_Order_By>;
  variance: InputMaybe<Review_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "Review" */
export type Review_Arr_Rel_Insert_Input = {
  data: Array<Review_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<Review_On_Conflict>;
};

/** aggregate avg on columns */
export type Review_Avg_Fields = {
  __typename?: 'Review_avg_fields';
  rating: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "Review" */
export type Review_Avg_Order_By = {
  rating: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "Review". All fields are combined with a logical 'AND'. */
export type Review_Bool_Exp = {
  Customer: InputMaybe<Customer_Bool_Exp>;
  Order: InputMaybe<Order_Bool_Exp>;
  VendorReview: InputMaybe<VendorReview_Bool_Exp>;
  VendorReview_aggregate: InputMaybe<VendorReview_Aggregate_Bool_Exp>;
  _and: InputMaybe<Array<Review_Bool_Exp>>;
  _not: InputMaybe<Review_Bool_Exp>;
  _or: InputMaybe<Array<Review_Bool_Exp>>;
  authorNickname: InputMaybe<String_Comparison_Exp>;
  content: InputMaybe<String_Comparison_Exp>;
  createdAt: InputMaybe<Timestamp_Comparison_Exp>;
  customerId: InputMaybe<Uuid_Comparison_Exp>;
  id: InputMaybe<String_Comparison_Exp>;
  orderId: InputMaybe<String_Comparison_Exp>;
  rating: InputMaybe<Int_Comparison_Exp>;
  title: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "Review" */
export enum Review_Constraint {
  /** unique or primary key constraint on columns "id" */
  ReviewPkey = 'Review_pkey',
}

/** input type for incrementing numeric columns in table "Review" */
export type Review_Inc_Input = {
  rating: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "Review" */
export type Review_Insert_Input = {
  Customer: InputMaybe<Customer_Obj_Rel_Insert_Input>;
  Order: InputMaybe<Order_Obj_Rel_Insert_Input>;
  VendorReview: InputMaybe<VendorReview_Arr_Rel_Insert_Input>;
  authorNickname: InputMaybe<Scalars['String']>;
  content: InputMaybe<Scalars['String']>;
  createdAt: InputMaybe<Scalars['timestamp']>;
  customerId: InputMaybe<Scalars['uuid']>;
  id: InputMaybe<Scalars['String']>;
  orderId: InputMaybe<Scalars['String']>;
  rating: InputMaybe<Scalars['Int']>;
  title: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Review_Max_Fields = {
  __typename?: 'Review_max_fields';
  authorNickname: Maybe<Scalars['String']>;
  content: Maybe<Scalars['String']>;
  createdAt: Maybe<Scalars['timestamp']>;
  customerId: Maybe<Scalars['uuid']>;
  id: Maybe<Scalars['String']>;
  orderId: Maybe<Scalars['String']>;
  rating: Maybe<Scalars['Int']>;
  title: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "Review" */
export type Review_Max_Order_By = {
  authorNickname: InputMaybe<Order_By>;
  content: InputMaybe<Order_By>;
  createdAt: InputMaybe<Order_By>;
  customerId: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  orderId: InputMaybe<Order_By>;
  rating: InputMaybe<Order_By>;
  title: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Review_Min_Fields = {
  __typename?: 'Review_min_fields';
  authorNickname: Maybe<Scalars['String']>;
  content: Maybe<Scalars['String']>;
  createdAt: Maybe<Scalars['timestamp']>;
  customerId: Maybe<Scalars['uuid']>;
  id: Maybe<Scalars['String']>;
  orderId: Maybe<Scalars['String']>;
  rating: Maybe<Scalars['Int']>;
  title: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "Review" */
export type Review_Min_Order_By = {
  authorNickname: InputMaybe<Order_By>;
  content: InputMaybe<Order_By>;
  createdAt: InputMaybe<Order_By>;
  customerId: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  orderId: InputMaybe<Order_By>;
  rating: InputMaybe<Order_By>;
  title: InputMaybe<Order_By>;
};

/** response of any mutation on the table "Review" */
export type Review_Mutation_Response = {
  __typename?: 'Review_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Review>;
};

/** input type for inserting object relation for remote table "Review" */
export type Review_Obj_Rel_Insert_Input = {
  data: Review_Insert_Input;
  /** upsert condition */
  on_conflict: InputMaybe<Review_On_Conflict>;
};

/** on_conflict condition type for table "Review" */
export type Review_On_Conflict = {
  constraint: Review_Constraint;
  update_columns: Array<Review_Update_Column>;
  where: InputMaybe<Review_Bool_Exp>;
};

/** Ordering options when selecting data from "Review". */
export type Review_Order_By = {
  Customer: InputMaybe<Customer_Order_By>;
  Order: InputMaybe<Order_Order_By>;
  VendorReview_aggregate: InputMaybe<VendorReview_Aggregate_Order_By>;
  authorNickname: InputMaybe<Order_By>;
  content: InputMaybe<Order_By>;
  createdAt: InputMaybe<Order_By>;
  customerId: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  orderId: InputMaybe<Order_By>;
  rating: InputMaybe<Order_By>;
  title: InputMaybe<Order_By>;
};

/** primary key columns input for table: Review */
export type Review_Pk_Columns_Input = {
  id: Scalars['String'];
};

/** select columns of table "Review" */
export enum Review_Select_Column {
  /** column name */
  AuthorNickname = 'authorNickname',
  /** column name */
  Content = 'content',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CustomerId = 'customerId',
  /** column name */
  Id = 'id',
  /** column name */
  OrderId = 'orderId',
  /** column name */
  Rating = 'rating',
  /** column name */
  Title = 'title',
}

/** input type for updating data in table "Review" */
export type Review_Set_Input = {
  authorNickname: InputMaybe<Scalars['String']>;
  content: InputMaybe<Scalars['String']>;
  createdAt: InputMaybe<Scalars['timestamp']>;
  customerId: InputMaybe<Scalars['uuid']>;
  id: InputMaybe<Scalars['String']>;
  orderId: InputMaybe<Scalars['String']>;
  rating: InputMaybe<Scalars['Int']>;
  title: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Review_Stddev_Fields = {
  __typename?: 'Review_stddev_fields';
  rating: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "Review" */
export type Review_Stddev_Order_By = {
  rating: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Review_Stddev_Pop_Fields = {
  __typename?: 'Review_stddev_pop_fields';
  rating: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "Review" */
export type Review_Stddev_Pop_Order_By = {
  rating: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Review_Stddev_Samp_Fields = {
  __typename?: 'Review_stddev_samp_fields';
  rating: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "Review" */
export type Review_Stddev_Samp_Order_By = {
  rating: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "Review" */
export type Review_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Review_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Review_Stream_Cursor_Value_Input = {
  authorNickname: InputMaybe<Scalars['String']>;
  content: InputMaybe<Scalars['String']>;
  createdAt: InputMaybe<Scalars['timestamp']>;
  customerId: InputMaybe<Scalars['uuid']>;
  id: InputMaybe<Scalars['String']>;
  orderId: InputMaybe<Scalars['String']>;
  rating: InputMaybe<Scalars['Int']>;
  title: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type Review_Sum_Fields = {
  __typename?: 'Review_sum_fields';
  rating: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "Review" */
export type Review_Sum_Order_By = {
  rating: InputMaybe<Order_By>;
};

/** update columns of table "Review" */
export enum Review_Update_Column {
  /** column name */
  AuthorNickname = 'authorNickname',
  /** column name */
  Content = 'content',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CustomerId = 'customerId',
  /** column name */
  Id = 'id',
  /** column name */
  OrderId = 'orderId',
  /** column name */
  Rating = 'rating',
  /** column name */
  Title = 'title',
}

export type Review_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Review_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Review_Set_Input>;
  /** filter the rows which have to be updated */
  where: Review_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Review_Var_Pop_Fields = {
  __typename?: 'Review_var_pop_fields';
  rating: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "Review" */
export type Review_Var_Pop_Order_By = {
  rating: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Review_Var_Samp_Fields = {
  __typename?: 'Review_var_samp_fields';
  rating: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "Review" */
export type Review_Var_Samp_Order_By = {
  rating: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Review_Variance_Fields = {
  __typename?: 'Review_variance_fields';
  rating: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "Review" */
export type Review_Variance_Order_By = {
  rating: InputMaybe<Order_By>;
};

/** columns and relationships of "SavedSearch" */
export type SavedSearch = {
  __typename?: 'SavedSearch';
  /** An object relationship */
  Collection: Maybe<Collection>;
  /** An object relationship */
  Customer: Customer;
  /** An array relationship */
  FacetFilters: Array<FacetFilter>;
  /** An aggregate relationship */
  FacetFilters_aggregate: FacetFilter_Aggregate;
  /** An array relationship */
  NumericFilters: Array<NumericFilter>;
  /** An aggregate relationship */
  NumericFilters_aggregate: NumericFilter_Aggregate;
  /** An array relationship */
  SearchAlerts: Array<SearchAlert>;
  /** An aggregate relationship */
  SearchAlerts_aggregate: SearchAlert_Aggregate;
  collectionId: Maybe<Scalars['String']>;
  createdAt: Scalars['timestamp'];
  customerId: Scalars['uuid'];
  id: Scalars['String'];
  name: Scalars['String'];
  query: Maybe<Scalars['String']>;
  resultsUrl: Maybe<Scalars['String']>;
  source: Scalars['String'];
  updatedAt: Maybe<Scalars['timestamp']>;
};

/** columns and relationships of "SavedSearch" */
export type SavedSearchFacetFiltersArgs = {
  distinct_on: InputMaybe<Array<FacetFilter_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<FacetFilter_Order_By>>;
  where: InputMaybe<FacetFilter_Bool_Exp>;
};

/** columns and relationships of "SavedSearch" */
export type SavedSearchFacetFilters_AggregateArgs = {
  distinct_on: InputMaybe<Array<FacetFilter_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<FacetFilter_Order_By>>;
  where: InputMaybe<FacetFilter_Bool_Exp>;
};

/** columns and relationships of "SavedSearch" */
export type SavedSearchNumericFiltersArgs = {
  distinct_on: InputMaybe<Array<NumericFilter_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<NumericFilter_Order_By>>;
  where: InputMaybe<NumericFilter_Bool_Exp>;
};

/** columns and relationships of "SavedSearch" */
export type SavedSearchNumericFilters_AggregateArgs = {
  distinct_on: InputMaybe<Array<NumericFilter_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<NumericFilter_Order_By>>;
  where: InputMaybe<NumericFilter_Bool_Exp>;
};

/** columns and relationships of "SavedSearch" */
export type SavedSearchSearchAlertsArgs = {
  distinct_on: InputMaybe<Array<SearchAlert_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<SearchAlert_Order_By>>;
  where: InputMaybe<SearchAlert_Bool_Exp>;
};

/** columns and relationships of "SavedSearch" */
export type SavedSearchSearchAlerts_AggregateArgs = {
  distinct_on: InputMaybe<Array<SearchAlert_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<SearchAlert_Order_By>>;
  where: InputMaybe<SearchAlert_Bool_Exp>;
};

/** aggregated selection of "SavedSearch" */
export type SavedSearch_Aggregate = {
  __typename?: 'SavedSearch_aggregate';
  aggregate: Maybe<SavedSearch_Aggregate_Fields>;
  nodes: Array<SavedSearch>;
};

/** aggregate fields of "SavedSearch" */
export type SavedSearch_Aggregate_Fields = {
  __typename?: 'SavedSearch_aggregate_fields';
  count: Scalars['Int'];
  max: Maybe<SavedSearch_Max_Fields>;
  min: Maybe<SavedSearch_Min_Fields>;
};

/** aggregate fields of "SavedSearch" */
export type SavedSearch_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<SavedSearch_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "SavedSearch". All fields are combined with a logical 'AND'. */
export type SavedSearch_Bool_Exp = {
  Collection: InputMaybe<Collection_Bool_Exp>;
  Customer: InputMaybe<Customer_Bool_Exp>;
  FacetFilters: InputMaybe<FacetFilter_Bool_Exp>;
  FacetFilters_aggregate: InputMaybe<FacetFilter_Aggregate_Bool_Exp>;
  NumericFilters: InputMaybe<NumericFilter_Bool_Exp>;
  NumericFilters_aggregate: InputMaybe<NumericFilter_Aggregate_Bool_Exp>;
  SearchAlerts: InputMaybe<SearchAlert_Bool_Exp>;
  SearchAlerts_aggregate: InputMaybe<SearchAlert_Aggregate_Bool_Exp>;
  _and: InputMaybe<Array<SavedSearch_Bool_Exp>>;
  _not: InputMaybe<SavedSearch_Bool_Exp>;
  _or: InputMaybe<Array<SavedSearch_Bool_Exp>>;
  collectionId: InputMaybe<String_Comparison_Exp>;
  createdAt: InputMaybe<Timestamp_Comparison_Exp>;
  customerId: InputMaybe<Uuid_Comparison_Exp>;
  id: InputMaybe<String_Comparison_Exp>;
  name: InputMaybe<String_Comparison_Exp>;
  query: InputMaybe<String_Comparison_Exp>;
  resultsUrl: InputMaybe<String_Comparison_Exp>;
  source: InputMaybe<String_Comparison_Exp>;
  updatedAt: InputMaybe<Timestamp_Comparison_Exp>;
};

/** unique or primary key constraints on table "SavedSearch" */
export enum SavedSearch_Constraint {
  /** unique or primary key constraint on columns "id" */
  SavedSearchPkey = 'SavedSearch_pkey',
}

/** input type for inserting data into table "SavedSearch" */
export type SavedSearch_Insert_Input = {
  Collection: InputMaybe<Collection_Obj_Rel_Insert_Input>;
  Customer: InputMaybe<Customer_Obj_Rel_Insert_Input>;
  FacetFilters: InputMaybe<FacetFilter_Arr_Rel_Insert_Input>;
  NumericFilters: InputMaybe<NumericFilter_Arr_Rel_Insert_Input>;
  SearchAlerts: InputMaybe<SearchAlert_Arr_Rel_Insert_Input>;
  collectionId: InputMaybe<Scalars['String']>;
  createdAt: InputMaybe<Scalars['timestamp']>;
  customerId: InputMaybe<Scalars['uuid']>;
  id: InputMaybe<Scalars['String']>;
  name: InputMaybe<Scalars['String']>;
  query: InputMaybe<Scalars['String']>;
  resultsUrl: InputMaybe<Scalars['String']>;
  source: InputMaybe<Scalars['String']>;
  updatedAt: InputMaybe<Scalars['timestamp']>;
};

/** aggregate max on columns */
export type SavedSearch_Max_Fields = {
  __typename?: 'SavedSearch_max_fields';
  collectionId: Maybe<Scalars['String']>;
  createdAt: Maybe<Scalars['timestamp']>;
  customerId: Maybe<Scalars['uuid']>;
  id: Maybe<Scalars['String']>;
  name: Maybe<Scalars['String']>;
  query: Maybe<Scalars['String']>;
  resultsUrl: Maybe<Scalars['String']>;
  source: Maybe<Scalars['String']>;
  updatedAt: Maybe<Scalars['timestamp']>;
};

/** aggregate min on columns */
export type SavedSearch_Min_Fields = {
  __typename?: 'SavedSearch_min_fields';
  collectionId: Maybe<Scalars['String']>;
  createdAt: Maybe<Scalars['timestamp']>;
  customerId: Maybe<Scalars['uuid']>;
  id: Maybe<Scalars['String']>;
  name: Maybe<Scalars['String']>;
  query: Maybe<Scalars['String']>;
  resultsUrl: Maybe<Scalars['String']>;
  source: Maybe<Scalars['String']>;
  updatedAt: Maybe<Scalars['timestamp']>;
};

/** response of any mutation on the table "SavedSearch" */
export type SavedSearch_Mutation_Response = {
  __typename?: 'SavedSearch_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<SavedSearch>;
};

/** input type for inserting object relation for remote table "SavedSearch" */
export type SavedSearch_Obj_Rel_Insert_Input = {
  data: SavedSearch_Insert_Input;
  /** upsert condition */
  on_conflict: InputMaybe<SavedSearch_On_Conflict>;
};

/** on_conflict condition type for table "SavedSearch" */
export type SavedSearch_On_Conflict = {
  constraint: SavedSearch_Constraint;
  update_columns: Array<SavedSearch_Update_Column>;
  where: InputMaybe<SavedSearch_Bool_Exp>;
};

/** Ordering options when selecting data from "SavedSearch". */
export type SavedSearch_Order_By = {
  Collection: InputMaybe<Collection_Order_By>;
  Customer: InputMaybe<Customer_Order_By>;
  FacetFilters_aggregate: InputMaybe<FacetFilter_Aggregate_Order_By>;
  NumericFilters_aggregate: InputMaybe<NumericFilter_Aggregate_Order_By>;
  SearchAlerts_aggregate: InputMaybe<SearchAlert_Aggregate_Order_By>;
  collectionId: InputMaybe<Order_By>;
  createdAt: InputMaybe<Order_By>;
  customerId: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  name: InputMaybe<Order_By>;
  query: InputMaybe<Order_By>;
  resultsUrl: InputMaybe<Order_By>;
  source: InputMaybe<Order_By>;
  updatedAt: InputMaybe<Order_By>;
};

/** primary key columns input for table: SavedSearch */
export type SavedSearch_Pk_Columns_Input = {
  id: Scalars['String'];
};

/** select columns of table "SavedSearch" */
export enum SavedSearch_Select_Column {
  /** column name */
  CollectionId = 'collectionId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CustomerId = 'customerId',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Query = 'query',
  /** column name */
  ResultsUrl = 'resultsUrl',
  /** column name */
  Source = 'source',
  /** column name */
  UpdatedAt = 'updatedAt',
}

/** input type for updating data in table "SavedSearch" */
export type SavedSearch_Set_Input = {
  collectionId: InputMaybe<Scalars['String']>;
  createdAt: InputMaybe<Scalars['timestamp']>;
  customerId: InputMaybe<Scalars['uuid']>;
  id: InputMaybe<Scalars['String']>;
  name: InputMaybe<Scalars['String']>;
  query: InputMaybe<Scalars['String']>;
  resultsUrl: InputMaybe<Scalars['String']>;
  source: InputMaybe<Scalars['String']>;
  updatedAt: InputMaybe<Scalars['timestamp']>;
};

/** Streaming cursor of the table "SavedSearch" */
export type SavedSearch_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: SavedSearch_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type SavedSearch_Stream_Cursor_Value_Input = {
  collectionId: InputMaybe<Scalars['String']>;
  createdAt: InputMaybe<Scalars['timestamp']>;
  customerId: InputMaybe<Scalars['uuid']>;
  id: InputMaybe<Scalars['String']>;
  name: InputMaybe<Scalars['String']>;
  query: InputMaybe<Scalars['String']>;
  resultsUrl: InputMaybe<Scalars['String']>;
  source: InputMaybe<Scalars['String']>;
  updatedAt: InputMaybe<Scalars['timestamp']>;
};

/** update columns of table "SavedSearch" */
export enum SavedSearch_Update_Column {
  /** column name */
  CollectionId = 'collectionId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CustomerId = 'customerId',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Query = 'query',
  /** column name */
  ResultsUrl = 'resultsUrl',
  /** column name */
  Source = 'source',
  /** column name */
  UpdatedAt = 'updatedAt',
}

export type SavedSearch_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<SavedSearch_Set_Input>;
  /** filter the rows which have to be updated */
  where: SavedSearch_Bool_Exp;
};

/** columns and relationships of "SearchAlert" */
export type SearchAlert = {
  __typename?: 'SearchAlert';
  /** An object relationship */
  SavedSearch: SavedSearch;
  id: Scalars['String'];
  isActive: Scalars['Boolean'];
  latestResultsCount: Maybe<Scalars['Int']>;
  latestRunAt: Maybe<Scalars['timestamp']>;
  searchId: Scalars['String'];
};

/** aggregated selection of "SearchAlert" */
export type SearchAlert_Aggregate = {
  __typename?: 'SearchAlert_aggregate';
  aggregate: Maybe<SearchAlert_Aggregate_Fields>;
  nodes: Array<SearchAlert>;
};

export type SearchAlert_Aggregate_Bool_Exp = {
  bool_and: InputMaybe<SearchAlert_Aggregate_Bool_Exp_Bool_And>;
  bool_or: InputMaybe<SearchAlert_Aggregate_Bool_Exp_Bool_Or>;
  count: InputMaybe<SearchAlert_Aggregate_Bool_Exp_Count>;
};

export type SearchAlert_Aggregate_Bool_Exp_Bool_And = {
  arguments: SearchAlert_Select_Column_SearchAlert_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<SearchAlert_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type SearchAlert_Aggregate_Bool_Exp_Bool_Or = {
  arguments: SearchAlert_Select_Column_SearchAlert_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<SearchAlert_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type SearchAlert_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<SearchAlert_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<SearchAlert_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "SearchAlert" */
export type SearchAlert_Aggregate_Fields = {
  __typename?: 'SearchAlert_aggregate_fields';
  avg: Maybe<SearchAlert_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<SearchAlert_Max_Fields>;
  min: Maybe<SearchAlert_Min_Fields>;
  stddev: Maybe<SearchAlert_Stddev_Fields>;
  stddev_pop: Maybe<SearchAlert_Stddev_Pop_Fields>;
  stddev_samp: Maybe<SearchAlert_Stddev_Samp_Fields>;
  sum: Maybe<SearchAlert_Sum_Fields>;
  var_pop: Maybe<SearchAlert_Var_Pop_Fields>;
  var_samp: Maybe<SearchAlert_Var_Samp_Fields>;
  variance: Maybe<SearchAlert_Variance_Fields>;
};

/** aggregate fields of "SearchAlert" */
export type SearchAlert_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<SearchAlert_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "SearchAlert" */
export type SearchAlert_Aggregate_Order_By = {
  avg: InputMaybe<SearchAlert_Avg_Order_By>;
  count: InputMaybe<Order_By>;
  max: InputMaybe<SearchAlert_Max_Order_By>;
  min: InputMaybe<SearchAlert_Min_Order_By>;
  stddev: InputMaybe<SearchAlert_Stddev_Order_By>;
  stddev_pop: InputMaybe<SearchAlert_Stddev_Pop_Order_By>;
  stddev_samp: InputMaybe<SearchAlert_Stddev_Samp_Order_By>;
  sum: InputMaybe<SearchAlert_Sum_Order_By>;
  var_pop: InputMaybe<SearchAlert_Var_Pop_Order_By>;
  var_samp: InputMaybe<SearchAlert_Var_Samp_Order_By>;
  variance: InputMaybe<SearchAlert_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "SearchAlert" */
export type SearchAlert_Arr_Rel_Insert_Input = {
  data: Array<SearchAlert_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<SearchAlert_On_Conflict>;
};

/** aggregate avg on columns */
export type SearchAlert_Avg_Fields = {
  __typename?: 'SearchAlert_avg_fields';
  latestResultsCount: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "SearchAlert" */
export type SearchAlert_Avg_Order_By = {
  latestResultsCount: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "SearchAlert". All fields are combined with a logical 'AND'. */
export type SearchAlert_Bool_Exp = {
  SavedSearch: InputMaybe<SavedSearch_Bool_Exp>;
  _and: InputMaybe<Array<SearchAlert_Bool_Exp>>;
  _not: InputMaybe<SearchAlert_Bool_Exp>;
  _or: InputMaybe<Array<SearchAlert_Bool_Exp>>;
  id: InputMaybe<String_Comparison_Exp>;
  isActive: InputMaybe<Boolean_Comparison_Exp>;
  latestResultsCount: InputMaybe<Int_Comparison_Exp>;
  latestRunAt: InputMaybe<Timestamp_Comparison_Exp>;
  searchId: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "SearchAlert" */
export enum SearchAlert_Constraint {
  /** unique or primary key constraint on columns "id" */
  SearchAlertPkey = 'SearchAlert_pkey',
}

/** input type for incrementing numeric columns in table "SearchAlert" */
export type SearchAlert_Inc_Input = {
  latestResultsCount: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "SearchAlert" */
export type SearchAlert_Insert_Input = {
  SavedSearch: InputMaybe<SavedSearch_Obj_Rel_Insert_Input>;
  id: InputMaybe<Scalars['String']>;
  isActive: InputMaybe<Scalars['Boolean']>;
  latestResultsCount: InputMaybe<Scalars['Int']>;
  latestRunAt: InputMaybe<Scalars['timestamp']>;
  searchId: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type SearchAlert_Max_Fields = {
  __typename?: 'SearchAlert_max_fields';
  id: Maybe<Scalars['String']>;
  latestResultsCount: Maybe<Scalars['Int']>;
  latestRunAt: Maybe<Scalars['timestamp']>;
  searchId: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "SearchAlert" */
export type SearchAlert_Max_Order_By = {
  id: InputMaybe<Order_By>;
  latestResultsCount: InputMaybe<Order_By>;
  latestRunAt: InputMaybe<Order_By>;
  searchId: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type SearchAlert_Min_Fields = {
  __typename?: 'SearchAlert_min_fields';
  id: Maybe<Scalars['String']>;
  latestResultsCount: Maybe<Scalars['Int']>;
  latestRunAt: Maybe<Scalars['timestamp']>;
  searchId: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "SearchAlert" */
export type SearchAlert_Min_Order_By = {
  id: InputMaybe<Order_By>;
  latestResultsCount: InputMaybe<Order_By>;
  latestRunAt: InputMaybe<Order_By>;
  searchId: InputMaybe<Order_By>;
};

/** response of any mutation on the table "SearchAlert" */
export type SearchAlert_Mutation_Response = {
  __typename?: 'SearchAlert_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<SearchAlert>;
};

/** on_conflict condition type for table "SearchAlert" */
export type SearchAlert_On_Conflict = {
  constraint: SearchAlert_Constraint;
  update_columns: Array<SearchAlert_Update_Column>;
  where: InputMaybe<SearchAlert_Bool_Exp>;
};

/** Ordering options when selecting data from "SearchAlert". */
export type SearchAlert_Order_By = {
  SavedSearch: InputMaybe<SavedSearch_Order_By>;
  id: InputMaybe<Order_By>;
  isActive: InputMaybe<Order_By>;
  latestResultsCount: InputMaybe<Order_By>;
  latestRunAt: InputMaybe<Order_By>;
  searchId: InputMaybe<Order_By>;
};

/** primary key columns input for table: SearchAlert */
export type SearchAlert_Pk_Columns_Input = {
  id: Scalars['String'];
};

/** select columns of table "SearchAlert" */
export enum SearchAlert_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  IsActive = 'isActive',
  /** column name */
  LatestResultsCount = 'latestResultsCount',
  /** column name */
  LatestRunAt = 'latestRunAt',
  /** column name */
  SearchId = 'searchId',
}

/** select "SearchAlert_aggregate_bool_exp_bool_and_arguments_columns" columns of table "SearchAlert" */
export enum SearchAlert_Select_Column_SearchAlert_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  IsActive = 'isActive',
}

/** select "SearchAlert_aggregate_bool_exp_bool_or_arguments_columns" columns of table "SearchAlert" */
export enum SearchAlert_Select_Column_SearchAlert_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  IsActive = 'isActive',
}

/** input type for updating data in table "SearchAlert" */
export type SearchAlert_Set_Input = {
  id: InputMaybe<Scalars['String']>;
  isActive: InputMaybe<Scalars['Boolean']>;
  latestResultsCount: InputMaybe<Scalars['Int']>;
  latestRunAt: InputMaybe<Scalars['timestamp']>;
  searchId: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type SearchAlert_Stddev_Fields = {
  __typename?: 'SearchAlert_stddev_fields';
  latestResultsCount: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "SearchAlert" */
export type SearchAlert_Stddev_Order_By = {
  latestResultsCount: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type SearchAlert_Stddev_Pop_Fields = {
  __typename?: 'SearchAlert_stddev_pop_fields';
  latestResultsCount: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "SearchAlert" */
export type SearchAlert_Stddev_Pop_Order_By = {
  latestResultsCount: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type SearchAlert_Stddev_Samp_Fields = {
  __typename?: 'SearchAlert_stddev_samp_fields';
  latestResultsCount: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "SearchAlert" */
export type SearchAlert_Stddev_Samp_Order_By = {
  latestResultsCount: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "SearchAlert" */
export type SearchAlert_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: SearchAlert_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type SearchAlert_Stream_Cursor_Value_Input = {
  id: InputMaybe<Scalars['String']>;
  isActive: InputMaybe<Scalars['Boolean']>;
  latestResultsCount: InputMaybe<Scalars['Int']>;
  latestRunAt: InputMaybe<Scalars['timestamp']>;
  searchId: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type SearchAlert_Sum_Fields = {
  __typename?: 'SearchAlert_sum_fields';
  latestResultsCount: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "SearchAlert" */
export type SearchAlert_Sum_Order_By = {
  latestResultsCount: InputMaybe<Order_By>;
};

/** update columns of table "SearchAlert" */
export enum SearchAlert_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  IsActive = 'isActive',
  /** column name */
  LatestResultsCount = 'latestResultsCount',
  /** column name */
  LatestRunAt = 'latestRunAt',
  /** column name */
  SearchId = 'searchId',
}

export type SearchAlert_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<SearchAlert_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<SearchAlert_Set_Input>;
  /** filter the rows which have to be updated */
  where: SearchAlert_Bool_Exp;
};

/** aggregate var_pop on columns */
export type SearchAlert_Var_Pop_Fields = {
  __typename?: 'SearchAlert_var_pop_fields';
  latestResultsCount: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "SearchAlert" */
export type SearchAlert_Var_Pop_Order_By = {
  latestResultsCount: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type SearchAlert_Var_Samp_Fields = {
  __typename?: 'SearchAlert_var_samp_fields';
  latestResultsCount: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "SearchAlert" */
export type SearchAlert_Var_Samp_Order_By = {
  latestResultsCount: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type SearchAlert_Variance_Fields = {
  __typename?: 'SearchAlert_variance_fields';
  latestResultsCount: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "SearchAlert" */
export type SearchAlert_Variance_Order_By = {
  latestResultsCount: InputMaybe<Order_By>;
};

/** Boolean expression to compare columns of type "ShipmentTimeframe". All fields are combined with logical 'AND'. */
export type ShipmentTimeframe_Comparison_Exp = {
  _eq: InputMaybe<Scalars['ShipmentTimeframe']>;
  _gt: InputMaybe<Scalars['ShipmentTimeframe']>;
  _gte: InputMaybe<Scalars['ShipmentTimeframe']>;
  _in: InputMaybe<Array<Scalars['ShipmentTimeframe']>>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  _lt: InputMaybe<Scalars['ShipmentTimeframe']>;
  _lte: InputMaybe<Scalars['ShipmentTimeframe']>;
  _neq: InputMaybe<Scalars['ShipmentTimeframe']>;
  _nin: InputMaybe<Array<Scalars['ShipmentTimeframe']>>;
};

/** Boolean expression to compare columns of type "ShippingSolution". All fields are combined with logical 'AND'. */
export type ShippingSolution_Comparison_Exp = {
  _eq: InputMaybe<Scalars['ShippingSolution']>;
  _gt: InputMaybe<Scalars['ShippingSolution']>;
  _gte: InputMaybe<Scalars['ShippingSolution']>;
  _in: InputMaybe<Array<Scalars['ShippingSolution']>>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  _lt: InputMaybe<Scalars['ShippingSolution']>;
  _lte: InputMaybe<Scalars['ShippingSolution']>;
  _neq: InputMaybe<Scalars['ShippingSolution']>;
  _nin: InputMaybe<Array<Scalars['ShippingSolution']>>;
};

/** Boolean expression to compare columns of type "ShippingType". All fields are combined with logical 'AND'. */
export type ShippingType_Comparison_Exp = {
  _eq: InputMaybe<Scalars['ShippingType']>;
  _gt: InputMaybe<Scalars['ShippingType']>;
  _gte: InputMaybe<Scalars['ShippingType']>;
  _in: InputMaybe<Array<Scalars['ShippingType']>>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  _lt: InputMaybe<Scalars['ShippingType']>;
  _lte: InputMaybe<Scalars['ShippingType']>;
  _neq: InputMaybe<Scalars['ShippingType']>;
  _nin: InputMaybe<Array<Scalars['ShippingType']>>;
};

/** Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'. */
export type String_Comparison_Exp = {
  _eq: InputMaybe<Scalars['String']>;
  _gt: InputMaybe<Scalars['String']>;
  _gte: InputMaybe<Scalars['String']>;
  /** does the column match the given case-insensitive pattern */
  _ilike: InputMaybe<Scalars['String']>;
  _in: InputMaybe<Array<Scalars['String']>>;
  /** does the column match the given POSIX regular expression, case insensitive */
  _iregex: InputMaybe<Scalars['String']>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  /** does the column match the given pattern */
  _like: InputMaybe<Scalars['String']>;
  _lt: InputMaybe<Scalars['String']>;
  _lte: InputMaybe<Scalars['String']>;
  _neq: InputMaybe<Scalars['String']>;
  /** does the column NOT match the given case-insensitive pattern */
  _nilike: InputMaybe<Scalars['String']>;
  _nin: InputMaybe<Array<Scalars['String']>>;
  /** does the column NOT match the given POSIX regular expression, case insensitive */
  _niregex: InputMaybe<Scalars['String']>;
  /** does the column NOT match the given pattern */
  _nlike: InputMaybe<Scalars['String']>;
  /** does the column NOT match the given POSIX regular expression, case sensitive */
  _nregex: InputMaybe<Scalars['String']>;
  /** does the column NOT match the given SQL regular expression */
  _nsimilar: InputMaybe<Scalars['String']>;
  /** does the column match the given POSIX regular expression, case sensitive */
  _regex: InputMaybe<Scalars['String']>;
  /** does the column match the given SQL regular expression */
  _similar: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "VendorProCategoryMapping" */
export type VendorProCategoryMapping = {
  __typename?: 'VendorProCategoryMapping';
  createdAt: Scalars['timestamp'];
  externalCategoryId: Maybe<Scalars['String']>;
  externalCategoryName: Maybe<Scalars['String']>;
  id: Scalars['String'];
  internalCategoryName: Maybe<Scalars['String']>;
  mappingKey: Scalars['String'];
  metadata: Maybe<Scalars['jsonb']>;
  updatedAt: Maybe<Scalars['timestamp']>;
};

/** columns and relationships of "VendorProCategoryMapping" */
export type VendorProCategoryMappingMetadataArgs = {
  path: InputMaybe<Scalars['String']>;
};

/** aggregated selection of "VendorProCategoryMapping" */
export type VendorProCategoryMapping_Aggregate = {
  __typename?: 'VendorProCategoryMapping_aggregate';
  aggregate: Maybe<VendorProCategoryMapping_Aggregate_Fields>;
  nodes: Array<VendorProCategoryMapping>;
};

/** aggregate fields of "VendorProCategoryMapping" */
export type VendorProCategoryMapping_Aggregate_Fields = {
  __typename?: 'VendorProCategoryMapping_aggregate_fields';
  count: Scalars['Int'];
  max: Maybe<VendorProCategoryMapping_Max_Fields>;
  min: Maybe<VendorProCategoryMapping_Min_Fields>;
};

/** aggregate fields of "VendorProCategoryMapping" */
export type VendorProCategoryMapping_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<VendorProCategoryMapping_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type VendorProCategoryMapping_Append_Input = {
  metadata: InputMaybe<Scalars['jsonb']>;
};

/** Boolean expression to filter rows from the table "VendorProCategoryMapping". All fields are combined with a logical 'AND'. */
export type VendorProCategoryMapping_Bool_Exp = {
  _and: InputMaybe<Array<VendorProCategoryMapping_Bool_Exp>>;
  _not: InputMaybe<VendorProCategoryMapping_Bool_Exp>;
  _or: InputMaybe<Array<VendorProCategoryMapping_Bool_Exp>>;
  createdAt: InputMaybe<Timestamp_Comparison_Exp>;
  externalCategoryId: InputMaybe<String_Comparison_Exp>;
  externalCategoryName: InputMaybe<String_Comparison_Exp>;
  id: InputMaybe<String_Comparison_Exp>;
  internalCategoryName: InputMaybe<String_Comparison_Exp>;
  mappingKey: InputMaybe<String_Comparison_Exp>;
  metadata: InputMaybe<Jsonb_Comparison_Exp>;
  updatedAt: InputMaybe<Timestamp_Comparison_Exp>;
};

/** unique or primary key constraints on table "VendorProCategoryMapping" */
export enum VendorProCategoryMapping_Constraint {
  /** unique or primary key constraint on columns "id" */
  VendorProCategoryMappingPkey = 'VendorProCategoryMapping_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type VendorProCategoryMapping_Delete_At_Path_Input = {
  metadata: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type VendorProCategoryMapping_Delete_Elem_Input = {
  metadata: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type VendorProCategoryMapping_Delete_Key_Input = {
  metadata: InputMaybe<Scalars['String']>;
};

/** input type for inserting data into table "VendorProCategoryMapping" */
export type VendorProCategoryMapping_Insert_Input = {
  createdAt: InputMaybe<Scalars['timestamp']>;
  externalCategoryId: InputMaybe<Scalars['String']>;
  externalCategoryName: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  internalCategoryName: InputMaybe<Scalars['String']>;
  mappingKey: InputMaybe<Scalars['String']>;
  metadata: InputMaybe<Scalars['jsonb']>;
  updatedAt: InputMaybe<Scalars['timestamp']>;
};

/** aggregate max on columns */
export type VendorProCategoryMapping_Max_Fields = {
  __typename?: 'VendorProCategoryMapping_max_fields';
  createdAt: Maybe<Scalars['timestamp']>;
  externalCategoryId: Maybe<Scalars['String']>;
  externalCategoryName: Maybe<Scalars['String']>;
  id: Maybe<Scalars['String']>;
  internalCategoryName: Maybe<Scalars['String']>;
  mappingKey: Maybe<Scalars['String']>;
  updatedAt: Maybe<Scalars['timestamp']>;
};

/** aggregate min on columns */
export type VendorProCategoryMapping_Min_Fields = {
  __typename?: 'VendorProCategoryMapping_min_fields';
  createdAt: Maybe<Scalars['timestamp']>;
  externalCategoryId: Maybe<Scalars['String']>;
  externalCategoryName: Maybe<Scalars['String']>;
  id: Maybe<Scalars['String']>;
  internalCategoryName: Maybe<Scalars['String']>;
  mappingKey: Maybe<Scalars['String']>;
  updatedAt: Maybe<Scalars['timestamp']>;
};

/** response of any mutation on the table "VendorProCategoryMapping" */
export type VendorProCategoryMapping_Mutation_Response = {
  __typename?: 'VendorProCategoryMapping_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<VendorProCategoryMapping>;
};

/** on_conflict condition type for table "VendorProCategoryMapping" */
export type VendorProCategoryMapping_On_Conflict = {
  constraint: VendorProCategoryMapping_Constraint;
  update_columns: Array<VendorProCategoryMapping_Update_Column>;
  where: InputMaybe<VendorProCategoryMapping_Bool_Exp>;
};

/** Ordering options when selecting data from "VendorProCategoryMapping". */
export type VendorProCategoryMapping_Order_By = {
  createdAt: InputMaybe<Order_By>;
  externalCategoryId: InputMaybe<Order_By>;
  externalCategoryName: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  internalCategoryName: InputMaybe<Order_By>;
  mappingKey: InputMaybe<Order_By>;
  metadata: InputMaybe<Order_By>;
  updatedAt: InputMaybe<Order_By>;
};

/** primary key columns input for table: VendorProCategoryMapping */
export type VendorProCategoryMapping_Pk_Columns_Input = {
  id: Scalars['String'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type VendorProCategoryMapping_Prepend_Input = {
  metadata: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "VendorProCategoryMapping" */
export enum VendorProCategoryMapping_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  ExternalCategoryId = 'externalCategoryId',
  /** column name */
  ExternalCategoryName = 'externalCategoryName',
  /** column name */
  Id = 'id',
  /** column name */
  InternalCategoryName = 'internalCategoryName',
  /** column name */
  MappingKey = 'mappingKey',
  /** column name */
  Metadata = 'metadata',
  /** column name */
  UpdatedAt = 'updatedAt',
}

/** input type for updating data in table "VendorProCategoryMapping" */
export type VendorProCategoryMapping_Set_Input = {
  createdAt: InputMaybe<Scalars['timestamp']>;
  externalCategoryId: InputMaybe<Scalars['String']>;
  externalCategoryName: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  internalCategoryName: InputMaybe<Scalars['String']>;
  mappingKey: InputMaybe<Scalars['String']>;
  metadata: InputMaybe<Scalars['jsonb']>;
  updatedAt: InputMaybe<Scalars['timestamp']>;
};

/** Streaming cursor of the table "VendorProCategoryMapping" */
export type VendorProCategoryMapping_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: VendorProCategoryMapping_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type VendorProCategoryMapping_Stream_Cursor_Value_Input = {
  createdAt: InputMaybe<Scalars['timestamp']>;
  externalCategoryId: InputMaybe<Scalars['String']>;
  externalCategoryName: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  internalCategoryName: InputMaybe<Scalars['String']>;
  mappingKey: InputMaybe<Scalars['String']>;
  metadata: InputMaybe<Scalars['jsonb']>;
  updatedAt: InputMaybe<Scalars['timestamp']>;
};

/** update columns of table "VendorProCategoryMapping" */
export enum VendorProCategoryMapping_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  ExternalCategoryId = 'externalCategoryId',
  /** column name */
  ExternalCategoryName = 'externalCategoryName',
  /** column name */
  Id = 'id',
  /** column name */
  InternalCategoryName = 'internalCategoryName',
  /** column name */
  MappingKey = 'mappingKey',
  /** column name */
  Metadata = 'metadata',
  /** column name */
  UpdatedAt = 'updatedAt',
}

export type VendorProCategoryMapping_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append: InputMaybe<VendorProCategoryMapping_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path: InputMaybe<VendorProCategoryMapping_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem: InputMaybe<VendorProCategoryMapping_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key: InputMaybe<VendorProCategoryMapping_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend: InputMaybe<VendorProCategoryMapping_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<VendorProCategoryMapping_Set_Input>;
  /** filter the rows which have to be updated */
  where: VendorProCategoryMapping_Bool_Exp;
};

/** columns and relationships of "VendorProTagMapping" */
export type VendorProTagMapping = {
  __typename?: 'VendorProTagMapping';
  createdAt: Scalars['timestamp'];
  externalTagId: Maybe<Scalars['String']>;
  externalTagName: Scalars['String'];
  id: Scalars['String'];
  internalTagName: Maybe<Scalars['String']>;
  mappingKey: Scalars['String'];
  updatedAt: Maybe<Scalars['timestamp']>;
  useDefaultTagValues: Scalars['Boolean'];
};

/** aggregated selection of "VendorProTagMapping" */
export type VendorProTagMapping_Aggregate = {
  __typename?: 'VendorProTagMapping_aggregate';
  aggregate: Maybe<VendorProTagMapping_Aggregate_Fields>;
  nodes: Array<VendorProTagMapping>;
};

/** aggregate fields of "VendorProTagMapping" */
export type VendorProTagMapping_Aggregate_Fields = {
  __typename?: 'VendorProTagMapping_aggregate_fields';
  count: Scalars['Int'];
  max: Maybe<VendorProTagMapping_Max_Fields>;
  min: Maybe<VendorProTagMapping_Min_Fields>;
};

/** aggregate fields of "VendorProTagMapping" */
export type VendorProTagMapping_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<VendorProTagMapping_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "VendorProTagMapping". All fields are combined with a logical 'AND'. */
export type VendorProTagMapping_Bool_Exp = {
  _and: InputMaybe<Array<VendorProTagMapping_Bool_Exp>>;
  _not: InputMaybe<VendorProTagMapping_Bool_Exp>;
  _or: InputMaybe<Array<VendorProTagMapping_Bool_Exp>>;
  createdAt: InputMaybe<Timestamp_Comparison_Exp>;
  externalTagId: InputMaybe<String_Comparison_Exp>;
  externalTagName: InputMaybe<String_Comparison_Exp>;
  id: InputMaybe<String_Comparison_Exp>;
  internalTagName: InputMaybe<String_Comparison_Exp>;
  mappingKey: InputMaybe<String_Comparison_Exp>;
  updatedAt: InputMaybe<Timestamp_Comparison_Exp>;
  useDefaultTagValues: InputMaybe<Boolean_Comparison_Exp>;
};

/** unique or primary key constraints on table "VendorProTagMapping" */
export enum VendorProTagMapping_Constraint {
  /** unique or primary key constraint on columns "id" */
  VendorProTagMappingPkey = 'VendorProTagMapping_pkey',
}

/** input type for inserting data into table "VendorProTagMapping" */
export type VendorProTagMapping_Insert_Input = {
  createdAt: InputMaybe<Scalars['timestamp']>;
  externalTagId: InputMaybe<Scalars['String']>;
  externalTagName: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  internalTagName: InputMaybe<Scalars['String']>;
  mappingKey: InputMaybe<Scalars['String']>;
  updatedAt: InputMaybe<Scalars['timestamp']>;
  useDefaultTagValues: InputMaybe<Scalars['Boolean']>;
};

/** aggregate max on columns */
export type VendorProTagMapping_Max_Fields = {
  __typename?: 'VendorProTagMapping_max_fields';
  createdAt: Maybe<Scalars['timestamp']>;
  externalTagId: Maybe<Scalars['String']>;
  externalTagName: Maybe<Scalars['String']>;
  id: Maybe<Scalars['String']>;
  internalTagName: Maybe<Scalars['String']>;
  mappingKey: Maybe<Scalars['String']>;
  updatedAt: Maybe<Scalars['timestamp']>;
};

/** aggregate min on columns */
export type VendorProTagMapping_Min_Fields = {
  __typename?: 'VendorProTagMapping_min_fields';
  createdAt: Maybe<Scalars['timestamp']>;
  externalTagId: Maybe<Scalars['String']>;
  externalTagName: Maybe<Scalars['String']>;
  id: Maybe<Scalars['String']>;
  internalTagName: Maybe<Scalars['String']>;
  mappingKey: Maybe<Scalars['String']>;
  updatedAt: Maybe<Scalars['timestamp']>;
};

/** response of any mutation on the table "VendorProTagMapping" */
export type VendorProTagMapping_Mutation_Response = {
  __typename?: 'VendorProTagMapping_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<VendorProTagMapping>;
};

/** on_conflict condition type for table "VendorProTagMapping" */
export type VendorProTagMapping_On_Conflict = {
  constraint: VendorProTagMapping_Constraint;
  update_columns: Array<VendorProTagMapping_Update_Column>;
  where: InputMaybe<VendorProTagMapping_Bool_Exp>;
};

/** Ordering options when selecting data from "VendorProTagMapping". */
export type VendorProTagMapping_Order_By = {
  createdAt: InputMaybe<Order_By>;
  externalTagId: InputMaybe<Order_By>;
  externalTagName: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  internalTagName: InputMaybe<Order_By>;
  mappingKey: InputMaybe<Order_By>;
  updatedAt: InputMaybe<Order_By>;
  useDefaultTagValues: InputMaybe<Order_By>;
};

/** primary key columns input for table: VendorProTagMapping */
export type VendorProTagMapping_Pk_Columns_Input = {
  id: Scalars['String'];
};

/** select columns of table "VendorProTagMapping" */
export enum VendorProTagMapping_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  ExternalTagId = 'externalTagId',
  /** column name */
  ExternalTagName = 'externalTagName',
  /** column name */
  Id = 'id',
  /** column name */
  InternalTagName = 'internalTagName',
  /** column name */
  MappingKey = 'mappingKey',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UseDefaultTagValues = 'useDefaultTagValues',
}

/** input type for updating data in table "VendorProTagMapping" */
export type VendorProTagMapping_Set_Input = {
  createdAt: InputMaybe<Scalars['timestamp']>;
  externalTagId: InputMaybe<Scalars['String']>;
  externalTagName: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  internalTagName: InputMaybe<Scalars['String']>;
  mappingKey: InputMaybe<Scalars['String']>;
  updatedAt: InputMaybe<Scalars['timestamp']>;
  useDefaultTagValues: InputMaybe<Scalars['Boolean']>;
};

/** Streaming cursor of the table "VendorProTagMapping" */
export type VendorProTagMapping_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: VendorProTagMapping_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type VendorProTagMapping_Stream_Cursor_Value_Input = {
  createdAt: InputMaybe<Scalars['timestamp']>;
  externalTagId: InputMaybe<Scalars['String']>;
  externalTagName: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  internalTagName: InputMaybe<Scalars['String']>;
  mappingKey: InputMaybe<Scalars['String']>;
  updatedAt: InputMaybe<Scalars['timestamp']>;
  useDefaultTagValues: InputMaybe<Scalars['Boolean']>;
};

/** update columns of table "VendorProTagMapping" */
export enum VendorProTagMapping_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  ExternalTagId = 'externalTagId',
  /** column name */
  ExternalTagName = 'externalTagName',
  /** column name */
  Id = 'id',
  /** column name */
  InternalTagName = 'internalTagName',
  /** column name */
  MappingKey = 'mappingKey',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UseDefaultTagValues = 'useDefaultTagValues',
}

export type VendorProTagMapping_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<VendorProTagMapping_Set_Input>;
  /** filter the rows which have to be updated */
  where: VendorProTagMapping_Bool_Exp;
};

/** columns and relationships of "VendorProTagValueMapping" */
export type VendorProTagValueMapping = {
  __typename?: 'VendorProTagValueMapping';
  createdAt: Scalars['timestamp'];
  externalTagName: Scalars['String'];
  externalTagValue: Scalars['String'];
  externalTagValueId: Maybe<Scalars['String']>;
  id: Scalars['String'];
  internalTagValue: Maybe<Scalars['String']>;
  mappingKey: Scalars['String'];
  metadata: Maybe<Scalars['jsonb']>;
  updatedAt: Maybe<Scalars['timestamp']>;
};

/** columns and relationships of "VendorProTagValueMapping" */
export type VendorProTagValueMappingMetadataArgs = {
  path: InputMaybe<Scalars['String']>;
};

/** aggregated selection of "VendorProTagValueMapping" */
export type VendorProTagValueMapping_Aggregate = {
  __typename?: 'VendorProTagValueMapping_aggregate';
  aggregate: Maybe<VendorProTagValueMapping_Aggregate_Fields>;
  nodes: Array<VendorProTagValueMapping>;
};

/** aggregate fields of "VendorProTagValueMapping" */
export type VendorProTagValueMapping_Aggregate_Fields = {
  __typename?: 'VendorProTagValueMapping_aggregate_fields';
  count: Scalars['Int'];
  max: Maybe<VendorProTagValueMapping_Max_Fields>;
  min: Maybe<VendorProTagValueMapping_Min_Fields>;
};

/** aggregate fields of "VendorProTagValueMapping" */
export type VendorProTagValueMapping_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<VendorProTagValueMapping_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type VendorProTagValueMapping_Append_Input = {
  metadata: InputMaybe<Scalars['jsonb']>;
};

/** Boolean expression to filter rows from the table "VendorProTagValueMapping". All fields are combined with a logical 'AND'. */
export type VendorProTagValueMapping_Bool_Exp = {
  _and: InputMaybe<Array<VendorProTagValueMapping_Bool_Exp>>;
  _not: InputMaybe<VendorProTagValueMapping_Bool_Exp>;
  _or: InputMaybe<Array<VendorProTagValueMapping_Bool_Exp>>;
  createdAt: InputMaybe<Timestamp_Comparison_Exp>;
  externalTagName: InputMaybe<String_Comparison_Exp>;
  externalTagValue: InputMaybe<String_Comparison_Exp>;
  externalTagValueId: InputMaybe<String_Comparison_Exp>;
  id: InputMaybe<String_Comparison_Exp>;
  internalTagValue: InputMaybe<String_Comparison_Exp>;
  mappingKey: InputMaybe<String_Comparison_Exp>;
  metadata: InputMaybe<Jsonb_Comparison_Exp>;
  updatedAt: InputMaybe<Timestamp_Comparison_Exp>;
};

/** unique or primary key constraints on table "VendorProTagValueMapping" */
export enum VendorProTagValueMapping_Constraint {
  /** unique or primary key constraint on columns "id" */
  VendorProTagValueMappingPkey = 'VendorProTagValueMapping_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type VendorProTagValueMapping_Delete_At_Path_Input = {
  metadata: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type VendorProTagValueMapping_Delete_Elem_Input = {
  metadata: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type VendorProTagValueMapping_Delete_Key_Input = {
  metadata: InputMaybe<Scalars['String']>;
};

/** input type for inserting data into table "VendorProTagValueMapping" */
export type VendorProTagValueMapping_Insert_Input = {
  createdAt: InputMaybe<Scalars['timestamp']>;
  externalTagName: InputMaybe<Scalars['String']>;
  externalTagValue: InputMaybe<Scalars['String']>;
  externalTagValueId: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  internalTagValue: InputMaybe<Scalars['String']>;
  mappingKey: InputMaybe<Scalars['String']>;
  metadata: InputMaybe<Scalars['jsonb']>;
  updatedAt: InputMaybe<Scalars['timestamp']>;
};

/** aggregate max on columns */
export type VendorProTagValueMapping_Max_Fields = {
  __typename?: 'VendorProTagValueMapping_max_fields';
  createdAt: Maybe<Scalars['timestamp']>;
  externalTagName: Maybe<Scalars['String']>;
  externalTagValue: Maybe<Scalars['String']>;
  externalTagValueId: Maybe<Scalars['String']>;
  id: Maybe<Scalars['String']>;
  internalTagValue: Maybe<Scalars['String']>;
  mappingKey: Maybe<Scalars['String']>;
  updatedAt: Maybe<Scalars['timestamp']>;
};

/** aggregate min on columns */
export type VendorProTagValueMapping_Min_Fields = {
  __typename?: 'VendorProTagValueMapping_min_fields';
  createdAt: Maybe<Scalars['timestamp']>;
  externalTagName: Maybe<Scalars['String']>;
  externalTagValue: Maybe<Scalars['String']>;
  externalTagValueId: Maybe<Scalars['String']>;
  id: Maybe<Scalars['String']>;
  internalTagValue: Maybe<Scalars['String']>;
  mappingKey: Maybe<Scalars['String']>;
  updatedAt: Maybe<Scalars['timestamp']>;
};

/** response of any mutation on the table "VendorProTagValueMapping" */
export type VendorProTagValueMapping_Mutation_Response = {
  __typename?: 'VendorProTagValueMapping_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<VendorProTagValueMapping>;
};

/** on_conflict condition type for table "VendorProTagValueMapping" */
export type VendorProTagValueMapping_On_Conflict = {
  constraint: VendorProTagValueMapping_Constraint;
  update_columns: Array<VendorProTagValueMapping_Update_Column>;
  where: InputMaybe<VendorProTagValueMapping_Bool_Exp>;
};

/** Ordering options when selecting data from "VendorProTagValueMapping". */
export type VendorProTagValueMapping_Order_By = {
  createdAt: InputMaybe<Order_By>;
  externalTagName: InputMaybe<Order_By>;
  externalTagValue: InputMaybe<Order_By>;
  externalTagValueId: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  internalTagValue: InputMaybe<Order_By>;
  mappingKey: InputMaybe<Order_By>;
  metadata: InputMaybe<Order_By>;
  updatedAt: InputMaybe<Order_By>;
};

/** primary key columns input for table: VendorProTagValueMapping */
export type VendorProTagValueMapping_Pk_Columns_Input = {
  id: Scalars['String'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type VendorProTagValueMapping_Prepend_Input = {
  metadata: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "VendorProTagValueMapping" */
export enum VendorProTagValueMapping_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  ExternalTagName = 'externalTagName',
  /** column name */
  ExternalTagValue = 'externalTagValue',
  /** column name */
  ExternalTagValueId = 'externalTagValueId',
  /** column name */
  Id = 'id',
  /** column name */
  InternalTagValue = 'internalTagValue',
  /** column name */
  MappingKey = 'mappingKey',
  /** column name */
  Metadata = 'metadata',
  /** column name */
  UpdatedAt = 'updatedAt',
}

/** input type for updating data in table "VendorProTagValueMapping" */
export type VendorProTagValueMapping_Set_Input = {
  createdAt: InputMaybe<Scalars['timestamp']>;
  externalTagName: InputMaybe<Scalars['String']>;
  externalTagValue: InputMaybe<Scalars['String']>;
  externalTagValueId: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  internalTagValue: InputMaybe<Scalars['String']>;
  mappingKey: InputMaybe<Scalars['String']>;
  metadata: InputMaybe<Scalars['jsonb']>;
  updatedAt: InputMaybe<Scalars['timestamp']>;
};

/** Streaming cursor of the table "VendorProTagValueMapping" */
export type VendorProTagValueMapping_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: VendorProTagValueMapping_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type VendorProTagValueMapping_Stream_Cursor_Value_Input = {
  createdAt: InputMaybe<Scalars['timestamp']>;
  externalTagName: InputMaybe<Scalars['String']>;
  externalTagValue: InputMaybe<Scalars['String']>;
  externalTagValueId: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  internalTagValue: InputMaybe<Scalars['String']>;
  mappingKey: InputMaybe<Scalars['String']>;
  metadata: InputMaybe<Scalars['jsonb']>;
  updatedAt: InputMaybe<Scalars['timestamp']>;
};

/** update columns of table "VendorProTagValueMapping" */
export enum VendorProTagValueMapping_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  ExternalTagName = 'externalTagName',
  /** column name */
  ExternalTagValue = 'externalTagValue',
  /** column name */
  ExternalTagValueId = 'externalTagValueId',
  /** column name */
  Id = 'id',
  /** column name */
  InternalTagValue = 'internalTagValue',
  /** column name */
  MappingKey = 'mappingKey',
  /** column name */
  Metadata = 'metadata',
  /** column name */
  UpdatedAt = 'updatedAt',
}

export type VendorProTagValueMapping_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append: InputMaybe<VendorProTagValueMapping_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path: InputMaybe<VendorProTagValueMapping_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem: InputMaybe<VendorProTagValueMapping_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key: InputMaybe<VendorProTagValueMapping_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend: InputMaybe<VendorProTagValueMapping_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<VendorProTagValueMapping_Set_Input>;
  /** filter the rows which have to be updated */
  where: VendorProTagValueMapping_Bool_Exp;
};

/** columns and relationships of "VendorReview" */
export type VendorReview = {
  __typename?: 'VendorReview';
  /** An object relationship */
  Order: Maybe<Order>;
  /** An object relationship */
  Review: Review;
  /** An object relationship */
  Vendor: Customer;
  orderId: Maybe<Scalars['String']>;
  reviewId: Scalars['String'];
  vendorId: Scalars['uuid'];
};

/** aggregated selection of "VendorReview" */
export type VendorReview_Aggregate = {
  __typename?: 'VendorReview_aggregate';
  aggregate: Maybe<VendorReview_Aggregate_Fields>;
  nodes: Array<VendorReview>;
};

export type VendorReview_Aggregate_Bool_Exp = {
  count: InputMaybe<VendorReview_Aggregate_Bool_Exp_Count>;
};

export type VendorReview_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<VendorReview_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<VendorReview_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "VendorReview" */
export type VendorReview_Aggregate_Fields = {
  __typename?: 'VendorReview_aggregate_fields';
  count: Scalars['Int'];
  max: Maybe<VendorReview_Max_Fields>;
  min: Maybe<VendorReview_Min_Fields>;
};

/** aggregate fields of "VendorReview" */
export type VendorReview_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<VendorReview_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "VendorReview" */
export type VendorReview_Aggregate_Order_By = {
  count: InputMaybe<Order_By>;
  max: InputMaybe<VendorReview_Max_Order_By>;
  min: InputMaybe<VendorReview_Min_Order_By>;
};

/** input type for inserting array relation for remote table "VendorReview" */
export type VendorReview_Arr_Rel_Insert_Input = {
  data: Array<VendorReview_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<VendorReview_On_Conflict>;
};

/** Boolean expression to filter rows from the table "VendorReview". All fields are combined with a logical 'AND'. */
export type VendorReview_Bool_Exp = {
  Order: InputMaybe<Order_Bool_Exp>;
  Review: InputMaybe<Review_Bool_Exp>;
  Vendor: InputMaybe<Customer_Bool_Exp>;
  _and: InputMaybe<Array<VendorReview_Bool_Exp>>;
  _not: InputMaybe<VendorReview_Bool_Exp>;
  _or: InputMaybe<Array<VendorReview_Bool_Exp>>;
  orderId: InputMaybe<String_Comparison_Exp>;
  reviewId: InputMaybe<String_Comparison_Exp>;
  vendorId: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "VendorReview" */
export enum VendorReview_Constraint {
  /** unique or primary key constraint on columns "reviewId" */
  VendorReviewPkey = 'VendorReview_pkey',
}

/** input type for inserting data into table "VendorReview" */
export type VendorReview_Insert_Input = {
  Order: InputMaybe<Order_Obj_Rel_Insert_Input>;
  Review: InputMaybe<Review_Obj_Rel_Insert_Input>;
  Vendor: InputMaybe<Customer_Obj_Rel_Insert_Input>;
  orderId: InputMaybe<Scalars['String']>;
  reviewId: InputMaybe<Scalars['String']>;
  vendorId: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type VendorReview_Max_Fields = {
  __typename?: 'VendorReview_max_fields';
  orderId: Maybe<Scalars['String']>;
  reviewId: Maybe<Scalars['String']>;
  vendorId: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "VendorReview" */
export type VendorReview_Max_Order_By = {
  orderId: InputMaybe<Order_By>;
  reviewId: InputMaybe<Order_By>;
  vendorId: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type VendorReview_Min_Fields = {
  __typename?: 'VendorReview_min_fields';
  orderId: Maybe<Scalars['String']>;
  reviewId: Maybe<Scalars['String']>;
  vendorId: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "VendorReview" */
export type VendorReview_Min_Order_By = {
  orderId: InputMaybe<Order_By>;
  reviewId: InputMaybe<Order_By>;
  vendorId: InputMaybe<Order_By>;
};

/** response of any mutation on the table "VendorReview" */
export type VendorReview_Mutation_Response = {
  __typename?: 'VendorReview_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<VendorReview>;
};

/** on_conflict condition type for table "VendorReview" */
export type VendorReview_On_Conflict = {
  constraint: VendorReview_Constraint;
  update_columns: Array<VendorReview_Update_Column>;
  where: InputMaybe<VendorReview_Bool_Exp>;
};

/** Ordering options when selecting data from "VendorReview". */
export type VendorReview_Order_By = {
  Order: InputMaybe<Order_Order_By>;
  Review: InputMaybe<Review_Order_By>;
  Vendor: InputMaybe<Customer_Order_By>;
  orderId: InputMaybe<Order_By>;
  reviewId: InputMaybe<Order_By>;
  vendorId: InputMaybe<Order_By>;
};

/** primary key columns input for table: VendorReview */
export type VendorReview_Pk_Columns_Input = {
  reviewId: Scalars['String'];
};

/** select columns of table "VendorReview" */
export enum VendorReview_Select_Column {
  /** column name */
  OrderId = 'orderId',
  /** column name */
  ReviewId = 'reviewId',
  /** column name */
  VendorId = 'vendorId',
}

/** input type for updating data in table "VendorReview" */
export type VendorReview_Set_Input = {
  orderId: InputMaybe<Scalars['String']>;
  reviewId: InputMaybe<Scalars['String']>;
  vendorId: InputMaybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "VendorReview" */
export type VendorReview_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: VendorReview_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type VendorReview_Stream_Cursor_Value_Input = {
  orderId: InputMaybe<Scalars['String']>;
  reviewId: InputMaybe<Scalars['String']>;
  vendorId: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "VendorReview" */
export enum VendorReview_Update_Column {
  /** column name */
  OrderId = 'orderId',
  /** column name */
  ReviewId = 'reviewId',
  /** column name */
  VendorId = 'vendorId',
}

export type VendorReview_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<VendorReview_Set_Input>;
  /** filter the rows which have to be updated */
  where: VendorReview_Bool_Exp;
};

/** columns and relationships of "auth.provider_requests" */
export type AuthProviderRequests = {
  __typename?: 'authProviderRequests';
  id: Scalars['uuid'];
  options: Maybe<Scalars['jsonb']>;
};

/** columns and relationships of "auth.provider_requests" */
export type AuthProviderRequestsOptionsArgs = {
  path: InputMaybe<Scalars['String']>;
};

/** aggregated selection of "auth.provider_requests" */
export type AuthProviderRequests_Aggregate = {
  __typename?: 'authProviderRequests_aggregate';
  aggregate: Maybe<AuthProviderRequests_Aggregate_Fields>;
  nodes: Array<AuthProviderRequests>;
};

/** aggregate fields of "auth.provider_requests" */
export type AuthProviderRequests_Aggregate_Fields = {
  __typename?: 'authProviderRequests_aggregate_fields';
  count: Scalars['Int'];
  max: Maybe<AuthProviderRequests_Max_Fields>;
  min: Maybe<AuthProviderRequests_Min_Fields>;
};

/** aggregate fields of "auth.provider_requests" */
export type AuthProviderRequests_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<AuthProviderRequests_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type AuthProviderRequests_Append_Input = {
  options: InputMaybe<Scalars['jsonb']>;
};

/** Boolean expression to filter rows from the table "auth.provider_requests". All fields are combined with a logical 'AND'. */
export type AuthProviderRequests_Bool_Exp = {
  _and: InputMaybe<Array<AuthProviderRequests_Bool_Exp>>;
  _not: InputMaybe<AuthProviderRequests_Bool_Exp>;
  _or: InputMaybe<Array<AuthProviderRequests_Bool_Exp>>;
  id: InputMaybe<Uuid_Comparison_Exp>;
  options: InputMaybe<Jsonb_Comparison_Exp>;
};

/** unique or primary key constraints on table "auth.provider_requests" */
export enum AuthProviderRequests_Constraint {
  /** unique or primary key constraint on columns "id" */
  ProviderRequestsPkey = 'provider_requests_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type AuthProviderRequests_Delete_At_Path_Input = {
  options: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type AuthProviderRequests_Delete_Elem_Input = {
  options: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type AuthProviderRequests_Delete_Key_Input = {
  options: InputMaybe<Scalars['String']>;
};

/** input type for inserting data into table "auth.provider_requests" */
export type AuthProviderRequests_Insert_Input = {
  id: InputMaybe<Scalars['uuid']>;
  options: InputMaybe<Scalars['jsonb']>;
};

/** aggregate max on columns */
export type AuthProviderRequests_Max_Fields = {
  __typename?: 'authProviderRequests_max_fields';
  id: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type AuthProviderRequests_Min_Fields = {
  __typename?: 'authProviderRequests_min_fields';
  id: Maybe<Scalars['uuid']>;
};

/** response of any mutation on the table "auth.provider_requests" */
export type AuthProviderRequests_Mutation_Response = {
  __typename?: 'authProviderRequests_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<AuthProviderRequests>;
};

/** on_conflict condition type for table "auth.provider_requests" */
export type AuthProviderRequests_On_Conflict = {
  constraint: AuthProviderRequests_Constraint;
  update_columns: Array<AuthProviderRequests_Update_Column>;
  where: InputMaybe<AuthProviderRequests_Bool_Exp>;
};

/** Ordering options when selecting data from "auth.provider_requests". */
export type AuthProviderRequests_Order_By = {
  id: InputMaybe<Order_By>;
  options: InputMaybe<Order_By>;
};

/** primary key columns input for table: auth.provider_requests */
export type AuthProviderRequests_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type AuthProviderRequests_Prepend_Input = {
  options: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "auth.provider_requests" */
export enum AuthProviderRequests_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Options = 'options',
}

/** input type for updating data in table "auth.provider_requests" */
export type AuthProviderRequests_Set_Input = {
  id: InputMaybe<Scalars['uuid']>;
  options: InputMaybe<Scalars['jsonb']>;
};

/** Streaming cursor of the table "authProviderRequests" */
export type AuthProviderRequests_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: AuthProviderRequests_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type AuthProviderRequests_Stream_Cursor_Value_Input = {
  id: InputMaybe<Scalars['uuid']>;
  options: InputMaybe<Scalars['jsonb']>;
};

/** update columns of table "auth.provider_requests" */
export enum AuthProviderRequests_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Options = 'options',
}

export type AuthProviderRequests_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append: InputMaybe<AuthProviderRequests_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path: InputMaybe<AuthProviderRequests_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem: InputMaybe<AuthProviderRequests_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key: InputMaybe<AuthProviderRequests_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend: InputMaybe<AuthProviderRequests_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<AuthProviderRequests_Set_Input>;
  /** filter the rows which have to be updated */
  where: AuthProviderRequests_Bool_Exp;
};

/** columns and relationships of "auth.providers" */
export type AuthProviders = {
  __typename?: 'authProviders';
  id: Scalars['String'];
  /** An array relationship */
  userProviders: Array<Auth_User_Providers>;
  /** An aggregate relationship */
  userProviders_aggregate: Auth_User_Providers_Aggregate;
};

/** columns and relationships of "auth.providers" */
export type AuthProvidersUserProvidersArgs = {
  distinct_on: InputMaybe<Array<Auth_User_Providers_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Auth_User_Providers_Order_By>>;
  where: InputMaybe<Auth_User_Providers_Bool_Exp>;
};

/** columns and relationships of "auth.providers" */
export type AuthProvidersUserProviders_AggregateArgs = {
  distinct_on: InputMaybe<Array<Auth_User_Providers_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Auth_User_Providers_Order_By>>;
  where: InputMaybe<Auth_User_Providers_Bool_Exp>;
};

/** aggregated selection of "auth.providers" */
export type AuthProviders_Aggregate = {
  __typename?: 'authProviders_aggregate';
  aggregate: Maybe<AuthProviders_Aggregate_Fields>;
  nodes: Array<AuthProviders>;
};

/** aggregate fields of "auth.providers" */
export type AuthProviders_Aggregate_Fields = {
  __typename?: 'authProviders_aggregate_fields';
  count: Scalars['Int'];
  max: Maybe<AuthProviders_Max_Fields>;
  min: Maybe<AuthProviders_Min_Fields>;
};

/** aggregate fields of "auth.providers" */
export type AuthProviders_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<AuthProviders_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "auth.providers". All fields are combined with a logical 'AND'. */
export type AuthProviders_Bool_Exp = {
  _and: InputMaybe<Array<AuthProviders_Bool_Exp>>;
  _not: InputMaybe<AuthProviders_Bool_Exp>;
  _or: InputMaybe<Array<AuthProviders_Bool_Exp>>;
  id: InputMaybe<String_Comparison_Exp>;
  userProviders: InputMaybe<Auth_User_Providers_Bool_Exp>;
  userProviders_aggregate: InputMaybe<Auth_User_Providers_Aggregate_Bool_Exp>;
};

/** unique or primary key constraints on table "auth.providers" */
export enum AuthProviders_Constraint {
  /** unique or primary key constraint on columns "id" */
  ProvidersPkey = 'providers_pkey',
}

/** input type for inserting data into table "auth.providers" */
export type AuthProviders_Insert_Input = {
  id: InputMaybe<Scalars['String']>;
  userProviders: InputMaybe<Auth_User_Providers_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type AuthProviders_Max_Fields = {
  __typename?: 'authProviders_max_fields';
  id: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type AuthProviders_Min_Fields = {
  __typename?: 'authProviders_min_fields';
  id: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "auth.providers" */
export type AuthProviders_Mutation_Response = {
  __typename?: 'authProviders_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<AuthProviders>;
};

/** on_conflict condition type for table "auth.providers" */
export type AuthProviders_On_Conflict = {
  constraint: AuthProviders_Constraint;
  update_columns: Array<AuthProviders_Update_Column>;
  where: InputMaybe<AuthProviders_Bool_Exp>;
};

/** Ordering options when selecting data from "auth.providers". */
export type AuthProviders_Order_By = {
  id: InputMaybe<Order_By>;
  userProviders_aggregate: InputMaybe<Auth_User_Providers_Aggregate_Order_By>;
};

/** primary key columns input for table: auth.providers */
export type AuthProviders_Pk_Columns_Input = {
  id: Scalars['String'];
};

/** select columns of table "auth.providers" */
export enum AuthProviders_Select_Column {
  /** column name */
  Id = 'id',
}

/** input type for updating data in table "auth.providers" */
export type AuthProviders_Set_Input = {
  id: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "authProviders" */
export type AuthProviders_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: AuthProviders_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type AuthProviders_Stream_Cursor_Value_Input = {
  id: InputMaybe<Scalars['String']>;
};

/** update columns of table "auth.providers" */
export enum AuthProviders_Update_Column {
  /** column name */
  Id = 'id',
}

export type AuthProviders_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<AuthProviders_Set_Input>;
  /** filter the rows which have to be updated */
  where: AuthProviders_Bool_Exp;
};

/** columns and relationships of "auth.refresh_tokens" */
export type AuthRefreshTokens = {
  __typename?: 'authRefreshTokens';
  createdAt: Scalars['timestamptz'];
  expiresAt: Scalars['timestamptz'];
  refreshToken: Scalars['uuid'];
  refresh_token_hash: Maybe<Scalars['String']>;
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid'];
};

/** aggregated selection of "auth.refresh_tokens" */
export type AuthRefreshTokens_Aggregate = {
  __typename?: 'authRefreshTokens_aggregate';
  aggregate: Maybe<AuthRefreshTokens_Aggregate_Fields>;
  nodes: Array<AuthRefreshTokens>;
};

export type AuthRefreshTokens_Aggregate_Bool_Exp = {
  count: InputMaybe<AuthRefreshTokens_Aggregate_Bool_Exp_Count>;
};

export type AuthRefreshTokens_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<AuthRefreshTokens_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<AuthRefreshTokens_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "auth.refresh_tokens" */
export type AuthRefreshTokens_Aggregate_Fields = {
  __typename?: 'authRefreshTokens_aggregate_fields';
  count: Scalars['Int'];
  max: Maybe<AuthRefreshTokens_Max_Fields>;
  min: Maybe<AuthRefreshTokens_Min_Fields>;
};

/** aggregate fields of "auth.refresh_tokens" */
export type AuthRefreshTokens_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<AuthRefreshTokens_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "auth.refresh_tokens" */
export type AuthRefreshTokens_Aggregate_Order_By = {
  count: InputMaybe<Order_By>;
  max: InputMaybe<AuthRefreshTokens_Max_Order_By>;
  min: InputMaybe<AuthRefreshTokens_Min_Order_By>;
};

/** input type for inserting array relation for remote table "auth.refresh_tokens" */
export type AuthRefreshTokens_Arr_Rel_Insert_Input = {
  data: Array<AuthRefreshTokens_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<AuthRefreshTokens_On_Conflict>;
};

/** Boolean expression to filter rows from the table "auth.refresh_tokens". All fields are combined with a logical 'AND'. */
export type AuthRefreshTokens_Bool_Exp = {
  _and: InputMaybe<Array<AuthRefreshTokens_Bool_Exp>>;
  _not: InputMaybe<AuthRefreshTokens_Bool_Exp>;
  _or: InputMaybe<Array<AuthRefreshTokens_Bool_Exp>>;
  createdAt: InputMaybe<Timestamptz_Comparison_Exp>;
  expiresAt: InputMaybe<Timestamptz_Comparison_Exp>;
  refreshToken: InputMaybe<Uuid_Comparison_Exp>;
  refresh_token_hash: InputMaybe<String_Comparison_Exp>;
  user: InputMaybe<Users_Bool_Exp>;
  userId: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "auth.refresh_tokens" */
export enum AuthRefreshTokens_Constraint {
  /** unique or primary key constraint on columns "refresh_token" */
  RefreshTokensPkey = 'refresh_tokens_pkey',
}

/** input type for inserting data into table "auth.refresh_tokens" */
export type AuthRefreshTokens_Insert_Input = {
  createdAt: InputMaybe<Scalars['timestamptz']>;
  expiresAt: InputMaybe<Scalars['timestamptz']>;
  refreshToken: InputMaybe<Scalars['uuid']>;
  user: InputMaybe<Users_Obj_Rel_Insert_Input>;
  userId: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type AuthRefreshTokens_Max_Fields = {
  __typename?: 'authRefreshTokens_max_fields';
  createdAt: Maybe<Scalars['timestamptz']>;
  expiresAt: Maybe<Scalars['timestamptz']>;
  refreshToken: Maybe<Scalars['uuid']>;
  refresh_token_hash: Maybe<Scalars['String']>;
  userId: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "auth.refresh_tokens" */
export type AuthRefreshTokens_Max_Order_By = {
  createdAt: InputMaybe<Order_By>;
  expiresAt: InputMaybe<Order_By>;
  refreshToken: InputMaybe<Order_By>;
  refresh_token_hash: InputMaybe<Order_By>;
  userId: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type AuthRefreshTokens_Min_Fields = {
  __typename?: 'authRefreshTokens_min_fields';
  createdAt: Maybe<Scalars['timestamptz']>;
  expiresAt: Maybe<Scalars['timestamptz']>;
  refreshToken: Maybe<Scalars['uuid']>;
  refresh_token_hash: Maybe<Scalars['String']>;
  userId: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "auth.refresh_tokens" */
export type AuthRefreshTokens_Min_Order_By = {
  createdAt: InputMaybe<Order_By>;
  expiresAt: InputMaybe<Order_By>;
  refreshToken: InputMaybe<Order_By>;
  refresh_token_hash: InputMaybe<Order_By>;
  userId: InputMaybe<Order_By>;
};

/** response of any mutation on the table "auth.refresh_tokens" */
export type AuthRefreshTokens_Mutation_Response = {
  __typename?: 'authRefreshTokens_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<AuthRefreshTokens>;
};

/** on_conflict condition type for table "auth.refresh_tokens" */
export type AuthRefreshTokens_On_Conflict = {
  constraint: AuthRefreshTokens_Constraint;
  update_columns: Array<AuthRefreshTokens_Update_Column>;
  where: InputMaybe<AuthRefreshTokens_Bool_Exp>;
};

/** Ordering options when selecting data from "auth.refresh_tokens". */
export type AuthRefreshTokens_Order_By = {
  createdAt: InputMaybe<Order_By>;
  expiresAt: InputMaybe<Order_By>;
  refreshToken: InputMaybe<Order_By>;
  refresh_token_hash: InputMaybe<Order_By>;
  user: InputMaybe<Users_Order_By>;
  userId: InputMaybe<Order_By>;
};

/** primary key columns input for table: auth.refresh_tokens */
export type AuthRefreshTokens_Pk_Columns_Input = {
  refreshToken: Scalars['uuid'];
};

/** select columns of table "auth.refresh_tokens" */
export enum AuthRefreshTokens_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  ExpiresAt = 'expiresAt',
  /** column name */
  RefreshToken = 'refreshToken',
  /** column name */
  RefreshTokenHash = 'refresh_token_hash',
  /** column name */
  UserId = 'userId',
}

/** input type for updating data in table "auth.refresh_tokens" */
export type AuthRefreshTokens_Set_Input = {
  createdAt: InputMaybe<Scalars['timestamptz']>;
  expiresAt: InputMaybe<Scalars['timestamptz']>;
  refreshToken: InputMaybe<Scalars['uuid']>;
  userId: InputMaybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "authRefreshTokens" */
export type AuthRefreshTokens_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: AuthRefreshTokens_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type AuthRefreshTokens_Stream_Cursor_Value_Input = {
  createdAt: InputMaybe<Scalars['timestamptz']>;
  expiresAt: InputMaybe<Scalars['timestamptz']>;
  refreshToken: InputMaybe<Scalars['uuid']>;
  refresh_token_hash: InputMaybe<Scalars['String']>;
  userId: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "auth.refresh_tokens" */
export enum AuthRefreshTokens_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  ExpiresAt = 'expiresAt',
  /** column name */
  RefreshToken = 'refreshToken',
  /** column name */
  UserId = 'userId',
}

export type AuthRefreshTokens_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<AuthRefreshTokens_Set_Input>;
  /** filter the rows which have to be updated */
  where: AuthRefreshTokens_Bool_Exp;
};

/** columns and relationships of "auth.user_roles" */
export type AuthUserRoles = {
  __typename?: 'authUserRoles';
  createdAt: Scalars['timestamptz'];
  id: Scalars['uuid'];
  role: Scalars['String'];
  /** An object relationship */
  roleByRole: Auth_Roles;
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid'];
};

/** aggregated selection of "auth.user_roles" */
export type AuthUserRoles_Aggregate = {
  __typename?: 'authUserRoles_aggregate';
  aggregate: Maybe<AuthUserRoles_Aggregate_Fields>;
  nodes: Array<AuthUserRoles>;
};

export type AuthUserRoles_Aggregate_Bool_Exp = {
  count: InputMaybe<AuthUserRoles_Aggregate_Bool_Exp_Count>;
};

export type AuthUserRoles_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<AuthUserRoles_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<AuthUserRoles_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "auth.user_roles" */
export type AuthUserRoles_Aggregate_Fields = {
  __typename?: 'authUserRoles_aggregate_fields';
  count: Scalars['Int'];
  max: Maybe<AuthUserRoles_Max_Fields>;
  min: Maybe<AuthUserRoles_Min_Fields>;
};

/** aggregate fields of "auth.user_roles" */
export type AuthUserRoles_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<AuthUserRoles_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "auth.user_roles" */
export type AuthUserRoles_Aggregate_Order_By = {
  count: InputMaybe<Order_By>;
  max: InputMaybe<AuthUserRoles_Max_Order_By>;
  min: InputMaybe<AuthUserRoles_Min_Order_By>;
};

/** input type for inserting array relation for remote table "auth.user_roles" */
export type AuthUserRoles_Arr_Rel_Insert_Input = {
  data: Array<AuthUserRoles_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<AuthUserRoles_On_Conflict>;
};

/** Boolean expression to filter rows from the table "auth.user_roles". All fields are combined with a logical 'AND'. */
export type AuthUserRoles_Bool_Exp = {
  _and: InputMaybe<Array<AuthUserRoles_Bool_Exp>>;
  _not: InputMaybe<AuthUserRoles_Bool_Exp>;
  _or: InputMaybe<Array<AuthUserRoles_Bool_Exp>>;
  createdAt: InputMaybe<Timestamptz_Comparison_Exp>;
  id: InputMaybe<Uuid_Comparison_Exp>;
  role: InputMaybe<String_Comparison_Exp>;
  roleByRole: InputMaybe<Auth_Roles_Bool_Exp>;
  user: InputMaybe<Users_Bool_Exp>;
  userId: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "auth.user_roles" */
export enum AuthUserRoles_Constraint {
  /** unique or primary key constraint on columns "id" */
  UserRolesPkey = 'user_roles_pkey',
  /** unique or primary key constraint on columns "user_id", "role" */
  UserRolesUserIdRoleKey = 'user_roles_user_id_role_key',
}

/** input type for inserting data into table "auth.user_roles" */
export type AuthUserRoles_Insert_Input = {
  createdAt: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['uuid']>;
  role: InputMaybe<Scalars['String']>;
  roleByRole: InputMaybe<Auth_Roles_Obj_Rel_Insert_Input>;
  user: InputMaybe<Users_Obj_Rel_Insert_Input>;
  userId: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type AuthUserRoles_Max_Fields = {
  __typename?: 'authUserRoles_max_fields';
  createdAt: Maybe<Scalars['timestamptz']>;
  id: Maybe<Scalars['uuid']>;
  role: Maybe<Scalars['String']>;
  userId: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "auth.user_roles" */
export type AuthUserRoles_Max_Order_By = {
  createdAt: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  role: InputMaybe<Order_By>;
  userId: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type AuthUserRoles_Min_Fields = {
  __typename?: 'authUserRoles_min_fields';
  createdAt: Maybe<Scalars['timestamptz']>;
  id: Maybe<Scalars['uuid']>;
  role: Maybe<Scalars['String']>;
  userId: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "auth.user_roles" */
export type AuthUserRoles_Min_Order_By = {
  createdAt: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  role: InputMaybe<Order_By>;
  userId: InputMaybe<Order_By>;
};

/** response of any mutation on the table "auth.user_roles" */
export type AuthUserRoles_Mutation_Response = {
  __typename?: 'authUserRoles_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<AuthUserRoles>;
};

/** on_conflict condition type for table "auth.user_roles" */
export type AuthUserRoles_On_Conflict = {
  constraint: AuthUserRoles_Constraint;
  update_columns: Array<AuthUserRoles_Update_Column>;
  where: InputMaybe<AuthUserRoles_Bool_Exp>;
};

/** Ordering options when selecting data from "auth.user_roles". */
export type AuthUserRoles_Order_By = {
  createdAt: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  role: InputMaybe<Order_By>;
  roleByRole: InputMaybe<Auth_Roles_Order_By>;
  user: InputMaybe<Users_Order_By>;
  userId: InputMaybe<Order_By>;
};

/** primary key columns input for table: auth.user_roles */
export type AuthUserRoles_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "auth.user_roles" */
export enum AuthUserRoles_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Role = 'role',
  /** column name */
  UserId = 'userId',
}

/** input type for updating data in table "auth.user_roles" */
export type AuthUserRoles_Set_Input = {
  createdAt: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['uuid']>;
  role: InputMaybe<Scalars['String']>;
  userId: InputMaybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "authUserRoles" */
export type AuthUserRoles_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: AuthUserRoles_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type AuthUserRoles_Stream_Cursor_Value_Input = {
  createdAt: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['uuid']>;
  role: InputMaybe<Scalars['String']>;
  userId: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "auth.user_roles" */
export enum AuthUserRoles_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Role = 'role',
  /** column name */
  UserId = 'userId',
}

export type AuthUserRoles_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<AuthUserRoles_Set_Input>;
  /** filter the rows which have to be updated */
  where: AuthUserRoles_Bool_Exp;
};

/** columns and relationships of "auth.user_security_keys" */
export type AuthUserSecurityKeys = {
  __typename?: 'authUserSecurityKeys';
  counter: Scalars['bigint'];
  credentialId: Scalars['String'];
  credentialPublicKey: Maybe<Scalars['bytea']>;
  id: Scalars['uuid'];
  nickname: Maybe<Scalars['String']>;
  transports: Scalars['String'];
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid'];
};

/** aggregated selection of "auth.user_security_keys" */
export type AuthUserSecurityKeys_Aggregate = {
  __typename?: 'authUserSecurityKeys_aggregate';
  aggregate: Maybe<AuthUserSecurityKeys_Aggregate_Fields>;
  nodes: Array<AuthUserSecurityKeys>;
};

export type AuthUserSecurityKeys_Aggregate_Bool_Exp = {
  count: InputMaybe<AuthUserSecurityKeys_Aggregate_Bool_Exp_Count>;
};

export type AuthUserSecurityKeys_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<AuthUserSecurityKeys_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<AuthUserSecurityKeys_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "auth.user_security_keys" */
export type AuthUserSecurityKeys_Aggregate_Fields = {
  __typename?: 'authUserSecurityKeys_aggregate_fields';
  avg: Maybe<AuthUserSecurityKeys_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<AuthUserSecurityKeys_Max_Fields>;
  min: Maybe<AuthUserSecurityKeys_Min_Fields>;
  stddev: Maybe<AuthUserSecurityKeys_Stddev_Fields>;
  stddev_pop: Maybe<AuthUserSecurityKeys_Stddev_Pop_Fields>;
  stddev_samp: Maybe<AuthUserSecurityKeys_Stddev_Samp_Fields>;
  sum: Maybe<AuthUserSecurityKeys_Sum_Fields>;
  var_pop: Maybe<AuthUserSecurityKeys_Var_Pop_Fields>;
  var_samp: Maybe<AuthUserSecurityKeys_Var_Samp_Fields>;
  variance: Maybe<AuthUserSecurityKeys_Variance_Fields>;
};

/** aggregate fields of "auth.user_security_keys" */
export type AuthUserSecurityKeys_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<AuthUserSecurityKeys_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "auth.user_security_keys" */
export type AuthUserSecurityKeys_Aggregate_Order_By = {
  avg: InputMaybe<AuthUserSecurityKeys_Avg_Order_By>;
  count: InputMaybe<Order_By>;
  max: InputMaybe<AuthUserSecurityKeys_Max_Order_By>;
  min: InputMaybe<AuthUserSecurityKeys_Min_Order_By>;
  stddev: InputMaybe<AuthUserSecurityKeys_Stddev_Order_By>;
  stddev_pop: InputMaybe<AuthUserSecurityKeys_Stddev_Pop_Order_By>;
  stddev_samp: InputMaybe<AuthUserSecurityKeys_Stddev_Samp_Order_By>;
  sum: InputMaybe<AuthUserSecurityKeys_Sum_Order_By>;
  var_pop: InputMaybe<AuthUserSecurityKeys_Var_Pop_Order_By>;
  var_samp: InputMaybe<AuthUserSecurityKeys_Var_Samp_Order_By>;
  variance: InputMaybe<AuthUserSecurityKeys_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "auth.user_security_keys" */
export type AuthUserSecurityKeys_Arr_Rel_Insert_Input = {
  data: Array<AuthUserSecurityKeys_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<AuthUserSecurityKeys_On_Conflict>;
};

/** aggregate avg on columns */
export type AuthUserSecurityKeys_Avg_Fields = {
  __typename?: 'authUserSecurityKeys_avg_fields';
  counter: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "auth.user_security_keys" */
export type AuthUserSecurityKeys_Avg_Order_By = {
  counter: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "auth.user_security_keys". All fields are combined with a logical 'AND'. */
export type AuthUserSecurityKeys_Bool_Exp = {
  _and: InputMaybe<Array<AuthUserSecurityKeys_Bool_Exp>>;
  _not: InputMaybe<AuthUserSecurityKeys_Bool_Exp>;
  _or: InputMaybe<Array<AuthUserSecurityKeys_Bool_Exp>>;
  counter: InputMaybe<Bigint_Comparison_Exp>;
  credentialId: InputMaybe<String_Comparison_Exp>;
  credentialPublicKey: InputMaybe<Bytea_Comparison_Exp>;
  id: InputMaybe<Uuid_Comparison_Exp>;
  nickname: InputMaybe<String_Comparison_Exp>;
  transports: InputMaybe<String_Comparison_Exp>;
  user: InputMaybe<Users_Bool_Exp>;
  userId: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "auth.user_security_keys" */
export enum AuthUserSecurityKeys_Constraint {
  /** unique or primary key constraint on columns "credential_id" */
  UserSecurityKeyCredentialIdKey = 'user_security_key_credential_id_key',
  /** unique or primary key constraint on columns "id" */
  UserSecurityKeysPkey = 'user_security_keys_pkey',
}

/** input type for incrementing numeric columns in table "auth.user_security_keys" */
export type AuthUserSecurityKeys_Inc_Input = {
  counter: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "auth.user_security_keys" */
export type AuthUserSecurityKeys_Insert_Input = {
  counter: InputMaybe<Scalars['bigint']>;
  credentialId: InputMaybe<Scalars['String']>;
  credentialPublicKey: InputMaybe<Scalars['bytea']>;
  id: InputMaybe<Scalars['uuid']>;
  nickname: InputMaybe<Scalars['String']>;
  transports: InputMaybe<Scalars['String']>;
  user: InputMaybe<Users_Obj_Rel_Insert_Input>;
  userId: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type AuthUserSecurityKeys_Max_Fields = {
  __typename?: 'authUserSecurityKeys_max_fields';
  counter: Maybe<Scalars['bigint']>;
  credentialId: Maybe<Scalars['String']>;
  id: Maybe<Scalars['uuid']>;
  nickname: Maybe<Scalars['String']>;
  transports: Maybe<Scalars['String']>;
  userId: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "auth.user_security_keys" */
export type AuthUserSecurityKeys_Max_Order_By = {
  counter: InputMaybe<Order_By>;
  credentialId: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  nickname: InputMaybe<Order_By>;
  transports: InputMaybe<Order_By>;
  userId: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type AuthUserSecurityKeys_Min_Fields = {
  __typename?: 'authUserSecurityKeys_min_fields';
  counter: Maybe<Scalars['bigint']>;
  credentialId: Maybe<Scalars['String']>;
  id: Maybe<Scalars['uuid']>;
  nickname: Maybe<Scalars['String']>;
  transports: Maybe<Scalars['String']>;
  userId: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "auth.user_security_keys" */
export type AuthUserSecurityKeys_Min_Order_By = {
  counter: InputMaybe<Order_By>;
  credentialId: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  nickname: InputMaybe<Order_By>;
  transports: InputMaybe<Order_By>;
  userId: InputMaybe<Order_By>;
};

/** response of any mutation on the table "auth.user_security_keys" */
export type AuthUserSecurityKeys_Mutation_Response = {
  __typename?: 'authUserSecurityKeys_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<AuthUserSecurityKeys>;
};

/** on_conflict condition type for table "auth.user_security_keys" */
export type AuthUserSecurityKeys_On_Conflict = {
  constraint: AuthUserSecurityKeys_Constraint;
  update_columns: Array<AuthUserSecurityKeys_Update_Column>;
  where: InputMaybe<AuthUserSecurityKeys_Bool_Exp>;
};

/** Ordering options when selecting data from "auth.user_security_keys". */
export type AuthUserSecurityKeys_Order_By = {
  counter: InputMaybe<Order_By>;
  credentialId: InputMaybe<Order_By>;
  credentialPublicKey: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  nickname: InputMaybe<Order_By>;
  transports: InputMaybe<Order_By>;
  user: InputMaybe<Users_Order_By>;
  userId: InputMaybe<Order_By>;
};

/** primary key columns input for table: auth.user_security_keys */
export type AuthUserSecurityKeys_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "auth.user_security_keys" */
export enum AuthUserSecurityKeys_Select_Column {
  /** column name */
  Counter = 'counter',
  /** column name */
  CredentialId = 'credentialId',
  /** column name */
  CredentialPublicKey = 'credentialPublicKey',
  /** column name */
  Id = 'id',
  /** column name */
  Nickname = 'nickname',
  /** column name */
  Transports = 'transports',
  /** column name */
  UserId = 'userId',
}

/** input type for updating data in table "auth.user_security_keys" */
export type AuthUserSecurityKeys_Set_Input = {
  counter: InputMaybe<Scalars['bigint']>;
  credentialId: InputMaybe<Scalars['String']>;
  credentialPublicKey: InputMaybe<Scalars['bytea']>;
  id: InputMaybe<Scalars['uuid']>;
  nickname: InputMaybe<Scalars['String']>;
  transports: InputMaybe<Scalars['String']>;
  userId: InputMaybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type AuthUserSecurityKeys_Stddev_Fields = {
  __typename?: 'authUserSecurityKeys_stddev_fields';
  counter: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "auth.user_security_keys" */
export type AuthUserSecurityKeys_Stddev_Order_By = {
  counter: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type AuthUserSecurityKeys_Stddev_Pop_Fields = {
  __typename?: 'authUserSecurityKeys_stddev_pop_fields';
  counter: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "auth.user_security_keys" */
export type AuthUserSecurityKeys_Stddev_Pop_Order_By = {
  counter: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type AuthUserSecurityKeys_Stddev_Samp_Fields = {
  __typename?: 'authUserSecurityKeys_stddev_samp_fields';
  counter: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "auth.user_security_keys" */
export type AuthUserSecurityKeys_Stddev_Samp_Order_By = {
  counter: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "authUserSecurityKeys" */
export type AuthUserSecurityKeys_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: AuthUserSecurityKeys_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type AuthUserSecurityKeys_Stream_Cursor_Value_Input = {
  counter: InputMaybe<Scalars['bigint']>;
  credentialId: InputMaybe<Scalars['String']>;
  credentialPublicKey: InputMaybe<Scalars['bytea']>;
  id: InputMaybe<Scalars['uuid']>;
  nickname: InputMaybe<Scalars['String']>;
  transports: InputMaybe<Scalars['String']>;
  userId: InputMaybe<Scalars['uuid']>;
};

/** aggregate sum on columns */
export type AuthUserSecurityKeys_Sum_Fields = {
  __typename?: 'authUserSecurityKeys_sum_fields';
  counter: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "auth.user_security_keys" */
export type AuthUserSecurityKeys_Sum_Order_By = {
  counter: InputMaybe<Order_By>;
};

/** update columns of table "auth.user_security_keys" */
export enum AuthUserSecurityKeys_Update_Column {
  /** column name */
  Counter = 'counter',
  /** column name */
  CredentialId = 'credentialId',
  /** column name */
  CredentialPublicKey = 'credentialPublicKey',
  /** column name */
  Id = 'id',
  /** column name */
  Nickname = 'nickname',
  /** column name */
  Transports = 'transports',
  /** column name */
  UserId = 'userId',
}

export type AuthUserSecurityKeys_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<AuthUserSecurityKeys_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<AuthUserSecurityKeys_Set_Input>;
  /** filter the rows which have to be updated */
  where: AuthUserSecurityKeys_Bool_Exp;
};

/** aggregate var_pop on columns */
export type AuthUserSecurityKeys_Var_Pop_Fields = {
  __typename?: 'authUserSecurityKeys_var_pop_fields';
  counter: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "auth.user_security_keys" */
export type AuthUserSecurityKeys_Var_Pop_Order_By = {
  counter: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type AuthUserSecurityKeys_Var_Samp_Fields = {
  __typename?: 'authUserSecurityKeys_var_samp_fields';
  counter: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "auth.user_security_keys" */
export type AuthUserSecurityKeys_Var_Samp_Order_By = {
  counter: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type AuthUserSecurityKeys_Variance_Fields = {
  __typename?: 'authUserSecurityKeys_variance_fields';
  counter: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "auth.user_security_keys" */
export type AuthUserSecurityKeys_Variance_Order_By = {
  counter: InputMaybe<Order_By>;
};

/** columns and relationships of "auth.roles" */
export type Auth_Roles = {
  __typename?: 'auth_roles';
  role: Scalars['String'];
};

/** aggregated selection of "auth.roles" */
export type Auth_Roles_Aggregate = {
  __typename?: 'auth_roles_aggregate';
  aggregate: Maybe<Auth_Roles_Aggregate_Fields>;
  nodes: Array<Auth_Roles>;
};

/** aggregate fields of "auth.roles" */
export type Auth_Roles_Aggregate_Fields = {
  __typename?: 'auth_roles_aggregate_fields';
  count: Scalars['Int'];
  max: Maybe<Auth_Roles_Max_Fields>;
  min: Maybe<Auth_Roles_Min_Fields>;
};

/** aggregate fields of "auth.roles" */
export type Auth_Roles_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Auth_Roles_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "auth.roles". All fields are combined with a logical 'AND'. */
export type Auth_Roles_Bool_Exp = {
  _and: InputMaybe<Array<Auth_Roles_Bool_Exp>>;
  _not: InputMaybe<Auth_Roles_Bool_Exp>;
  _or: InputMaybe<Array<Auth_Roles_Bool_Exp>>;
  role: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "auth.roles" */
export enum Auth_Roles_Constraint {
  /** unique or primary key constraint on columns "role" */
  RolesPkey = 'roles_pkey',
}

/** input type for inserting data into table "auth.roles" */
export type Auth_Roles_Insert_Input = {
  role: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Auth_Roles_Max_Fields = {
  __typename?: 'auth_roles_max_fields';
  role: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Auth_Roles_Min_Fields = {
  __typename?: 'auth_roles_min_fields';
  role: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "auth.roles" */
export type Auth_Roles_Mutation_Response = {
  __typename?: 'auth_roles_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Auth_Roles>;
};

/** input type for inserting object relation for remote table "auth.roles" */
export type Auth_Roles_Obj_Rel_Insert_Input = {
  data: Auth_Roles_Insert_Input;
  /** upsert condition */
  on_conflict: InputMaybe<Auth_Roles_On_Conflict>;
};

/** on_conflict condition type for table "auth.roles" */
export type Auth_Roles_On_Conflict = {
  constraint: Auth_Roles_Constraint;
  update_columns: Array<Auth_Roles_Update_Column>;
  where: InputMaybe<Auth_Roles_Bool_Exp>;
};

/** Ordering options when selecting data from "auth.roles". */
export type Auth_Roles_Order_By = {
  role: InputMaybe<Order_By>;
};

/** primary key columns input for table: auth.roles */
export type Auth_Roles_Pk_Columns_Input = {
  role: Scalars['String'];
};

/** select columns of table "auth.roles" */
export enum Auth_Roles_Select_Column {
  /** column name */
  Role = 'role',
}

/** input type for updating data in table "auth.roles" */
export type Auth_Roles_Set_Input = {
  role: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "auth_roles" */
export type Auth_Roles_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Auth_Roles_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Auth_Roles_Stream_Cursor_Value_Input = {
  role: InputMaybe<Scalars['String']>;
};

/** update columns of table "auth.roles" */
export enum Auth_Roles_Update_Column {
  /** column name */
  Role = 'role',
}

export type Auth_Roles_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Auth_Roles_Set_Input>;
  /** filter the rows which have to be updated */
  where: Auth_Roles_Bool_Exp;
};

/** columns and relationships of "auth.user_providers" */
export type Auth_User_Providers = {
  __typename?: 'auth_user_providers';
  access_token: Scalars['String'];
  created_at: Scalars['timestamptz'];
  id: Scalars['uuid'];
  provider_id: Scalars['String'];
  provider_user_id: Scalars['String'];
  refresh_token: Maybe<Scalars['String']>;
  updated_at: Scalars['timestamptz'];
  user_id: Scalars['uuid'];
};

/** aggregated selection of "auth.user_providers" */
export type Auth_User_Providers_Aggregate = {
  __typename?: 'auth_user_providers_aggregate';
  aggregate: Maybe<Auth_User_Providers_Aggregate_Fields>;
  nodes: Array<Auth_User_Providers>;
};

export type Auth_User_Providers_Aggregate_Bool_Exp = {
  count: InputMaybe<Auth_User_Providers_Aggregate_Bool_Exp_Count>;
};

export type Auth_User_Providers_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<Auth_User_Providers_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<Auth_User_Providers_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "auth.user_providers" */
export type Auth_User_Providers_Aggregate_Fields = {
  __typename?: 'auth_user_providers_aggregate_fields';
  count: Scalars['Int'];
  max: Maybe<Auth_User_Providers_Max_Fields>;
  min: Maybe<Auth_User_Providers_Min_Fields>;
};

/** aggregate fields of "auth.user_providers" */
export type Auth_User_Providers_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Auth_User_Providers_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "auth.user_providers" */
export type Auth_User_Providers_Aggregate_Order_By = {
  count: InputMaybe<Order_By>;
  max: InputMaybe<Auth_User_Providers_Max_Order_By>;
  min: InputMaybe<Auth_User_Providers_Min_Order_By>;
};

/** input type for inserting array relation for remote table "auth.user_providers" */
export type Auth_User_Providers_Arr_Rel_Insert_Input = {
  data: Array<Auth_User_Providers_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<Auth_User_Providers_On_Conflict>;
};

/** Boolean expression to filter rows from the table "auth.user_providers". All fields are combined with a logical 'AND'. */
export type Auth_User_Providers_Bool_Exp = {
  _and: InputMaybe<Array<Auth_User_Providers_Bool_Exp>>;
  _not: InputMaybe<Auth_User_Providers_Bool_Exp>;
  _or: InputMaybe<Array<Auth_User_Providers_Bool_Exp>>;
  access_token: InputMaybe<String_Comparison_Exp>;
  created_at: InputMaybe<Timestamptz_Comparison_Exp>;
  id: InputMaybe<Uuid_Comparison_Exp>;
  provider_id: InputMaybe<String_Comparison_Exp>;
  provider_user_id: InputMaybe<String_Comparison_Exp>;
  refresh_token: InputMaybe<String_Comparison_Exp>;
  updated_at: InputMaybe<Timestamptz_Comparison_Exp>;
  user_id: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "auth.user_providers" */
export enum Auth_User_Providers_Constraint {
  /** unique or primary key constraint on columns "id" */
  UserProvidersPkey = 'user_providers_pkey',
  /** unique or primary key constraint on columns "provider_user_id", "provider_id" */
  UserProvidersProviderIdProviderUserIdKey = 'user_providers_provider_id_provider_user_id_key',
  /** unique or primary key constraint on columns "user_id", "provider_id" */
  UserProvidersUserIdProviderIdKey = 'user_providers_user_id_provider_id_key',
}

/** input type for inserting data into table "auth.user_providers" */
export type Auth_User_Providers_Insert_Input = {
  access_token: InputMaybe<Scalars['String']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['uuid']>;
  provider_id: InputMaybe<Scalars['String']>;
  provider_user_id: InputMaybe<Scalars['String']>;
  refresh_token: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
  user_id: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Auth_User_Providers_Max_Fields = {
  __typename?: 'auth_user_providers_max_fields';
  access_token: Maybe<Scalars['String']>;
  created_at: Maybe<Scalars['timestamptz']>;
  id: Maybe<Scalars['uuid']>;
  provider_id: Maybe<Scalars['String']>;
  provider_user_id: Maybe<Scalars['String']>;
  refresh_token: Maybe<Scalars['String']>;
  updated_at: Maybe<Scalars['timestamptz']>;
  user_id: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "auth.user_providers" */
export type Auth_User_Providers_Max_Order_By = {
  access_token: InputMaybe<Order_By>;
  created_at: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  provider_id: InputMaybe<Order_By>;
  provider_user_id: InputMaybe<Order_By>;
  refresh_token: InputMaybe<Order_By>;
  updated_at: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Auth_User_Providers_Min_Fields = {
  __typename?: 'auth_user_providers_min_fields';
  access_token: Maybe<Scalars['String']>;
  created_at: Maybe<Scalars['timestamptz']>;
  id: Maybe<Scalars['uuid']>;
  provider_id: Maybe<Scalars['String']>;
  provider_user_id: Maybe<Scalars['String']>;
  refresh_token: Maybe<Scalars['String']>;
  updated_at: Maybe<Scalars['timestamptz']>;
  user_id: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "auth.user_providers" */
export type Auth_User_Providers_Min_Order_By = {
  access_token: InputMaybe<Order_By>;
  created_at: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  provider_id: InputMaybe<Order_By>;
  provider_user_id: InputMaybe<Order_By>;
  refresh_token: InputMaybe<Order_By>;
  updated_at: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** response of any mutation on the table "auth.user_providers" */
export type Auth_User_Providers_Mutation_Response = {
  __typename?: 'auth_user_providers_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Auth_User_Providers>;
};

/** on_conflict condition type for table "auth.user_providers" */
export type Auth_User_Providers_On_Conflict = {
  constraint: Auth_User_Providers_Constraint;
  update_columns: Array<Auth_User_Providers_Update_Column>;
  where: InputMaybe<Auth_User_Providers_Bool_Exp>;
};

/** Ordering options when selecting data from "auth.user_providers". */
export type Auth_User_Providers_Order_By = {
  access_token: InputMaybe<Order_By>;
  created_at: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  provider_id: InputMaybe<Order_By>;
  provider_user_id: InputMaybe<Order_By>;
  refresh_token: InputMaybe<Order_By>;
  updated_at: InputMaybe<Order_By>;
  user_id: InputMaybe<Order_By>;
};

/** primary key columns input for table: auth.user_providers */
export type Auth_User_Providers_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "auth.user_providers" */
export enum Auth_User_Providers_Select_Column {
  /** column name */
  AccessToken = 'access_token',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  ProviderId = 'provider_id',
  /** column name */
  ProviderUserId = 'provider_user_id',
  /** column name */
  RefreshToken = 'refresh_token',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id',
}

/** input type for updating data in table "auth.user_providers" */
export type Auth_User_Providers_Set_Input = {
  access_token: InputMaybe<Scalars['String']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['uuid']>;
  provider_id: InputMaybe<Scalars['String']>;
  provider_user_id: InputMaybe<Scalars['String']>;
  refresh_token: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
  user_id: InputMaybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "auth_user_providers" */
export type Auth_User_Providers_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Auth_User_Providers_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Auth_User_Providers_Stream_Cursor_Value_Input = {
  access_token: InputMaybe<Scalars['String']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['uuid']>;
  provider_id: InputMaybe<Scalars['String']>;
  provider_user_id: InputMaybe<Scalars['String']>;
  refresh_token: InputMaybe<Scalars['String']>;
  updated_at: InputMaybe<Scalars['timestamptz']>;
  user_id: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "auth.user_providers" */
export enum Auth_User_Providers_Update_Column {
  /** column name */
  AccessToken = 'access_token',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  ProviderId = 'provider_id',
  /** column name */
  ProviderUserId = 'provider_user_id',
  /** column name */
  RefreshToken = 'refresh_token',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id',
}

export type Auth_User_Providers_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Auth_User_Providers_Set_Input>;
  /** filter the rows which have to be updated */
  where: Auth_User_Providers_Bool_Exp;
};

/** Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'. */
export type Bigint_Comparison_Exp = {
  _eq: InputMaybe<Scalars['bigint']>;
  _gt: InputMaybe<Scalars['bigint']>;
  _gte: InputMaybe<Scalars['bigint']>;
  _in: InputMaybe<Array<Scalars['bigint']>>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  _lt: InputMaybe<Scalars['bigint']>;
  _lte: InputMaybe<Scalars['bigint']>;
  _neq: InputMaybe<Scalars['bigint']>;
  _nin: InputMaybe<Array<Scalars['bigint']>>;
};

/** Boolean expression to compare columns of type "bytea". All fields are combined with logical 'AND'. */
export type Bytea_Comparison_Exp = {
  _eq: InputMaybe<Scalars['bytea']>;
  _gt: InputMaybe<Scalars['bytea']>;
  _gte: InputMaybe<Scalars['bytea']>;
  _in: InputMaybe<Array<Scalars['bytea']>>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  _lt: InputMaybe<Scalars['bytea']>;
  _lte: InputMaybe<Scalars['bytea']>;
  _neq: InputMaybe<Scalars['bytea']>;
  _nin: InputMaybe<Array<Scalars['bytea']>>;
};

/** Boolean expression to compare columns of type "citext". All fields are combined with logical 'AND'. */
export type Citext_Comparison_Exp = {
  _eq: InputMaybe<Scalars['citext']>;
  _gt: InputMaybe<Scalars['citext']>;
  _gte: InputMaybe<Scalars['citext']>;
  /** does the column match the given case-insensitive pattern */
  _ilike: InputMaybe<Scalars['citext']>;
  _in: InputMaybe<Array<Scalars['citext']>>;
  /** does the column match the given POSIX regular expression, case insensitive */
  _iregex: InputMaybe<Scalars['citext']>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  /** does the column match the given pattern */
  _like: InputMaybe<Scalars['citext']>;
  _lt: InputMaybe<Scalars['citext']>;
  _lte: InputMaybe<Scalars['citext']>;
  _neq: InputMaybe<Scalars['citext']>;
  /** does the column NOT match the given case-insensitive pattern */
  _nilike: InputMaybe<Scalars['citext']>;
  _nin: InputMaybe<Array<Scalars['citext']>>;
  /** does the column NOT match the given POSIX regular expression, case insensitive */
  _niregex: InputMaybe<Scalars['citext']>;
  /** does the column NOT match the given pattern */
  _nlike: InputMaybe<Scalars['citext']>;
  /** does the column NOT match the given POSIX regular expression, case sensitive */
  _nregex: InputMaybe<Scalars['citext']>;
  /** does the column NOT match the given SQL regular expression */
  _nsimilar: InputMaybe<Scalars['citext']>;
  /** does the column match the given POSIX regular expression, case sensitive */
  _regex: InputMaybe<Scalars['citext']>;
  /** does the column match the given SQL regular expression */
  _similar: InputMaybe<Scalars['citext']>;
};

/** ordering argument of a cursor */
export enum Cursor_Ordering {
  /** ascending ordering of the cursor */
  Asc = 'ASC',
  /** descending ordering of the cursor */
  Desc = 'DESC',
}

/** Boolean expression to compare columns of type "date". All fields are combined with logical 'AND'. */
export type Date_Comparison_Exp = {
  _eq: InputMaybe<Scalars['date']>;
  _gt: InputMaybe<Scalars['date']>;
  _gte: InputMaybe<Scalars['date']>;
  _in: InputMaybe<Array<Scalars['date']>>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  _lt: InputMaybe<Scalars['date']>;
  _lte: InputMaybe<Scalars['date']>;
  _neq: InputMaybe<Scalars['date']>;
  _nin: InputMaybe<Array<Scalars['date']>>;
};

/** columns and relationships of "dbt.store_base_product" */
export type Dbt_Store_Base_Product = {
  __typename?: 'dbt_store_base_product';
  /** An array relationship */
  collections: Array<Dbt_Store_Product_Collection>;
  /** An aggregate relationship */
  collections_aggregate: Dbt_Store_Product_Collection_Aggregate;
  createdAt: Scalars['timestamptz'];
  id: Scalars['String'];
  /** An array relationship */
  images: Array<Dbt_Store_Exposed_Product_Image>;
  /** An aggregate relationship */
  images_aggregate: Dbt_Store_Exposed_Product_Image_Aggregate;
  /** An object relationship */
  product: Maybe<Dbt_Store_Exposed_Product>;
  shopifyId: Scalars['bigint'];
  /** An array relationship */
  tags: Array<Dbt_Store_Exposed_Product_Tag>;
  /** An aggregate relationship */
  tags_aggregate: Dbt_Store_Exposed_Product_Tag_Aggregate;
  /** An array relationship */
  variants: Array<Dbt_Store_Base_Product_Variant>;
  /** An aggregate relationship */
  variants_aggregate: Dbt_Store_Base_Product_Variant_Aggregate;
  vendorId: Scalars['uuid'];
};

/** columns and relationships of "dbt.store_base_product" */
export type Dbt_Store_Base_ProductCollectionsArgs = {
  distinct_on: InputMaybe<Array<Dbt_Store_Product_Collection_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Product_Collection_Order_By>>;
  where: InputMaybe<Dbt_Store_Product_Collection_Bool_Exp>;
};

/** columns and relationships of "dbt.store_base_product" */
export type Dbt_Store_Base_ProductCollections_AggregateArgs = {
  distinct_on: InputMaybe<Array<Dbt_Store_Product_Collection_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Product_Collection_Order_By>>;
  where: InputMaybe<Dbt_Store_Product_Collection_Bool_Exp>;
};

/** columns and relationships of "dbt.store_base_product" */
export type Dbt_Store_Base_ProductImagesArgs = {
  distinct_on: InputMaybe<Array<Dbt_Store_Exposed_Product_Image_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Exposed_Product_Image_Order_By>>;
  where: InputMaybe<Dbt_Store_Exposed_Product_Image_Bool_Exp>;
};

/** columns and relationships of "dbt.store_base_product" */
export type Dbt_Store_Base_ProductImages_AggregateArgs = {
  distinct_on: InputMaybe<Array<Dbt_Store_Exposed_Product_Image_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Exposed_Product_Image_Order_By>>;
  where: InputMaybe<Dbt_Store_Exposed_Product_Image_Bool_Exp>;
};

/** columns and relationships of "dbt.store_base_product" */
export type Dbt_Store_Base_ProductTagsArgs = {
  distinct_on: InputMaybe<Array<Dbt_Store_Exposed_Product_Tag_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Exposed_Product_Tag_Order_By>>;
  where: InputMaybe<Dbt_Store_Exposed_Product_Tag_Bool_Exp>;
};

/** columns and relationships of "dbt.store_base_product" */
export type Dbt_Store_Base_ProductTags_AggregateArgs = {
  distinct_on: InputMaybe<Array<Dbt_Store_Exposed_Product_Tag_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Exposed_Product_Tag_Order_By>>;
  where: InputMaybe<Dbt_Store_Exposed_Product_Tag_Bool_Exp>;
};

/** columns and relationships of "dbt.store_base_product" */
export type Dbt_Store_Base_ProductVariantsArgs = {
  distinct_on: InputMaybe<Array<Dbt_Store_Base_Product_Variant_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Base_Product_Variant_Order_By>>;
  where: InputMaybe<Dbt_Store_Base_Product_Variant_Bool_Exp>;
};

/** columns and relationships of "dbt.store_base_product" */
export type Dbt_Store_Base_ProductVariants_AggregateArgs = {
  distinct_on: InputMaybe<Array<Dbt_Store_Base_Product_Variant_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Base_Product_Variant_Order_By>>;
  where: InputMaybe<Dbt_Store_Base_Product_Variant_Bool_Exp>;
};

/** aggregated selection of "dbt.store_base_product" */
export type Dbt_Store_Base_Product_Aggregate = {
  __typename?: 'dbt_store_base_product_aggregate';
  aggregate: Maybe<Dbt_Store_Base_Product_Aggregate_Fields>;
  nodes: Array<Dbt_Store_Base_Product>;
};

/** aggregate fields of "dbt.store_base_product" */
export type Dbt_Store_Base_Product_Aggregate_Fields = {
  __typename?: 'dbt_store_base_product_aggregate_fields';
  avg: Maybe<Dbt_Store_Base_Product_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Dbt_Store_Base_Product_Max_Fields>;
  min: Maybe<Dbt_Store_Base_Product_Min_Fields>;
  stddev: Maybe<Dbt_Store_Base_Product_Stddev_Fields>;
  stddev_pop: Maybe<Dbt_Store_Base_Product_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Dbt_Store_Base_Product_Stddev_Samp_Fields>;
  sum: Maybe<Dbt_Store_Base_Product_Sum_Fields>;
  var_pop: Maybe<Dbt_Store_Base_Product_Var_Pop_Fields>;
  var_samp: Maybe<Dbt_Store_Base_Product_Var_Samp_Fields>;
  variance: Maybe<Dbt_Store_Base_Product_Variance_Fields>;
};

/** aggregate fields of "dbt.store_base_product" */
export type Dbt_Store_Base_Product_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Dbt_Store_Base_Product_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Dbt_Store_Base_Product_Avg_Fields = {
  __typename?: 'dbt_store_base_product_avg_fields';
  shopifyId: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "dbt.store_base_product". All fields are combined with a logical 'AND'. */
export type Dbt_Store_Base_Product_Bool_Exp = {
  _and: InputMaybe<Array<Dbt_Store_Base_Product_Bool_Exp>>;
  _not: InputMaybe<Dbt_Store_Base_Product_Bool_Exp>;
  _or: InputMaybe<Array<Dbt_Store_Base_Product_Bool_Exp>>;
  collections: InputMaybe<Dbt_Store_Product_Collection_Bool_Exp>;
  collections_aggregate: InputMaybe<Dbt_Store_Product_Collection_Aggregate_Bool_Exp>;
  createdAt: InputMaybe<Timestamptz_Comparison_Exp>;
  id: InputMaybe<String_Comparison_Exp>;
  images: InputMaybe<Dbt_Store_Exposed_Product_Image_Bool_Exp>;
  images_aggregate: InputMaybe<Dbt_Store_Exposed_Product_Image_Aggregate_Bool_Exp>;
  product: InputMaybe<Dbt_Store_Exposed_Product_Bool_Exp>;
  shopifyId: InputMaybe<Bigint_Comparison_Exp>;
  tags: InputMaybe<Dbt_Store_Exposed_Product_Tag_Bool_Exp>;
  tags_aggregate: InputMaybe<Dbt_Store_Exposed_Product_Tag_Aggregate_Bool_Exp>;
  variants: InputMaybe<Dbt_Store_Base_Product_Variant_Bool_Exp>;
  variants_aggregate: InputMaybe<Dbt_Store_Base_Product_Variant_Aggregate_Bool_Exp>;
  vendorId: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "dbt.store_base_product" */
export enum Dbt_Store_Base_Product_Constraint {
  /** unique or primary key constraint on columns "id" */
  StoreBaseProductPkey = 'store_base_product_pkey',
  /** unique or primary key constraint on columns "shopifyId" */
  StoreBaseProductShopifyIdKey = 'store_base_product_shopifyId_key',
}

/** input type for incrementing numeric columns in table "dbt.store_base_product" */
export type Dbt_Store_Base_Product_Inc_Input = {
  shopifyId: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "dbt.store_base_product" */
export type Dbt_Store_Base_Product_Insert_Input = {
  collections: InputMaybe<Dbt_Store_Product_Collection_Arr_Rel_Insert_Input>;
  createdAt: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['String']>;
  images: InputMaybe<Dbt_Store_Exposed_Product_Image_Arr_Rel_Insert_Input>;
  product: InputMaybe<Dbt_Store_Exposed_Product_Obj_Rel_Insert_Input>;
  shopifyId: InputMaybe<Scalars['bigint']>;
  tags: InputMaybe<Dbt_Store_Exposed_Product_Tag_Arr_Rel_Insert_Input>;
  variants: InputMaybe<Dbt_Store_Base_Product_Variant_Arr_Rel_Insert_Input>;
  vendorId: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Dbt_Store_Base_Product_Max_Fields = {
  __typename?: 'dbt_store_base_product_max_fields';
  createdAt: Maybe<Scalars['timestamptz']>;
  id: Maybe<Scalars['String']>;
  shopifyId: Maybe<Scalars['bigint']>;
  vendorId: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type Dbt_Store_Base_Product_Min_Fields = {
  __typename?: 'dbt_store_base_product_min_fields';
  createdAt: Maybe<Scalars['timestamptz']>;
  id: Maybe<Scalars['String']>;
  shopifyId: Maybe<Scalars['bigint']>;
  vendorId: Maybe<Scalars['uuid']>;
};

/** response of any mutation on the table "dbt.store_base_product" */
export type Dbt_Store_Base_Product_Mutation_Response = {
  __typename?: 'dbt_store_base_product_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Dbt_Store_Base_Product>;
};

/** input type for inserting object relation for remote table "dbt.store_base_product" */
export type Dbt_Store_Base_Product_Obj_Rel_Insert_Input = {
  data: Dbt_Store_Base_Product_Insert_Input;
  /** upsert condition */
  on_conflict: InputMaybe<Dbt_Store_Base_Product_On_Conflict>;
};

/** on_conflict condition type for table "dbt.store_base_product" */
export type Dbt_Store_Base_Product_On_Conflict = {
  constraint: Dbt_Store_Base_Product_Constraint;
  update_columns: Array<Dbt_Store_Base_Product_Update_Column>;
  where: InputMaybe<Dbt_Store_Base_Product_Bool_Exp>;
};

/** Ordering options when selecting data from "dbt.store_base_product". */
export type Dbt_Store_Base_Product_Order_By = {
  collections_aggregate: InputMaybe<Dbt_Store_Product_Collection_Aggregate_Order_By>;
  createdAt: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  images_aggregate: InputMaybe<Dbt_Store_Exposed_Product_Image_Aggregate_Order_By>;
  product: InputMaybe<Dbt_Store_Exposed_Product_Order_By>;
  shopifyId: InputMaybe<Order_By>;
  tags_aggregate: InputMaybe<Dbt_Store_Exposed_Product_Tag_Aggregate_Order_By>;
  variants_aggregate: InputMaybe<Dbt_Store_Base_Product_Variant_Aggregate_Order_By>;
  vendorId: InputMaybe<Order_By>;
};

/** primary key columns input for table: dbt.store_base_product */
export type Dbt_Store_Base_Product_Pk_Columns_Input = {
  id: Scalars['String'];
};

/** select columns of table "dbt.store_base_product" */
export enum Dbt_Store_Base_Product_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  ShopifyId = 'shopifyId',
  /** column name */
  VendorId = 'vendorId',
}

/** input type for updating data in table "dbt.store_base_product" */
export type Dbt_Store_Base_Product_Set_Input = {
  createdAt: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['String']>;
  shopifyId: InputMaybe<Scalars['bigint']>;
  vendorId: InputMaybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type Dbt_Store_Base_Product_Stddev_Fields = {
  __typename?: 'dbt_store_base_product_stddev_fields';
  shopifyId: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Dbt_Store_Base_Product_Stddev_Pop_Fields = {
  __typename?: 'dbt_store_base_product_stddev_pop_fields';
  shopifyId: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Dbt_Store_Base_Product_Stddev_Samp_Fields = {
  __typename?: 'dbt_store_base_product_stddev_samp_fields';
  shopifyId: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "dbt_store_base_product" */
export type Dbt_Store_Base_Product_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Dbt_Store_Base_Product_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Dbt_Store_Base_Product_Stream_Cursor_Value_Input = {
  createdAt: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['String']>;
  shopifyId: InputMaybe<Scalars['bigint']>;
  vendorId: InputMaybe<Scalars['uuid']>;
};

/** aggregate sum on columns */
export type Dbt_Store_Base_Product_Sum_Fields = {
  __typename?: 'dbt_store_base_product_sum_fields';
  shopifyId: Maybe<Scalars['bigint']>;
};

/** update columns of table "dbt.store_base_product" */
export enum Dbt_Store_Base_Product_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  ShopifyId = 'shopifyId',
  /** column name */
  VendorId = 'vendorId',
}

export type Dbt_Store_Base_Product_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Dbt_Store_Base_Product_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Dbt_Store_Base_Product_Set_Input>;
  /** filter the rows which have to be updated */
  where: Dbt_Store_Base_Product_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Dbt_Store_Base_Product_Var_Pop_Fields = {
  __typename?: 'dbt_store_base_product_var_pop_fields';
  shopifyId: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Dbt_Store_Base_Product_Var_Samp_Fields = {
  __typename?: 'dbt_store_base_product_var_samp_fields';
  shopifyId: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Dbt_Store_Base_Product_Variance_Fields = {
  __typename?: 'dbt_store_base_product_variance_fields';
  shopifyId: Maybe<Scalars['Float']>;
};

/** columns and relationships of "dbt.store_base_product_variant" */
export type Dbt_Store_Base_Product_Variant = {
  __typename?: 'dbt_store_base_product_variant';
  createdAt: Scalars['timestamptz'];
  id: Maybe<Scalars['String']>;
  /** An object relationship */
  product: Maybe<Dbt_Store_Base_Product>;
  productId: Scalars['String'];
  shopify_id: Scalars['bigint'];
  /** An object relationship */
  variant: Maybe<Dbt_Store_Exposed_Product_Variant>;
};

/** aggregated selection of "dbt.store_base_product_variant" */
export type Dbt_Store_Base_Product_Variant_Aggregate = {
  __typename?: 'dbt_store_base_product_variant_aggregate';
  aggregate: Maybe<Dbt_Store_Base_Product_Variant_Aggregate_Fields>;
  nodes: Array<Dbt_Store_Base_Product_Variant>;
};

export type Dbt_Store_Base_Product_Variant_Aggregate_Bool_Exp = {
  count: InputMaybe<Dbt_Store_Base_Product_Variant_Aggregate_Bool_Exp_Count>;
};

export type Dbt_Store_Base_Product_Variant_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<Dbt_Store_Base_Product_Variant_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<Dbt_Store_Base_Product_Variant_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "dbt.store_base_product_variant" */
export type Dbt_Store_Base_Product_Variant_Aggregate_Fields = {
  __typename?: 'dbt_store_base_product_variant_aggregate_fields';
  avg: Maybe<Dbt_Store_Base_Product_Variant_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Dbt_Store_Base_Product_Variant_Max_Fields>;
  min: Maybe<Dbt_Store_Base_Product_Variant_Min_Fields>;
  stddev: Maybe<Dbt_Store_Base_Product_Variant_Stddev_Fields>;
  stddev_pop: Maybe<Dbt_Store_Base_Product_Variant_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Dbt_Store_Base_Product_Variant_Stddev_Samp_Fields>;
  sum: Maybe<Dbt_Store_Base_Product_Variant_Sum_Fields>;
  var_pop: Maybe<Dbt_Store_Base_Product_Variant_Var_Pop_Fields>;
  var_samp: Maybe<Dbt_Store_Base_Product_Variant_Var_Samp_Fields>;
  variance: Maybe<Dbt_Store_Base_Product_Variant_Variance_Fields>;
};

/** aggregate fields of "dbt.store_base_product_variant" */
export type Dbt_Store_Base_Product_Variant_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Dbt_Store_Base_Product_Variant_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "dbt.store_base_product_variant" */
export type Dbt_Store_Base_Product_Variant_Aggregate_Order_By = {
  avg: InputMaybe<Dbt_Store_Base_Product_Variant_Avg_Order_By>;
  count: InputMaybe<Order_By>;
  max: InputMaybe<Dbt_Store_Base_Product_Variant_Max_Order_By>;
  min: InputMaybe<Dbt_Store_Base_Product_Variant_Min_Order_By>;
  stddev: InputMaybe<Dbt_Store_Base_Product_Variant_Stddev_Order_By>;
  stddev_pop: InputMaybe<Dbt_Store_Base_Product_Variant_Stddev_Pop_Order_By>;
  stddev_samp: InputMaybe<Dbt_Store_Base_Product_Variant_Stddev_Samp_Order_By>;
  sum: InputMaybe<Dbt_Store_Base_Product_Variant_Sum_Order_By>;
  var_pop: InputMaybe<Dbt_Store_Base_Product_Variant_Var_Pop_Order_By>;
  var_samp: InputMaybe<Dbt_Store_Base_Product_Variant_Var_Samp_Order_By>;
  variance: InputMaybe<Dbt_Store_Base_Product_Variant_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "dbt.store_base_product_variant" */
export type Dbt_Store_Base_Product_Variant_Arr_Rel_Insert_Input = {
  data: Array<Dbt_Store_Base_Product_Variant_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<Dbt_Store_Base_Product_Variant_On_Conflict>;
};

/** aggregate avg on columns */
export type Dbt_Store_Base_Product_Variant_Avg_Fields = {
  __typename?: 'dbt_store_base_product_variant_avg_fields';
  shopify_id: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "dbt.store_base_product_variant" */
export type Dbt_Store_Base_Product_Variant_Avg_Order_By = {
  shopify_id: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "dbt.store_base_product_variant". All fields are combined with a logical 'AND'. */
export type Dbt_Store_Base_Product_Variant_Bool_Exp = {
  _and: InputMaybe<Array<Dbt_Store_Base_Product_Variant_Bool_Exp>>;
  _not: InputMaybe<Dbt_Store_Base_Product_Variant_Bool_Exp>;
  _or: InputMaybe<Array<Dbt_Store_Base_Product_Variant_Bool_Exp>>;
  createdAt: InputMaybe<Timestamptz_Comparison_Exp>;
  id: InputMaybe<String_Comparison_Exp>;
  product: InputMaybe<Dbt_Store_Base_Product_Bool_Exp>;
  productId: InputMaybe<String_Comparison_Exp>;
  shopify_id: InputMaybe<Bigint_Comparison_Exp>;
  variant: InputMaybe<Dbt_Store_Exposed_Product_Variant_Bool_Exp>;
};

/** unique or primary key constraints on table "dbt.store_base_product_variant" */
export enum Dbt_Store_Base_Product_Variant_Constraint {
  /** unique or primary key constraint on columns "shopify_id" */
  StoreBaseProductVariantPkey = 'store_base_product_variant_pkey',
}

/** input type for incrementing numeric columns in table "dbt.store_base_product_variant" */
export type Dbt_Store_Base_Product_Variant_Inc_Input = {
  shopify_id: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "dbt.store_base_product_variant" */
export type Dbt_Store_Base_Product_Variant_Insert_Input = {
  createdAt: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['String']>;
  product: InputMaybe<Dbt_Store_Base_Product_Obj_Rel_Insert_Input>;
  productId: InputMaybe<Scalars['String']>;
  shopify_id: InputMaybe<Scalars['bigint']>;
  variant: InputMaybe<Dbt_Store_Exposed_Product_Variant_Obj_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Dbt_Store_Base_Product_Variant_Max_Fields = {
  __typename?: 'dbt_store_base_product_variant_max_fields';
  createdAt: Maybe<Scalars['timestamptz']>;
  id: Maybe<Scalars['String']>;
  productId: Maybe<Scalars['String']>;
  shopify_id: Maybe<Scalars['bigint']>;
};

/** order by max() on columns of table "dbt.store_base_product_variant" */
export type Dbt_Store_Base_Product_Variant_Max_Order_By = {
  createdAt: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  productId: InputMaybe<Order_By>;
  shopify_id: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Dbt_Store_Base_Product_Variant_Min_Fields = {
  __typename?: 'dbt_store_base_product_variant_min_fields';
  createdAt: Maybe<Scalars['timestamptz']>;
  id: Maybe<Scalars['String']>;
  productId: Maybe<Scalars['String']>;
  shopify_id: Maybe<Scalars['bigint']>;
};

/** order by min() on columns of table "dbt.store_base_product_variant" */
export type Dbt_Store_Base_Product_Variant_Min_Order_By = {
  createdAt: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  productId: InputMaybe<Order_By>;
  shopify_id: InputMaybe<Order_By>;
};

/** response of any mutation on the table "dbt.store_base_product_variant" */
export type Dbt_Store_Base_Product_Variant_Mutation_Response = {
  __typename?: 'dbt_store_base_product_variant_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Dbt_Store_Base_Product_Variant>;
};

/** input type for inserting object relation for remote table "dbt.store_base_product_variant" */
export type Dbt_Store_Base_Product_Variant_Obj_Rel_Insert_Input = {
  data: Dbt_Store_Base_Product_Variant_Insert_Input;
  /** upsert condition */
  on_conflict: InputMaybe<Dbt_Store_Base_Product_Variant_On_Conflict>;
};

/** on_conflict condition type for table "dbt.store_base_product_variant" */
export type Dbt_Store_Base_Product_Variant_On_Conflict = {
  constraint: Dbt_Store_Base_Product_Variant_Constraint;
  update_columns: Array<Dbt_Store_Base_Product_Variant_Update_Column>;
  where: InputMaybe<Dbt_Store_Base_Product_Variant_Bool_Exp>;
};

/** Ordering options when selecting data from "dbt.store_base_product_variant". */
export type Dbt_Store_Base_Product_Variant_Order_By = {
  createdAt: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  product: InputMaybe<Dbt_Store_Base_Product_Order_By>;
  productId: InputMaybe<Order_By>;
  shopify_id: InputMaybe<Order_By>;
  variant: InputMaybe<Dbt_Store_Exposed_Product_Variant_Order_By>;
};

/** primary key columns input for table: dbt.store_base_product_variant */
export type Dbt_Store_Base_Product_Variant_Pk_Columns_Input = {
  shopify_id: Scalars['bigint'];
};

/** select columns of table "dbt.store_base_product_variant" */
export enum Dbt_Store_Base_Product_Variant_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  ProductId = 'productId',
  /** column name */
  ShopifyId = 'shopify_id',
}

/** input type for updating data in table "dbt.store_base_product_variant" */
export type Dbt_Store_Base_Product_Variant_Set_Input = {
  createdAt: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['String']>;
  productId: InputMaybe<Scalars['String']>;
  shopify_id: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type Dbt_Store_Base_Product_Variant_Stddev_Fields = {
  __typename?: 'dbt_store_base_product_variant_stddev_fields';
  shopify_id: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "dbt.store_base_product_variant" */
export type Dbt_Store_Base_Product_Variant_Stddev_Order_By = {
  shopify_id: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Dbt_Store_Base_Product_Variant_Stddev_Pop_Fields = {
  __typename?: 'dbt_store_base_product_variant_stddev_pop_fields';
  shopify_id: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "dbt.store_base_product_variant" */
export type Dbt_Store_Base_Product_Variant_Stddev_Pop_Order_By = {
  shopify_id: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Dbt_Store_Base_Product_Variant_Stddev_Samp_Fields = {
  __typename?: 'dbt_store_base_product_variant_stddev_samp_fields';
  shopify_id: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "dbt.store_base_product_variant" */
export type Dbt_Store_Base_Product_Variant_Stddev_Samp_Order_By = {
  shopify_id: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "dbt_store_base_product_variant" */
export type Dbt_Store_Base_Product_Variant_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Dbt_Store_Base_Product_Variant_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Dbt_Store_Base_Product_Variant_Stream_Cursor_Value_Input = {
  createdAt: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['String']>;
  productId: InputMaybe<Scalars['String']>;
  shopify_id: InputMaybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type Dbt_Store_Base_Product_Variant_Sum_Fields = {
  __typename?: 'dbt_store_base_product_variant_sum_fields';
  shopify_id: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "dbt.store_base_product_variant" */
export type Dbt_Store_Base_Product_Variant_Sum_Order_By = {
  shopify_id: InputMaybe<Order_By>;
};

/** update columns of table "dbt.store_base_product_variant" */
export enum Dbt_Store_Base_Product_Variant_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  ProductId = 'productId',
  /** column name */
  ShopifyId = 'shopify_id',
}

export type Dbt_Store_Base_Product_Variant_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Dbt_Store_Base_Product_Variant_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Dbt_Store_Base_Product_Variant_Set_Input>;
  /** filter the rows which have to be updated */
  where: Dbt_Store_Base_Product_Variant_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Dbt_Store_Base_Product_Variant_Var_Pop_Fields = {
  __typename?: 'dbt_store_base_product_variant_var_pop_fields';
  shopify_id: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "dbt.store_base_product_variant" */
export type Dbt_Store_Base_Product_Variant_Var_Pop_Order_By = {
  shopify_id: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Dbt_Store_Base_Product_Variant_Var_Samp_Fields = {
  __typename?: 'dbt_store_base_product_variant_var_samp_fields';
  shopify_id: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "dbt.store_base_product_variant" */
export type Dbt_Store_Base_Product_Variant_Var_Samp_Order_By = {
  shopify_id: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Dbt_Store_Base_Product_Variant_Variance_Fields = {
  __typename?: 'dbt_store_base_product_variant_variance_fields';
  shopify_id: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "dbt.store_base_product_variant" */
export type Dbt_Store_Base_Product_Variant_Variance_Order_By = {
  shopify_id: InputMaybe<Order_By>;
};

/** columns and relationships of "dbt.store_discount" */
export type Dbt_Store_Discount = {
  __typename?: 'dbt_store_discount';
  code: Maybe<Scalars['String']>;
  /** An array relationship */
  collection: Array<Dbt_Store_Discount_Collection>;
  /** An aggregate relationship */
  collection_aggregate: Dbt_Store_Discount_Collection_Aggregate;
  ends_at: Maybe<Scalars['timestamptz']>;
  id: Scalars['bigint'];
  is_public: Scalars['Boolean'];
  min_amount: Maybe<Scalars['float8']>;
  starts_at: Scalars['timestamptz'];
  title: Scalars['String'];
  value: Scalars['float8'];
  value_type: Scalars['String'];
};

/** columns and relationships of "dbt.store_discount" */
export type Dbt_Store_DiscountCollectionArgs = {
  distinct_on: InputMaybe<Array<Dbt_Store_Discount_Collection_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Discount_Collection_Order_By>>;
  where: InputMaybe<Dbt_Store_Discount_Collection_Bool_Exp>;
};

/** columns and relationships of "dbt.store_discount" */
export type Dbt_Store_DiscountCollection_AggregateArgs = {
  distinct_on: InputMaybe<Array<Dbt_Store_Discount_Collection_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Discount_Collection_Order_By>>;
  where: InputMaybe<Dbt_Store_Discount_Collection_Bool_Exp>;
};

/** aggregated selection of "dbt.store_discount" */
export type Dbt_Store_Discount_Aggregate = {
  __typename?: 'dbt_store_discount_aggregate';
  aggregate: Maybe<Dbt_Store_Discount_Aggregate_Fields>;
  nodes: Array<Dbt_Store_Discount>;
};

/** aggregate fields of "dbt.store_discount" */
export type Dbt_Store_Discount_Aggregate_Fields = {
  __typename?: 'dbt_store_discount_aggregate_fields';
  avg: Maybe<Dbt_Store_Discount_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Dbt_Store_Discount_Max_Fields>;
  min: Maybe<Dbt_Store_Discount_Min_Fields>;
  stddev: Maybe<Dbt_Store_Discount_Stddev_Fields>;
  stddev_pop: Maybe<Dbt_Store_Discount_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Dbt_Store_Discount_Stddev_Samp_Fields>;
  sum: Maybe<Dbt_Store_Discount_Sum_Fields>;
  var_pop: Maybe<Dbt_Store_Discount_Var_Pop_Fields>;
  var_samp: Maybe<Dbt_Store_Discount_Var_Samp_Fields>;
  variance: Maybe<Dbt_Store_Discount_Variance_Fields>;
};

/** aggregate fields of "dbt.store_discount" */
export type Dbt_Store_Discount_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Dbt_Store_Discount_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Dbt_Store_Discount_Avg_Fields = {
  __typename?: 'dbt_store_discount_avg_fields';
  id: Maybe<Scalars['Float']>;
  min_amount: Maybe<Scalars['Float']>;
  value: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "dbt.store_discount". All fields are combined with a logical 'AND'. */
export type Dbt_Store_Discount_Bool_Exp = {
  _and: InputMaybe<Array<Dbt_Store_Discount_Bool_Exp>>;
  _not: InputMaybe<Dbt_Store_Discount_Bool_Exp>;
  _or: InputMaybe<Array<Dbt_Store_Discount_Bool_Exp>>;
  code: InputMaybe<String_Comparison_Exp>;
  collection: InputMaybe<Dbt_Store_Discount_Collection_Bool_Exp>;
  collection_aggregate: InputMaybe<Dbt_Store_Discount_Collection_Aggregate_Bool_Exp>;
  ends_at: InputMaybe<Timestamptz_Comparison_Exp>;
  id: InputMaybe<Bigint_Comparison_Exp>;
  is_public: InputMaybe<Boolean_Comparison_Exp>;
  min_amount: InputMaybe<Float8_Comparison_Exp>;
  starts_at: InputMaybe<Timestamptz_Comparison_Exp>;
  title: InputMaybe<String_Comparison_Exp>;
  value: InputMaybe<Float8_Comparison_Exp>;
  value_type: InputMaybe<String_Comparison_Exp>;
};

/** columns and relationships of "dbt.store_discount_collection" */
export type Dbt_Store_Discount_Collection = {
  __typename?: 'dbt_store_discount_collection';
  collection_internal_id: Scalars['String'];
  /** An object relationship */
  discount: Maybe<Dbt_Store_Discount>;
  discount_id: Scalars['bigint'];
};

/** aggregated selection of "dbt.store_discount_collection" */
export type Dbt_Store_Discount_Collection_Aggregate = {
  __typename?: 'dbt_store_discount_collection_aggregate';
  aggregate: Maybe<Dbt_Store_Discount_Collection_Aggregate_Fields>;
  nodes: Array<Dbt_Store_Discount_Collection>;
};

export type Dbt_Store_Discount_Collection_Aggregate_Bool_Exp = {
  count: InputMaybe<Dbt_Store_Discount_Collection_Aggregate_Bool_Exp_Count>;
};

export type Dbt_Store_Discount_Collection_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<Dbt_Store_Discount_Collection_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<Dbt_Store_Discount_Collection_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "dbt.store_discount_collection" */
export type Dbt_Store_Discount_Collection_Aggregate_Fields = {
  __typename?: 'dbt_store_discount_collection_aggregate_fields';
  avg: Maybe<Dbt_Store_Discount_Collection_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Dbt_Store_Discount_Collection_Max_Fields>;
  min: Maybe<Dbt_Store_Discount_Collection_Min_Fields>;
  stddev: Maybe<Dbt_Store_Discount_Collection_Stddev_Fields>;
  stddev_pop: Maybe<Dbt_Store_Discount_Collection_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Dbt_Store_Discount_Collection_Stddev_Samp_Fields>;
  sum: Maybe<Dbt_Store_Discount_Collection_Sum_Fields>;
  var_pop: Maybe<Dbt_Store_Discount_Collection_Var_Pop_Fields>;
  var_samp: Maybe<Dbt_Store_Discount_Collection_Var_Samp_Fields>;
  variance: Maybe<Dbt_Store_Discount_Collection_Variance_Fields>;
};

/** aggregate fields of "dbt.store_discount_collection" */
export type Dbt_Store_Discount_Collection_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Dbt_Store_Discount_Collection_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "dbt.store_discount_collection" */
export type Dbt_Store_Discount_Collection_Aggregate_Order_By = {
  avg: InputMaybe<Dbt_Store_Discount_Collection_Avg_Order_By>;
  count: InputMaybe<Order_By>;
  max: InputMaybe<Dbt_Store_Discount_Collection_Max_Order_By>;
  min: InputMaybe<Dbt_Store_Discount_Collection_Min_Order_By>;
  stddev: InputMaybe<Dbt_Store_Discount_Collection_Stddev_Order_By>;
  stddev_pop: InputMaybe<Dbt_Store_Discount_Collection_Stddev_Pop_Order_By>;
  stddev_samp: InputMaybe<Dbt_Store_Discount_Collection_Stddev_Samp_Order_By>;
  sum: InputMaybe<Dbt_Store_Discount_Collection_Sum_Order_By>;
  var_pop: InputMaybe<Dbt_Store_Discount_Collection_Var_Pop_Order_By>;
  var_samp: InputMaybe<Dbt_Store_Discount_Collection_Var_Samp_Order_By>;
  variance: InputMaybe<Dbt_Store_Discount_Collection_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "dbt.store_discount_collection" */
export type Dbt_Store_Discount_Collection_Arr_Rel_Insert_Input = {
  data: Array<Dbt_Store_Discount_Collection_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<Dbt_Store_Discount_Collection_On_Conflict>;
};

/** aggregate avg on columns */
export type Dbt_Store_Discount_Collection_Avg_Fields = {
  __typename?: 'dbt_store_discount_collection_avg_fields';
  discount_id: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "dbt.store_discount_collection" */
export type Dbt_Store_Discount_Collection_Avg_Order_By = {
  discount_id: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "dbt.store_discount_collection". All fields are combined with a logical 'AND'. */
export type Dbt_Store_Discount_Collection_Bool_Exp = {
  _and: InputMaybe<Array<Dbt_Store_Discount_Collection_Bool_Exp>>;
  _not: InputMaybe<Dbt_Store_Discount_Collection_Bool_Exp>;
  _or: InputMaybe<Array<Dbt_Store_Discount_Collection_Bool_Exp>>;
  collection_internal_id: InputMaybe<String_Comparison_Exp>;
  discount: InputMaybe<Dbt_Store_Discount_Bool_Exp>;
  discount_id: InputMaybe<Bigint_Comparison_Exp>;
};

/** unique or primary key constraints on table "dbt.store_discount_collection" */
export enum Dbt_Store_Discount_Collection_Constraint {
  /** unique or primary key constraint on columns "collection_internal_id", "discount_id" */
  StoreDiscountCollectionPkey = 'store_discount_collection_pkey',
}

/** input type for incrementing numeric columns in table "dbt.store_discount_collection" */
export type Dbt_Store_Discount_Collection_Inc_Input = {
  discount_id: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "dbt.store_discount_collection" */
export type Dbt_Store_Discount_Collection_Insert_Input = {
  collection_internal_id: InputMaybe<Scalars['String']>;
  discount: InputMaybe<Dbt_Store_Discount_Obj_Rel_Insert_Input>;
  discount_id: InputMaybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type Dbt_Store_Discount_Collection_Max_Fields = {
  __typename?: 'dbt_store_discount_collection_max_fields';
  collection_internal_id: Maybe<Scalars['String']>;
  discount_id: Maybe<Scalars['bigint']>;
};

/** order by max() on columns of table "dbt.store_discount_collection" */
export type Dbt_Store_Discount_Collection_Max_Order_By = {
  collection_internal_id: InputMaybe<Order_By>;
  discount_id: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Dbt_Store_Discount_Collection_Min_Fields = {
  __typename?: 'dbt_store_discount_collection_min_fields';
  collection_internal_id: Maybe<Scalars['String']>;
  discount_id: Maybe<Scalars['bigint']>;
};

/** order by min() on columns of table "dbt.store_discount_collection" */
export type Dbt_Store_Discount_Collection_Min_Order_By = {
  collection_internal_id: InputMaybe<Order_By>;
  discount_id: InputMaybe<Order_By>;
};

/** response of any mutation on the table "dbt.store_discount_collection" */
export type Dbt_Store_Discount_Collection_Mutation_Response = {
  __typename?: 'dbt_store_discount_collection_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Dbt_Store_Discount_Collection>;
};

/** on_conflict condition type for table "dbt.store_discount_collection" */
export type Dbt_Store_Discount_Collection_On_Conflict = {
  constraint: Dbt_Store_Discount_Collection_Constraint;
  update_columns: Array<Dbt_Store_Discount_Collection_Update_Column>;
  where: InputMaybe<Dbt_Store_Discount_Collection_Bool_Exp>;
};

/** Ordering options when selecting data from "dbt.store_discount_collection". */
export type Dbt_Store_Discount_Collection_Order_By = {
  collection_internal_id: InputMaybe<Order_By>;
  discount: InputMaybe<Dbt_Store_Discount_Order_By>;
  discount_id: InputMaybe<Order_By>;
};

/** primary key columns input for table: dbt.store_discount_collection */
export type Dbt_Store_Discount_Collection_Pk_Columns_Input = {
  collection_internal_id: Scalars['String'];
  discount_id: Scalars['bigint'];
};

/** select columns of table "dbt.store_discount_collection" */
export enum Dbt_Store_Discount_Collection_Select_Column {
  /** column name */
  CollectionInternalId = 'collection_internal_id',
  /** column name */
  DiscountId = 'discount_id',
}

/** input type for updating data in table "dbt.store_discount_collection" */
export type Dbt_Store_Discount_Collection_Set_Input = {
  collection_internal_id: InputMaybe<Scalars['String']>;
  discount_id: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type Dbt_Store_Discount_Collection_Stddev_Fields = {
  __typename?: 'dbt_store_discount_collection_stddev_fields';
  discount_id: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "dbt.store_discount_collection" */
export type Dbt_Store_Discount_Collection_Stddev_Order_By = {
  discount_id: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Dbt_Store_Discount_Collection_Stddev_Pop_Fields = {
  __typename?: 'dbt_store_discount_collection_stddev_pop_fields';
  discount_id: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "dbt.store_discount_collection" */
export type Dbt_Store_Discount_Collection_Stddev_Pop_Order_By = {
  discount_id: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Dbt_Store_Discount_Collection_Stddev_Samp_Fields = {
  __typename?: 'dbt_store_discount_collection_stddev_samp_fields';
  discount_id: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "dbt.store_discount_collection" */
export type Dbt_Store_Discount_Collection_Stddev_Samp_Order_By = {
  discount_id: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "dbt_store_discount_collection" */
export type Dbt_Store_Discount_Collection_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Dbt_Store_Discount_Collection_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Dbt_Store_Discount_Collection_Stream_Cursor_Value_Input = {
  collection_internal_id: InputMaybe<Scalars['String']>;
  discount_id: InputMaybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type Dbt_Store_Discount_Collection_Sum_Fields = {
  __typename?: 'dbt_store_discount_collection_sum_fields';
  discount_id: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "dbt.store_discount_collection" */
export type Dbt_Store_Discount_Collection_Sum_Order_By = {
  discount_id: InputMaybe<Order_By>;
};

/** update columns of table "dbt.store_discount_collection" */
export enum Dbt_Store_Discount_Collection_Update_Column {
  /** column name */
  CollectionInternalId = 'collection_internal_id',
  /** column name */
  DiscountId = 'discount_id',
}

export type Dbt_Store_Discount_Collection_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Dbt_Store_Discount_Collection_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Dbt_Store_Discount_Collection_Set_Input>;
  /** filter the rows which have to be updated */
  where: Dbt_Store_Discount_Collection_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Dbt_Store_Discount_Collection_Var_Pop_Fields = {
  __typename?: 'dbt_store_discount_collection_var_pop_fields';
  discount_id: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "dbt.store_discount_collection" */
export type Dbt_Store_Discount_Collection_Var_Pop_Order_By = {
  discount_id: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Dbt_Store_Discount_Collection_Var_Samp_Fields = {
  __typename?: 'dbt_store_discount_collection_var_samp_fields';
  discount_id: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "dbt.store_discount_collection" */
export type Dbt_Store_Discount_Collection_Var_Samp_Order_By = {
  discount_id: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Dbt_Store_Discount_Collection_Variance_Fields = {
  __typename?: 'dbt_store_discount_collection_variance_fields';
  discount_id: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "dbt.store_discount_collection" */
export type Dbt_Store_Discount_Collection_Variance_Order_By = {
  discount_id: InputMaybe<Order_By>;
};

/** unique or primary key constraints on table "dbt.store_discount" */
export enum Dbt_Store_Discount_Constraint {
  /** unique or primary key constraint on columns "id" */
  StoreDiscountIdKey = 'store_discount_id_key',
}

/** input type for incrementing numeric columns in table "dbt.store_discount" */
export type Dbt_Store_Discount_Inc_Input = {
  id: InputMaybe<Scalars['bigint']>;
  min_amount: InputMaybe<Scalars['float8']>;
  value: InputMaybe<Scalars['float8']>;
};

/** input type for inserting data into table "dbt.store_discount" */
export type Dbt_Store_Discount_Insert_Input = {
  code: InputMaybe<Scalars['String']>;
  collection: InputMaybe<Dbt_Store_Discount_Collection_Arr_Rel_Insert_Input>;
  ends_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['bigint']>;
  is_public: InputMaybe<Scalars['Boolean']>;
  min_amount: InputMaybe<Scalars['float8']>;
  starts_at: InputMaybe<Scalars['timestamptz']>;
  title: InputMaybe<Scalars['String']>;
  value: InputMaybe<Scalars['float8']>;
  value_type: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Dbt_Store_Discount_Max_Fields = {
  __typename?: 'dbt_store_discount_max_fields';
  code: Maybe<Scalars['String']>;
  ends_at: Maybe<Scalars['timestamptz']>;
  id: Maybe<Scalars['bigint']>;
  min_amount: Maybe<Scalars['float8']>;
  starts_at: Maybe<Scalars['timestamptz']>;
  title: Maybe<Scalars['String']>;
  value: Maybe<Scalars['float8']>;
  value_type: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Dbt_Store_Discount_Min_Fields = {
  __typename?: 'dbt_store_discount_min_fields';
  code: Maybe<Scalars['String']>;
  ends_at: Maybe<Scalars['timestamptz']>;
  id: Maybe<Scalars['bigint']>;
  min_amount: Maybe<Scalars['float8']>;
  starts_at: Maybe<Scalars['timestamptz']>;
  title: Maybe<Scalars['String']>;
  value: Maybe<Scalars['float8']>;
  value_type: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "dbt.store_discount" */
export type Dbt_Store_Discount_Mutation_Response = {
  __typename?: 'dbt_store_discount_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Dbt_Store_Discount>;
};

/** input type for inserting object relation for remote table "dbt.store_discount" */
export type Dbt_Store_Discount_Obj_Rel_Insert_Input = {
  data: Dbt_Store_Discount_Insert_Input;
  /** upsert condition */
  on_conflict: InputMaybe<Dbt_Store_Discount_On_Conflict>;
};

/** on_conflict condition type for table "dbt.store_discount" */
export type Dbt_Store_Discount_On_Conflict = {
  constraint: Dbt_Store_Discount_Constraint;
  update_columns: Array<Dbt_Store_Discount_Update_Column>;
  where: InputMaybe<Dbt_Store_Discount_Bool_Exp>;
};

/** Ordering options when selecting data from "dbt.store_discount". */
export type Dbt_Store_Discount_Order_By = {
  code: InputMaybe<Order_By>;
  collection_aggregate: InputMaybe<Dbt_Store_Discount_Collection_Aggregate_Order_By>;
  ends_at: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  is_public: InputMaybe<Order_By>;
  min_amount: InputMaybe<Order_By>;
  starts_at: InputMaybe<Order_By>;
  title: InputMaybe<Order_By>;
  value: InputMaybe<Order_By>;
  value_type: InputMaybe<Order_By>;
};

/** select columns of table "dbt.store_discount" */
export enum Dbt_Store_Discount_Select_Column {
  /** column name */
  Code = 'code',
  /** column name */
  EndsAt = 'ends_at',
  /** column name */
  Id = 'id',
  /** column name */
  IsPublic = 'is_public',
  /** column name */
  MinAmount = 'min_amount',
  /** column name */
  StartsAt = 'starts_at',
  /** column name */
  Title = 'title',
  /** column name */
  Value = 'value',
  /** column name */
  ValueType = 'value_type',
}

/** input type for updating data in table "dbt.store_discount" */
export type Dbt_Store_Discount_Set_Input = {
  code: InputMaybe<Scalars['String']>;
  ends_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['bigint']>;
  is_public: InputMaybe<Scalars['Boolean']>;
  min_amount: InputMaybe<Scalars['float8']>;
  starts_at: InputMaybe<Scalars['timestamptz']>;
  title: InputMaybe<Scalars['String']>;
  value: InputMaybe<Scalars['float8']>;
  value_type: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Dbt_Store_Discount_Stddev_Fields = {
  __typename?: 'dbt_store_discount_stddev_fields';
  id: Maybe<Scalars['Float']>;
  min_amount: Maybe<Scalars['Float']>;
  value: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Dbt_Store_Discount_Stddev_Pop_Fields = {
  __typename?: 'dbt_store_discount_stddev_pop_fields';
  id: Maybe<Scalars['Float']>;
  min_amount: Maybe<Scalars['Float']>;
  value: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Dbt_Store_Discount_Stddev_Samp_Fields = {
  __typename?: 'dbt_store_discount_stddev_samp_fields';
  id: Maybe<Scalars['Float']>;
  min_amount: Maybe<Scalars['Float']>;
  value: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "dbt_store_discount" */
export type Dbt_Store_Discount_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Dbt_Store_Discount_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Dbt_Store_Discount_Stream_Cursor_Value_Input = {
  code: InputMaybe<Scalars['String']>;
  ends_at: InputMaybe<Scalars['timestamptz']>;
  id: InputMaybe<Scalars['bigint']>;
  is_public: InputMaybe<Scalars['Boolean']>;
  min_amount: InputMaybe<Scalars['float8']>;
  starts_at: InputMaybe<Scalars['timestamptz']>;
  title: InputMaybe<Scalars['String']>;
  value: InputMaybe<Scalars['float8']>;
  value_type: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type Dbt_Store_Discount_Sum_Fields = {
  __typename?: 'dbt_store_discount_sum_fields';
  id: Maybe<Scalars['bigint']>;
  min_amount: Maybe<Scalars['float8']>;
  value: Maybe<Scalars['float8']>;
};

/** update columns of table "dbt.store_discount" */
export enum Dbt_Store_Discount_Update_Column {
  /** column name */
  Code = 'code',
  /** column name */
  EndsAt = 'ends_at',
  /** column name */
  Id = 'id',
  /** column name */
  IsPublic = 'is_public',
  /** column name */
  MinAmount = 'min_amount',
  /** column name */
  StartsAt = 'starts_at',
  /** column name */
  Title = 'title',
  /** column name */
  Value = 'value',
  /** column name */
  ValueType = 'value_type',
}

export type Dbt_Store_Discount_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Dbt_Store_Discount_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Dbt_Store_Discount_Set_Input>;
  /** filter the rows which have to be updated */
  where: Dbt_Store_Discount_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Dbt_Store_Discount_Var_Pop_Fields = {
  __typename?: 'dbt_store_discount_var_pop_fields';
  id: Maybe<Scalars['Float']>;
  min_amount: Maybe<Scalars['Float']>;
  value: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Dbt_Store_Discount_Var_Samp_Fields = {
  __typename?: 'dbt_store_discount_var_samp_fields';
  id: Maybe<Scalars['Float']>;
  min_amount: Maybe<Scalars['Float']>;
  value: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Dbt_Store_Discount_Variance_Fields = {
  __typename?: 'dbt_store_discount_variance_fields';
  id: Maybe<Scalars['Float']>;
  min_amount: Maybe<Scalars['Float']>;
  value: Maybe<Scalars['Float']>;
};

/** columns and relationships of "dbt.store_exposed_product" */
export type Dbt_Store_Exposed_Product = {
  __typename?: 'dbt_store_exposed_product';
  brand: Maybe<Scalars['String']>;
  description: Maybe<Scalars['String']>;
  firstImage: Maybe<Scalars['String']>;
  gender: Maybe<Scalars['String']>;
  handle: Scalars['String'];
  id: Scalars['String'];
  model: Maybe<Scalars['String']>;
  modelYear: Maybe<Scalars['String']>;
  numberOfViews: Scalars['bigint'];
  /** An object relationship */
  product: Maybe<Dbt_Store_Base_Product>;
  productType: Scalars['String'];
  publishedAt: Maybe<Scalars['timestamptz']>;
  size: Maybe<Scalars['String']>;
  status: Scalars['ProductStatus'];
  syncDate: Scalars['date'];
  title: Scalars['String'];
  vendor: Scalars['String'];
};

/** aggregated selection of "dbt.store_exposed_product" */
export type Dbt_Store_Exposed_Product_Aggregate = {
  __typename?: 'dbt_store_exposed_product_aggregate';
  aggregate: Maybe<Dbt_Store_Exposed_Product_Aggregate_Fields>;
  nodes: Array<Dbt_Store_Exposed_Product>;
};

/** aggregate fields of "dbt.store_exposed_product" */
export type Dbt_Store_Exposed_Product_Aggregate_Fields = {
  __typename?: 'dbt_store_exposed_product_aggregate_fields';
  avg: Maybe<Dbt_Store_Exposed_Product_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Dbt_Store_Exposed_Product_Max_Fields>;
  min: Maybe<Dbt_Store_Exposed_Product_Min_Fields>;
  stddev: Maybe<Dbt_Store_Exposed_Product_Stddev_Fields>;
  stddev_pop: Maybe<Dbt_Store_Exposed_Product_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Dbt_Store_Exposed_Product_Stddev_Samp_Fields>;
  sum: Maybe<Dbt_Store_Exposed_Product_Sum_Fields>;
  var_pop: Maybe<Dbt_Store_Exposed_Product_Var_Pop_Fields>;
  var_samp: Maybe<Dbt_Store_Exposed_Product_Var_Samp_Fields>;
  variance: Maybe<Dbt_Store_Exposed_Product_Variance_Fields>;
};

/** aggregate fields of "dbt.store_exposed_product" */
export type Dbt_Store_Exposed_Product_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Dbt_Store_Exposed_Product_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Dbt_Store_Exposed_Product_Avg_Fields = {
  __typename?: 'dbt_store_exposed_product_avg_fields';
  numberOfViews: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "dbt.store_exposed_product". All fields are combined with a logical 'AND'. */
export type Dbt_Store_Exposed_Product_Bool_Exp = {
  _and: InputMaybe<Array<Dbt_Store_Exposed_Product_Bool_Exp>>;
  _not: InputMaybe<Dbt_Store_Exposed_Product_Bool_Exp>;
  _or: InputMaybe<Array<Dbt_Store_Exposed_Product_Bool_Exp>>;
  brand: InputMaybe<String_Comparison_Exp>;
  description: InputMaybe<String_Comparison_Exp>;
  firstImage: InputMaybe<String_Comparison_Exp>;
  gender: InputMaybe<String_Comparison_Exp>;
  handle: InputMaybe<String_Comparison_Exp>;
  id: InputMaybe<String_Comparison_Exp>;
  model: InputMaybe<String_Comparison_Exp>;
  modelYear: InputMaybe<String_Comparison_Exp>;
  numberOfViews: InputMaybe<Bigint_Comparison_Exp>;
  product: InputMaybe<Dbt_Store_Base_Product_Bool_Exp>;
  productType: InputMaybe<String_Comparison_Exp>;
  publishedAt: InputMaybe<Timestamptz_Comparison_Exp>;
  size: InputMaybe<String_Comparison_Exp>;
  status: InputMaybe<ProductStatus_Comparison_Exp>;
  syncDate: InputMaybe<Date_Comparison_Exp>;
  title: InputMaybe<String_Comparison_Exp>;
  vendor: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "dbt.store_exposed_product" */
export enum Dbt_Store_Exposed_Product_Constraint {
  /** unique or primary key constraint on columns "id" */
  StoreExposedProductPkey = 'store_exposed_product_pkey',
}

/** columns and relationships of "dbt.store_exposed_product_image" */
export type Dbt_Store_Exposed_Product_Image = {
  __typename?: 'dbt_store_exposed_product_image';
  alt: Maybe<Scalars['String']>;
  height: Scalars['bigint'];
  position: Scalars['bigint'];
  productId: Scalars['String'];
  shopify_id: Scalars['bigint'];
  src: Scalars['String'];
  syncDate: Scalars['date'];
  width: Scalars['bigint'];
};

/** aggregated selection of "dbt.store_exposed_product_image" */
export type Dbt_Store_Exposed_Product_Image_Aggregate = {
  __typename?: 'dbt_store_exposed_product_image_aggregate';
  aggregate: Maybe<Dbt_Store_Exposed_Product_Image_Aggregate_Fields>;
  nodes: Array<Dbt_Store_Exposed_Product_Image>;
};

export type Dbt_Store_Exposed_Product_Image_Aggregate_Bool_Exp = {
  count: InputMaybe<Dbt_Store_Exposed_Product_Image_Aggregate_Bool_Exp_Count>;
};

export type Dbt_Store_Exposed_Product_Image_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<Dbt_Store_Exposed_Product_Image_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<Dbt_Store_Exposed_Product_Image_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "dbt.store_exposed_product_image" */
export type Dbt_Store_Exposed_Product_Image_Aggregate_Fields = {
  __typename?: 'dbt_store_exposed_product_image_aggregate_fields';
  avg: Maybe<Dbt_Store_Exposed_Product_Image_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Dbt_Store_Exposed_Product_Image_Max_Fields>;
  min: Maybe<Dbt_Store_Exposed_Product_Image_Min_Fields>;
  stddev: Maybe<Dbt_Store_Exposed_Product_Image_Stddev_Fields>;
  stddev_pop: Maybe<Dbt_Store_Exposed_Product_Image_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Dbt_Store_Exposed_Product_Image_Stddev_Samp_Fields>;
  sum: Maybe<Dbt_Store_Exposed_Product_Image_Sum_Fields>;
  var_pop: Maybe<Dbt_Store_Exposed_Product_Image_Var_Pop_Fields>;
  var_samp: Maybe<Dbt_Store_Exposed_Product_Image_Var_Samp_Fields>;
  variance: Maybe<Dbt_Store_Exposed_Product_Image_Variance_Fields>;
};

/** aggregate fields of "dbt.store_exposed_product_image" */
export type Dbt_Store_Exposed_Product_Image_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Dbt_Store_Exposed_Product_Image_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "dbt.store_exposed_product_image" */
export type Dbt_Store_Exposed_Product_Image_Aggregate_Order_By = {
  avg: InputMaybe<Dbt_Store_Exposed_Product_Image_Avg_Order_By>;
  count: InputMaybe<Order_By>;
  max: InputMaybe<Dbt_Store_Exposed_Product_Image_Max_Order_By>;
  min: InputMaybe<Dbt_Store_Exposed_Product_Image_Min_Order_By>;
  stddev: InputMaybe<Dbt_Store_Exposed_Product_Image_Stddev_Order_By>;
  stddev_pop: InputMaybe<Dbt_Store_Exposed_Product_Image_Stddev_Pop_Order_By>;
  stddev_samp: InputMaybe<Dbt_Store_Exposed_Product_Image_Stddev_Samp_Order_By>;
  sum: InputMaybe<Dbt_Store_Exposed_Product_Image_Sum_Order_By>;
  var_pop: InputMaybe<Dbt_Store_Exposed_Product_Image_Var_Pop_Order_By>;
  var_samp: InputMaybe<Dbt_Store_Exposed_Product_Image_Var_Samp_Order_By>;
  variance: InputMaybe<Dbt_Store_Exposed_Product_Image_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "dbt.store_exposed_product_image" */
export type Dbt_Store_Exposed_Product_Image_Arr_Rel_Insert_Input = {
  data: Array<Dbt_Store_Exposed_Product_Image_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<Dbt_Store_Exposed_Product_Image_On_Conflict>;
};

/** aggregate avg on columns */
export type Dbt_Store_Exposed_Product_Image_Avg_Fields = {
  __typename?: 'dbt_store_exposed_product_image_avg_fields';
  height: Maybe<Scalars['Float']>;
  position: Maybe<Scalars['Float']>;
  shopify_id: Maybe<Scalars['Float']>;
  width: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "dbt.store_exposed_product_image" */
export type Dbt_Store_Exposed_Product_Image_Avg_Order_By = {
  height: InputMaybe<Order_By>;
  position: InputMaybe<Order_By>;
  shopify_id: InputMaybe<Order_By>;
  width: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "dbt.store_exposed_product_image". All fields are combined with a logical 'AND'. */
export type Dbt_Store_Exposed_Product_Image_Bool_Exp = {
  _and: InputMaybe<Array<Dbt_Store_Exposed_Product_Image_Bool_Exp>>;
  _not: InputMaybe<Dbt_Store_Exposed_Product_Image_Bool_Exp>;
  _or: InputMaybe<Array<Dbt_Store_Exposed_Product_Image_Bool_Exp>>;
  alt: InputMaybe<String_Comparison_Exp>;
  height: InputMaybe<Bigint_Comparison_Exp>;
  position: InputMaybe<Bigint_Comparison_Exp>;
  productId: InputMaybe<String_Comparison_Exp>;
  shopify_id: InputMaybe<Bigint_Comparison_Exp>;
  src: InputMaybe<String_Comparison_Exp>;
  syncDate: InputMaybe<Date_Comparison_Exp>;
  width: InputMaybe<Bigint_Comparison_Exp>;
};

/** unique or primary key constraints on table "dbt.store_exposed_product_image" */
export enum Dbt_Store_Exposed_Product_Image_Constraint {
  /** unique or primary key constraint on columns "shopify_id" */
  StoreExposedProductImagePkey = 'store_exposed_product_image_pkey',
}

/** input type for incrementing numeric columns in table "dbt.store_exposed_product_image" */
export type Dbt_Store_Exposed_Product_Image_Inc_Input = {
  height: InputMaybe<Scalars['bigint']>;
  position: InputMaybe<Scalars['bigint']>;
  shopify_id: InputMaybe<Scalars['bigint']>;
  width: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "dbt.store_exposed_product_image" */
export type Dbt_Store_Exposed_Product_Image_Insert_Input = {
  alt: InputMaybe<Scalars['String']>;
  height: InputMaybe<Scalars['bigint']>;
  position: InputMaybe<Scalars['bigint']>;
  productId: InputMaybe<Scalars['String']>;
  shopify_id: InputMaybe<Scalars['bigint']>;
  src: InputMaybe<Scalars['String']>;
  syncDate: InputMaybe<Scalars['date']>;
  width: InputMaybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type Dbt_Store_Exposed_Product_Image_Max_Fields = {
  __typename?: 'dbt_store_exposed_product_image_max_fields';
  alt: Maybe<Scalars['String']>;
  height: Maybe<Scalars['bigint']>;
  position: Maybe<Scalars['bigint']>;
  productId: Maybe<Scalars['String']>;
  shopify_id: Maybe<Scalars['bigint']>;
  src: Maybe<Scalars['String']>;
  syncDate: Maybe<Scalars['date']>;
  width: Maybe<Scalars['bigint']>;
};

/** order by max() on columns of table "dbt.store_exposed_product_image" */
export type Dbt_Store_Exposed_Product_Image_Max_Order_By = {
  alt: InputMaybe<Order_By>;
  height: InputMaybe<Order_By>;
  position: InputMaybe<Order_By>;
  productId: InputMaybe<Order_By>;
  shopify_id: InputMaybe<Order_By>;
  src: InputMaybe<Order_By>;
  syncDate: InputMaybe<Order_By>;
  width: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Dbt_Store_Exposed_Product_Image_Min_Fields = {
  __typename?: 'dbt_store_exposed_product_image_min_fields';
  alt: Maybe<Scalars['String']>;
  height: Maybe<Scalars['bigint']>;
  position: Maybe<Scalars['bigint']>;
  productId: Maybe<Scalars['String']>;
  shopify_id: Maybe<Scalars['bigint']>;
  src: Maybe<Scalars['String']>;
  syncDate: Maybe<Scalars['date']>;
  width: Maybe<Scalars['bigint']>;
};

/** order by min() on columns of table "dbt.store_exposed_product_image" */
export type Dbt_Store_Exposed_Product_Image_Min_Order_By = {
  alt: InputMaybe<Order_By>;
  height: InputMaybe<Order_By>;
  position: InputMaybe<Order_By>;
  productId: InputMaybe<Order_By>;
  shopify_id: InputMaybe<Order_By>;
  src: InputMaybe<Order_By>;
  syncDate: InputMaybe<Order_By>;
  width: InputMaybe<Order_By>;
};

/** response of any mutation on the table "dbt.store_exposed_product_image" */
export type Dbt_Store_Exposed_Product_Image_Mutation_Response = {
  __typename?: 'dbt_store_exposed_product_image_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Dbt_Store_Exposed_Product_Image>;
};

/** on_conflict condition type for table "dbt.store_exposed_product_image" */
export type Dbt_Store_Exposed_Product_Image_On_Conflict = {
  constraint: Dbt_Store_Exposed_Product_Image_Constraint;
  update_columns: Array<Dbt_Store_Exposed_Product_Image_Update_Column>;
  where: InputMaybe<Dbt_Store_Exposed_Product_Image_Bool_Exp>;
};

/** Ordering options when selecting data from "dbt.store_exposed_product_image". */
export type Dbt_Store_Exposed_Product_Image_Order_By = {
  alt: InputMaybe<Order_By>;
  height: InputMaybe<Order_By>;
  position: InputMaybe<Order_By>;
  productId: InputMaybe<Order_By>;
  shopify_id: InputMaybe<Order_By>;
  src: InputMaybe<Order_By>;
  syncDate: InputMaybe<Order_By>;
  width: InputMaybe<Order_By>;
};

/** primary key columns input for table: dbt.store_exposed_product_image */
export type Dbt_Store_Exposed_Product_Image_Pk_Columns_Input = {
  shopify_id: Scalars['bigint'];
};

/** select columns of table "dbt.store_exposed_product_image" */
export enum Dbt_Store_Exposed_Product_Image_Select_Column {
  /** column name */
  Alt = 'alt',
  /** column name */
  Height = 'height',
  /** column name */
  Position = 'position',
  /** column name */
  ProductId = 'productId',
  /** column name */
  ShopifyId = 'shopify_id',
  /** column name */
  Src = 'src',
  /** column name */
  SyncDate = 'syncDate',
  /** column name */
  Width = 'width',
}

/** input type for updating data in table "dbt.store_exposed_product_image" */
export type Dbt_Store_Exposed_Product_Image_Set_Input = {
  alt: InputMaybe<Scalars['String']>;
  height: InputMaybe<Scalars['bigint']>;
  position: InputMaybe<Scalars['bigint']>;
  productId: InputMaybe<Scalars['String']>;
  shopify_id: InputMaybe<Scalars['bigint']>;
  src: InputMaybe<Scalars['String']>;
  syncDate: InputMaybe<Scalars['date']>;
  width: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type Dbt_Store_Exposed_Product_Image_Stddev_Fields = {
  __typename?: 'dbt_store_exposed_product_image_stddev_fields';
  height: Maybe<Scalars['Float']>;
  position: Maybe<Scalars['Float']>;
  shopify_id: Maybe<Scalars['Float']>;
  width: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "dbt.store_exposed_product_image" */
export type Dbt_Store_Exposed_Product_Image_Stddev_Order_By = {
  height: InputMaybe<Order_By>;
  position: InputMaybe<Order_By>;
  shopify_id: InputMaybe<Order_By>;
  width: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Dbt_Store_Exposed_Product_Image_Stddev_Pop_Fields = {
  __typename?: 'dbt_store_exposed_product_image_stddev_pop_fields';
  height: Maybe<Scalars['Float']>;
  position: Maybe<Scalars['Float']>;
  shopify_id: Maybe<Scalars['Float']>;
  width: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "dbt.store_exposed_product_image" */
export type Dbt_Store_Exposed_Product_Image_Stddev_Pop_Order_By = {
  height: InputMaybe<Order_By>;
  position: InputMaybe<Order_By>;
  shopify_id: InputMaybe<Order_By>;
  width: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Dbt_Store_Exposed_Product_Image_Stddev_Samp_Fields = {
  __typename?: 'dbt_store_exposed_product_image_stddev_samp_fields';
  height: Maybe<Scalars['Float']>;
  position: Maybe<Scalars['Float']>;
  shopify_id: Maybe<Scalars['Float']>;
  width: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "dbt.store_exposed_product_image" */
export type Dbt_Store_Exposed_Product_Image_Stddev_Samp_Order_By = {
  height: InputMaybe<Order_By>;
  position: InputMaybe<Order_By>;
  shopify_id: InputMaybe<Order_By>;
  width: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "dbt_store_exposed_product_image" */
export type Dbt_Store_Exposed_Product_Image_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Dbt_Store_Exposed_Product_Image_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Dbt_Store_Exposed_Product_Image_Stream_Cursor_Value_Input = {
  alt: InputMaybe<Scalars['String']>;
  height: InputMaybe<Scalars['bigint']>;
  position: InputMaybe<Scalars['bigint']>;
  productId: InputMaybe<Scalars['String']>;
  shopify_id: InputMaybe<Scalars['bigint']>;
  src: InputMaybe<Scalars['String']>;
  syncDate: InputMaybe<Scalars['date']>;
  width: InputMaybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type Dbt_Store_Exposed_Product_Image_Sum_Fields = {
  __typename?: 'dbt_store_exposed_product_image_sum_fields';
  height: Maybe<Scalars['bigint']>;
  position: Maybe<Scalars['bigint']>;
  shopify_id: Maybe<Scalars['bigint']>;
  width: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "dbt.store_exposed_product_image" */
export type Dbt_Store_Exposed_Product_Image_Sum_Order_By = {
  height: InputMaybe<Order_By>;
  position: InputMaybe<Order_By>;
  shopify_id: InputMaybe<Order_By>;
  width: InputMaybe<Order_By>;
};

/** update columns of table "dbt.store_exposed_product_image" */
export enum Dbt_Store_Exposed_Product_Image_Update_Column {
  /** column name */
  Alt = 'alt',
  /** column name */
  Height = 'height',
  /** column name */
  Position = 'position',
  /** column name */
  ProductId = 'productId',
  /** column name */
  ShopifyId = 'shopify_id',
  /** column name */
  Src = 'src',
  /** column name */
  SyncDate = 'syncDate',
  /** column name */
  Width = 'width',
}

export type Dbt_Store_Exposed_Product_Image_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Dbt_Store_Exposed_Product_Image_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Dbt_Store_Exposed_Product_Image_Set_Input>;
  /** filter the rows which have to be updated */
  where: Dbt_Store_Exposed_Product_Image_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Dbt_Store_Exposed_Product_Image_Var_Pop_Fields = {
  __typename?: 'dbt_store_exposed_product_image_var_pop_fields';
  height: Maybe<Scalars['Float']>;
  position: Maybe<Scalars['Float']>;
  shopify_id: Maybe<Scalars['Float']>;
  width: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "dbt.store_exposed_product_image" */
export type Dbt_Store_Exposed_Product_Image_Var_Pop_Order_By = {
  height: InputMaybe<Order_By>;
  position: InputMaybe<Order_By>;
  shopify_id: InputMaybe<Order_By>;
  width: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Dbt_Store_Exposed_Product_Image_Var_Samp_Fields = {
  __typename?: 'dbt_store_exposed_product_image_var_samp_fields';
  height: Maybe<Scalars['Float']>;
  position: Maybe<Scalars['Float']>;
  shopify_id: Maybe<Scalars['Float']>;
  width: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "dbt.store_exposed_product_image" */
export type Dbt_Store_Exposed_Product_Image_Var_Samp_Order_By = {
  height: InputMaybe<Order_By>;
  position: InputMaybe<Order_By>;
  shopify_id: InputMaybe<Order_By>;
  width: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Dbt_Store_Exposed_Product_Image_Variance_Fields = {
  __typename?: 'dbt_store_exposed_product_image_variance_fields';
  height: Maybe<Scalars['Float']>;
  position: Maybe<Scalars['Float']>;
  shopify_id: Maybe<Scalars['Float']>;
  width: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "dbt.store_exposed_product_image" */
export type Dbt_Store_Exposed_Product_Image_Variance_Order_By = {
  height: InputMaybe<Order_By>;
  position: InputMaybe<Order_By>;
  shopify_id: InputMaybe<Order_By>;
  width: InputMaybe<Order_By>;
};

/** input type for incrementing numeric columns in table "dbt.store_exposed_product" */
export type Dbt_Store_Exposed_Product_Inc_Input = {
  numberOfViews: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "dbt.store_exposed_product" */
export type Dbt_Store_Exposed_Product_Insert_Input = {
  brand: InputMaybe<Scalars['String']>;
  description: InputMaybe<Scalars['String']>;
  firstImage: InputMaybe<Scalars['String']>;
  gender: InputMaybe<Scalars['String']>;
  handle: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  model: InputMaybe<Scalars['String']>;
  modelYear: InputMaybe<Scalars['String']>;
  numberOfViews: InputMaybe<Scalars['bigint']>;
  product: InputMaybe<Dbt_Store_Base_Product_Obj_Rel_Insert_Input>;
  productType: InputMaybe<Scalars['String']>;
  publishedAt: InputMaybe<Scalars['timestamptz']>;
  size: InputMaybe<Scalars['String']>;
  status: InputMaybe<Scalars['ProductStatus']>;
  syncDate: InputMaybe<Scalars['date']>;
  title: InputMaybe<Scalars['String']>;
  vendor: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Dbt_Store_Exposed_Product_Max_Fields = {
  __typename?: 'dbt_store_exposed_product_max_fields';
  brand: Maybe<Scalars['String']>;
  description: Maybe<Scalars['String']>;
  firstImage: Maybe<Scalars['String']>;
  gender: Maybe<Scalars['String']>;
  handle: Maybe<Scalars['String']>;
  id: Maybe<Scalars['String']>;
  model: Maybe<Scalars['String']>;
  modelYear: Maybe<Scalars['String']>;
  numberOfViews: Maybe<Scalars['bigint']>;
  productType: Maybe<Scalars['String']>;
  publishedAt: Maybe<Scalars['timestamptz']>;
  size: Maybe<Scalars['String']>;
  status: Maybe<Scalars['ProductStatus']>;
  syncDate: Maybe<Scalars['date']>;
  title: Maybe<Scalars['String']>;
  vendor: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Dbt_Store_Exposed_Product_Min_Fields = {
  __typename?: 'dbt_store_exposed_product_min_fields';
  brand: Maybe<Scalars['String']>;
  description: Maybe<Scalars['String']>;
  firstImage: Maybe<Scalars['String']>;
  gender: Maybe<Scalars['String']>;
  handle: Maybe<Scalars['String']>;
  id: Maybe<Scalars['String']>;
  model: Maybe<Scalars['String']>;
  modelYear: Maybe<Scalars['String']>;
  numberOfViews: Maybe<Scalars['bigint']>;
  productType: Maybe<Scalars['String']>;
  publishedAt: Maybe<Scalars['timestamptz']>;
  size: Maybe<Scalars['String']>;
  status: Maybe<Scalars['ProductStatus']>;
  syncDate: Maybe<Scalars['date']>;
  title: Maybe<Scalars['String']>;
  vendor: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "dbt.store_exposed_product" */
export type Dbt_Store_Exposed_Product_Mutation_Response = {
  __typename?: 'dbt_store_exposed_product_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Dbt_Store_Exposed_Product>;
};

/** input type for inserting object relation for remote table "dbt.store_exposed_product" */
export type Dbt_Store_Exposed_Product_Obj_Rel_Insert_Input = {
  data: Dbt_Store_Exposed_Product_Insert_Input;
  /** upsert condition */
  on_conflict: InputMaybe<Dbt_Store_Exposed_Product_On_Conflict>;
};

/** on_conflict condition type for table "dbt.store_exposed_product" */
export type Dbt_Store_Exposed_Product_On_Conflict = {
  constraint: Dbt_Store_Exposed_Product_Constraint;
  update_columns: Array<Dbt_Store_Exposed_Product_Update_Column>;
  where: InputMaybe<Dbt_Store_Exposed_Product_Bool_Exp>;
};

/** Ordering options when selecting data from "dbt.store_exposed_product". */
export type Dbt_Store_Exposed_Product_Order_By = {
  brand: InputMaybe<Order_By>;
  description: InputMaybe<Order_By>;
  firstImage: InputMaybe<Order_By>;
  gender: InputMaybe<Order_By>;
  handle: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  model: InputMaybe<Order_By>;
  modelYear: InputMaybe<Order_By>;
  numberOfViews: InputMaybe<Order_By>;
  product: InputMaybe<Dbt_Store_Base_Product_Order_By>;
  productType: InputMaybe<Order_By>;
  publishedAt: InputMaybe<Order_By>;
  size: InputMaybe<Order_By>;
  status: InputMaybe<Order_By>;
  syncDate: InputMaybe<Order_By>;
  title: InputMaybe<Order_By>;
  vendor: InputMaybe<Order_By>;
};

/** primary key columns input for table: dbt.store_exposed_product */
export type Dbt_Store_Exposed_Product_Pk_Columns_Input = {
  id: Scalars['String'];
};

/** select columns of table "dbt.store_exposed_product" */
export enum Dbt_Store_Exposed_Product_Select_Column {
  /** column name */
  Brand = 'brand',
  /** column name */
  Description = 'description',
  /** column name */
  FirstImage = 'firstImage',
  /** column name */
  Gender = 'gender',
  /** column name */
  Handle = 'handle',
  /** column name */
  Id = 'id',
  /** column name */
  Model = 'model',
  /** column name */
  ModelYear = 'modelYear',
  /** column name */
  NumberOfViews = 'numberOfViews',
  /** column name */
  ProductType = 'productType',
  /** column name */
  PublishedAt = 'publishedAt',
  /** column name */
  Size = 'size',
  /** column name */
  Status = 'status',
  /** column name */
  SyncDate = 'syncDate',
  /** column name */
  Title = 'title',
  /** column name */
  Vendor = 'vendor',
}

/** input type for updating data in table "dbt.store_exposed_product" */
export type Dbt_Store_Exposed_Product_Set_Input = {
  brand: InputMaybe<Scalars['String']>;
  description: InputMaybe<Scalars['String']>;
  firstImage: InputMaybe<Scalars['String']>;
  gender: InputMaybe<Scalars['String']>;
  handle: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  model: InputMaybe<Scalars['String']>;
  modelYear: InputMaybe<Scalars['String']>;
  numberOfViews: InputMaybe<Scalars['bigint']>;
  productType: InputMaybe<Scalars['String']>;
  publishedAt: InputMaybe<Scalars['timestamptz']>;
  size: InputMaybe<Scalars['String']>;
  status: InputMaybe<Scalars['ProductStatus']>;
  syncDate: InputMaybe<Scalars['date']>;
  title: InputMaybe<Scalars['String']>;
  vendor: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Dbt_Store_Exposed_Product_Stddev_Fields = {
  __typename?: 'dbt_store_exposed_product_stddev_fields';
  numberOfViews: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Dbt_Store_Exposed_Product_Stddev_Pop_Fields = {
  __typename?: 'dbt_store_exposed_product_stddev_pop_fields';
  numberOfViews: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Dbt_Store_Exposed_Product_Stddev_Samp_Fields = {
  __typename?: 'dbt_store_exposed_product_stddev_samp_fields';
  numberOfViews: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "dbt_store_exposed_product" */
export type Dbt_Store_Exposed_Product_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Dbt_Store_Exposed_Product_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Dbt_Store_Exposed_Product_Stream_Cursor_Value_Input = {
  brand: InputMaybe<Scalars['String']>;
  description: InputMaybe<Scalars['String']>;
  firstImage: InputMaybe<Scalars['String']>;
  gender: InputMaybe<Scalars['String']>;
  handle: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['String']>;
  model: InputMaybe<Scalars['String']>;
  modelYear: InputMaybe<Scalars['String']>;
  numberOfViews: InputMaybe<Scalars['bigint']>;
  productType: InputMaybe<Scalars['String']>;
  publishedAt: InputMaybe<Scalars['timestamptz']>;
  size: InputMaybe<Scalars['String']>;
  status: InputMaybe<Scalars['ProductStatus']>;
  syncDate: InputMaybe<Scalars['date']>;
  title: InputMaybe<Scalars['String']>;
  vendor: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type Dbt_Store_Exposed_Product_Sum_Fields = {
  __typename?: 'dbt_store_exposed_product_sum_fields';
  numberOfViews: Maybe<Scalars['bigint']>;
};

/** columns and relationships of "dbt.store_exposed_product_tag" */
export type Dbt_Store_Exposed_Product_Tag = {
  __typename?: 'dbt_store_exposed_product_tag';
  full_tag: Scalars['String'];
  product_id: Scalars['String'];
  tag: Scalars['String'];
  value: Scalars['String'];
};

/** aggregated selection of "dbt.store_exposed_product_tag" */
export type Dbt_Store_Exposed_Product_Tag_Aggregate = {
  __typename?: 'dbt_store_exposed_product_tag_aggregate';
  aggregate: Maybe<Dbt_Store_Exposed_Product_Tag_Aggregate_Fields>;
  nodes: Array<Dbt_Store_Exposed_Product_Tag>;
};

export type Dbt_Store_Exposed_Product_Tag_Aggregate_Bool_Exp = {
  count: InputMaybe<Dbt_Store_Exposed_Product_Tag_Aggregate_Bool_Exp_Count>;
};

export type Dbt_Store_Exposed_Product_Tag_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<Dbt_Store_Exposed_Product_Tag_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<Dbt_Store_Exposed_Product_Tag_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "dbt.store_exposed_product_tag" */
export type Dbt_Store_Exposed_Product_Tag_Aggregate_Fields = {
  __typename?: 'dbt_store_exposed_product_tag_aggregate_fields';
  count: Scalars['Int'];
  max: Maybe<Dbt_Store_Exposed_Product_Tag_Max_Fields>;
  min: Maybe<Dbt_Store_Exposed_Product_Tag_Min_Fields>;
};

/** aggregate fields of "dbt.store_exposed_product_tag" */
export type Dbt_Store_Exposed_Product_Tag_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Dbt_Store_Exposed_Product_Tag_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "dbt.store_exposed_product_tag" */
export type Dbt_Store_Exposed_Product_Tag_Aggregate_Order_By = {
  count: InputMaybe<Order_By>;
  max: InputMaybe<Dbt_Store_Exposed_Product_Tag_Max_Order_By>;
  min: InputMaybe<Dbt_Store_Exposed_Product_Tag_Min_Order_By>;
};

/** input type for inserting array relation for remote table "dbt.store_exposed_product_tag" */
export type Dbt_Store_Exposed_Product_Tag_Arr_Rel_Insert_Input = {
  data: Array<Dbt_Store_Exposed_Product_Tag_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<Dbt_Store_Exposed_Product_Tag_On_Conflict>;
};

/** Boolean expression to filter rows from the table "dbt.store_exposed_product_tag". All fields are combined with a logical 'AND'. */
export type Dbt_Store_Exposed_Product_Tag_Bool_Exp = {
  _and: InputMaybe<Array<Dbt_Store_Exposed_Product_Tag_Bool_Exp>>;
  _not: InputMaybe<Dbt_Store_Exposed_Product_Tag_Bool_Exp>;
  _or: InputMaybe<Array<Dbt_Store_Exposed_Product_Tag_Bool_Exp>>;
  full_tag: InputMaybe<String_Comparison_Exp>;
  product_id: InputMaybe<String_Comparison_Exp>;
  tag: InputMaybe<String_Comparison_Exp>;
  value: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "dbt.store_exposed_product_tag" */
export enum Dbt_Store_Exposed_Product_Tag_Constraint {
  /** unique or primary key constraint on columns "product_id", "full_tag" */
  StoreExposedProductTagProductIdFullTagKey = 'store_exposed_product_tag_product_id_full_tag_key',
}

/** input type for inserting data into table "dbt.store_exposed_product_tag" */
export type Dbt_Store_Exposed_Product_Tag_Insert_Input = {
  full_tag: InputMaybe<Scalars['String']>;
  product_id: InputMaybe<Scalars['String']>;
  tag: InputMaybe<Scalars['String']>;
  value: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Dbt_Store_Exposed_Product_Tag_Max_Fields = {
  __typename?: 'dbt_store_exposed_product_tag_max_fields';
  full_tag: Maybe<Scalars['String']>;
  product_id: Maybe<Scalars['String']>;
  tag: Maybe<Scalars['String']>;
  value: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "dbt.store_exposed_product_tag" */
export type Dbt_Store_Exposed_Product_Tag_Max_Order_By = {
  full_tag: InputMaybe<Order_By>;
  product_id: InputMaybe<Order_By>;
  tag: InputMaybe<Order_By>;
  value: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Dbt_Store_Exposed_Product_Tag_Min_Fields = {
  __typename?: 'dbt_store_exposed_product_tag_min_fields';
  full_tag: Maybe<Scalars['String']>;
  product_id: Maybe<Scalars['String']>;
  tag: Maybe<Scalars['String']>;
  value: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "dbt.store_exposed_product_tag" */
export type Dbt_Store_Exposed_Product_Tag_Min_Order_By = {
  full_tag: InputMaybe<Order_By>;
  product_id: InputMaybe<Order_By>;
  tag: InputMaybe<Order_By>;
  value: InputMaybe<Order_By>;
};

/** response of any mutation on the table "dbt.store_exposed_product_tag" */
export type Dbt_Store_Exposed_Product_Tag_Mutation_Response = {
  __typename?: 'dbt_store_exposed_product_tag_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Dbt_Store_Exposed_Product_Tag>;
};

/** on_conflict condition type for table "dbt.store_exposed_product_tag" */
export type Dbt_Store_Exposed_Product_Tag_On_Conflict = {
  constraint: Dbt_Store_Exposed_Product_Tag_Constraint;
  update_columns: Array<Dbt_Store_Exposed_Product_Tag_Update_Column>;
  where: InputMaybe<Dbt_Store_Exposed_Product_Tag_Bool_Exp>;
};

/** Ordering options when selecting data from "dbt.store_exposed_product_tag". */
export type Dbt_Store_Exposed_Product_Tag_Order_By = {
  full_tag: InputMaybe<Order_By>;
  product_id: InputMaybe<Order_By>;
  tag: InputMaybe<Order_By>;
  value: InputMaybe<Order_By>;
};

/** select columns of table "dbt.store_exposed_product_tag" */
export enum Dbt_Store_Exposed_Product_Tag_Select_Column {
  /** column name */
  FullTag = 'full_tag',
  /** column name */
  ProductId = 'product_id',
  /** column name */
  Tag = 'tag',
  /** column name */
  Value = 'value',
}

/** input type for updating data in table "dbt.store_exposed_product_tag" */
export type Dbt_Store_Exposed_Product_Tag_Set_Input = {
  full_tag: InputMaybe<Scalars['String']>;
  product_id: InputMaybe<Scalars['String']>;
  tag: InputMaybe<Scalars['String']>;
  value: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "dbt_store_exposed_product_tag" */
export type Dbt_Store_Exposed_Product_Tag_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Dbt_Store_Exposed_Product_Tag_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Dbt_Store_Exposed_Product_Tag_Stream_Cursor_Value_Input = {
  full_tag: InputMaybe<Scalars['String']>;
  product_id: InputMaybe<Scalars['String']>;
  tag: InputMaybe<Scalars['String']>;
  value: InputMaybe<Scalars['String']>;
};

/** update columns of table "dbt.store_exposed_product_tag" */
export enum Dbt_Store_Exposed_Product_Tag_Update_Column {
  /** column name */
  FullTag = 'full_tag',
  /** column name */
  ProductId = 'product_id',
  /** column name */
  Tag = 'tag',
  /** column name */
  Value = 'value',
}

export type Dbt_Store_Exposed_Product_Tag_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Dbt_Store_Exposed_Product_Tag_Set_Input>;
  /** filter the rows which have to be updated */
  where: Dbt_Store_Exposed_Product_Tag_Bool_Exp;
};

/** update columns of table "dbt.store_exposed_product" */
export enum Dbt_Store_Exposed_Product_Update_Column {
  /** column name */
  Brand = 'brand',
  /** column name */
  Description = 'description',
  /** column name */
  FirstImage = 'firstImage',
  /** column name */
  Gender = 'gender',
  /** column name */
  Handle = 'handle',
  /** column name */
  Id = 'id',
  /** column name */
  Model = 'model',
  /** column name */
  ModelYear = 'modelYear',
  /** column name */
  NumberOfViews = 'numberOfViews',
  /** column name */
  ProductType = 'productType',
  /** column name */
  PublishedAt = 'publishedAt',
  /** column name */
  Size = 'size',
  /** column name */
  Status = 'status',
  /** column name */
  SyncDate = 'syncDate',
  /** column name */
  Title = 'title',
  /** column name */
  Vendor = 'vendor',
}

export type Dbt_Store_Exposed_Product_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Dbt_Store_Exposed_Product_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Dbt_Store_Exposed_Product_Set_Input>;
  /** filter the rows which have to be updated */
  where: Dbt_Store_Exposed_Product_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Dbt_Store_Exposed_Product_Var_Pop_Fields = {
  __typename?: 'dbt_store_exposed_product_var_pop_fields';
  numberOfViews: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Dbt_Store_Exposed_Product_Var_Samp_Fields = {
  __typename?: 'dbt_store_exposed_product_var_samp_fields';
  numberOfViews: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Dbt_Store_Exposed_Product_Variance_Fields = {
  __typename?: 'dbt_store_exposed_product_variance_fields';
  numberOfViews: Maybe<Scalars['Float']>;
};

/** columns and relationships of "dbt.store_exposed_product_variant" */
export type Dbt_Store_Exposed_Product_Variant = {
  __typename?: 'dbt_store_exposed_product_variant';
  compareAtPrice: Maybe<Scalars['float8']>;
  condition: Maybe<Scalars['Condition']>;
  inventoryQuantity: Scalars['bigint'];
  isRefurbished: Maybe<Scalars['Boolean']>;
  option1: Maybe<Scalars['String']>;
  option1Name: Maybe<Scalars['String']>;
  option2: Maybe<Scalars['String']>;
  option2Name: Maybe<Scalars['String']>;
  option3: Maybe<Scalars['String']>;
  option3Name: Maybe<Scalars['String']>;
  price: Scalars['float8'];
  requiresShipping: Maybe<Scalars['Boolean']>;
  shopify_id: Scalars['bigint'];
  syncDate: Scalars['date'];
  title: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  variant: Maybe<Dbt_Store_Base_Product_Variant>;
};

/** aggregated selection of "dbt.store_exposed_product_variant" */
export type Dbt_Store_Exposed_Product_Variant_Aggregate = {
  __typename?: 'dbt_store_exposed_product_variant_aggregate';
  aggregate: Maybe<Dbt_Store_Exposed_Product_Variant_Aggregate_Fields>;
  nodes: Array<Dbt_Store_Exposed_Product_Variant>;
};

/** aggregate fields of "dbt.store_exposed_product_variant" */
export type Dbt_Store_Exposed_Product_Variant_Aggregate_Fields = {
  __typename?: 'dbt_store_exposed_product_variant_aggregate_fields';
  avg: Maybe<Dbt_Store_Exposed_Product_Variant_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Dbt_Store_Exposed_Product_Variant_Max_Fields>;
  min: Maybe<Dbt_Store_Exposed_Product_Variant_Min_Fields>;
  stddev: Maybe<Dbt_Store_Exposed_Product_Variant_Stddev_Fields>;
  stddev_pop: Maybe<Dbt_Store_Exposed_Product_Variant_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Dbt_Store_Exposed_Product_Variant_Stddev_Samp_Fields>;
  sum: Maybe<Dbt_Store_Exposed_Product_Variant_Sum_Fields>;
  var_pop: Maybe<Dbt_Store_Exposed_Product_Variant_Var_Pop_Fields>;
  var_samp: Maybe<Dbt_Store_Exposed_Product_Variant_Var_Samp_Fields>;
  variance: Maybe<Dbt_Store_Exposed_Product_Variant_Variance_Fields>;
};

/** aggregate fields of "dbt.store_exposed_product_variant" */
export type Dbt_Store_Exposed_Product_Variant_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Dbt_Store_Exposed_Product_Variant_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Dbt_Store_Exposed_Product_Variant_Avg_Fields = {
  __typename?: 'dbt_store_exposed_product_variant_avg_fields';
  compareAtPrice: Maybe<Scalars['Float']>;
  inventoryQuantity: Maybe<Scalars['Float']>;
  price: Maybe<Scalars['Float']>;
  shopify_id: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "dbt.store_exposed_product_variant". All fields are combined with a logical 'AND'. */
export type Dbt_Store_Exposed_Product_Variant_Bool_Exp = {
  _and: InputMaybe<Array<Dbt_Store_Exposed_Product_Variant_Bool_Exp>>;
  _not: InputMaybe<Dbt_Store_Exposed_Product_Variant_Bool_Exp>;
  _or: InputMaybe<Array<Dbt_Store_Exposed_Product_Variant_Bool_Exp>>;
  compareAtPrice: InputMaybe<Float8_Comparison_Exp>;
  condition: InputMaybe<Condition_Comparison_Exp>;
  inventoryQuantity: InputMaybe<Bigint_Comparison_Exp>;
  isRefurbished: InputMaybe<Boolean_Comparison_Exp>;
  option1: InputMaybe<String_Comparison_Exp>;
  option1Name: InputMaybe<String_Comparison_Exp>;
  option2: InputMaybe<String_Comparison_Exp>;
  option2Name: InputMaybe<String_Comparison_Exp>;
  option3: InputMaybe<String_Comparison_Exp>;
  option3Name: InputMaybe<String_Comparison_Exp>;
  price: InputMaybe<Float8_Comparison_Exp>;
  requiresShipping: InputMaybe<Boolean_Comparison_Exp>;
  shopify_id: InputMaybe<Bigint_Comparison_Exp>;
  syncDate: InputMaybe<Date_Comparison_Exp>;
  title: InputMaybe<String_Comparison_Exp>;
  updatedAt: InputMaybe<Timestamptz_Comparison_Exp>;
  variant: InputMaybe<Dbt_Store_Base_Product_Variant_Bool_Exp>;
};

/** unique or primary key constraints on table "dbt.store_exposed_product_variant" */
export enum Dbt_Store_Exposed_Product_Variant_Constraint {
  /** unique or primary key constraint on columns "shopify_id" */
  StoreExposedProductVariantPkey = 'store_exposed_product_variant_pkey',
}

/** input type for incrementing numeric columns in table "dbt.store_exposed_product_variant" */
export type Dbt_Store_Exposed_Product_Variant_Inc_Input = {
  compareAtPrice: InputMaybe<Scalars['float8']>;
  inventoryQuantity: InputMaybe<Scalars['bigint']>;
  price: InputMaybe<Scalars['float8']>;
  shopify_id: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "dbt.store_exposed_product_variant" */
export type Dbt_Store_Exposed_Product_Variant_Insert_Input = {
  compareAtPrice: InputMaybe<Scalars['float8']>;
  condition: InputMaybe<Scalars['Condition']>;
  inventoryQuantity: InputMaybe<Scalars['bigint']>;
  isRefurbished: InputMaybe<Scalars['Boolean']>;
  option1: InputMaybe<Scalars['String']>;
  option1Name: InputMaybe<Scalars['String']>;
  option2: InputMaybe<Scalars['String']>;
  option2Name: InputMaybe<Scalars['String']>;
  option3: InputMaybe<Scalars['String']>;
  option3Name: InputMaybe<Scalars['String']>;
  price: InputMaybe<Scalars['float8']>;
  requiresShipping: InputMaybe<Scalars['Boolean']>;
  shopify_id: InputMaybe<Scalars['bigint']>;
  syncDate: InputMaybe<Scalars['date']>;
  title: InputMaybe<Scalars['String']>;
  updatedAt: InputMaybe<Scalars['timestamptz']>;
  variant: InputMaybe<Dbt_Store_Base_Product_Variant_Obj_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Dbt_Store_Exposed_Product_Variant_Max_Fields = {
  __typename?: 'dbt_store_exposed_product_variant_max_fields';
  compareAtPrice: Maybe<Scalars['float8']>;
  condition: Maybe<Scalars['Condition']>;
  inventoryQuantity: Maybe<Scalars['bigint']>;
  option1: Maybe<Scalars['String']>;
  option1Name: Maybe<Scalars['String']>;
  option2: Maybe<Scalars['String']>;
  option2Name: Maybe<Scalars['String']>;
  option3: Maybe<Scalars['String']>;
  option3Name: Maybe<Scalars['String']>;
  price: Maybe<Scalars['float8']>;
  shopify_id: Maybe<Scalars['bigint']>;
  syncDate: Maybe<Scalars['date']>;
  title: Maybe<Scalars['String']>;
  updatedAt: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Dbt_Store_Exposed_Product_Variant_Min_Fields = {
  __typename?: 'dbt_store_exposed_product_variant_min_fields';
  compareAtPrice: Maybe<Scalars['float8']>;
  condition: Maybe<Scalars['Condition']>;
  inventoryQuantity: Maybe<Scalars['bigint']>;
  option1: Maybe<Scalars['String']>;
  option1Name: Maybe<Scalars['String']>;
  option2: Maybe<Scalars['String']>;
  option2Name: Maybe<Scalars['String']>;
  option3: Maybe<Scalars['String']>;
  option3Name: Maybe<Scalars['String']>;
  price: Maybe<Scalars['float8']>;
  shopify_id: Maybe<Scalars['bigint']>;
  syncDate: Maybe<Scalars['date']>;
  title: Maybe<Scalars['String']>;
  updatedAt: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "dbt.store_exposed_product_variant" */
export type Dbt_Store_Exposed_Product_Variant_Mutation_Response = {
  __typename?: 'dbt_store_exposed_product_variant_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Dbt_Store_Exposed_Product_Variant>;
};

/** input type for inserting object relation for remote table "dbt.store_exposed_product_variant" */
export type Dbt_Store_Exposed_Product_Variant_Obj_Rel_Insert_Input = {
  data: Dbt_Store_Exposed_Product_Variant_Insert_Input;
  /** upsert condition */
  on_conflict: InputMaybe<Dbt_Store_Exposed_Product_Variant_On_Conflict>;
};

/** on_conflict condition type for table "dbt.store_exposed_product_variant" */
export type Dbt_Store_Exposed_Product_Variant_On_Conflict = {
  constraint: Dbt_Store_Exposed_Product_Variant_Constraint;
  update_columns: Array<Dbt_Store_Exposed_Product_Variant_Update_Column>;
  where: InputMaybe<Dbt_Store_Exposed_Product_Variant_Bool_Exp>;
};

/** Ordering options when selecting data from "dbt.store_exposed_product_variant". */
export type Dbt_Store_Exposed_Product_Variant_Order_By = {
  compareAtPrice: InputMaybe<Order_By>;
  condition: InputMaybe<Order_By>;
  inventoryQuantity: InputMaybe<Order_By>;
  isRefurbished: InputMaybe<Order_By>;
  option1: InputMaybe<Order_By>;
  option1Name: InputMaybe<Order_By>;
  option2: InputMaybe<Order_By>;
  option2Name: InputMaybe<Order_By>;
  option3: InputMaybe<Order_By>;
  option3Name: InputMaybe<Order_By>;
  price: InputMaybe<Order_By>;
  requiresShipping: InputMaybe<Order_By>;
  shopify_id: InputMaybe<Order_By>;
  syncDate: InputMaybe<Order_By>;
  title: InputMaybe<Order_By>;
  updatedAt: InputMaybe<Order_By>;
  variant: InputMaybe<Dbt_Store_Base_Product_Variant_Order_By>;
};

/** primary key columns input for table: dbt.store_exposed_product_variant */
export type Dbt_Store_Exposed_Product_Variant_Pk_Columns_Input = {
  shopify_id: Scalars['bigint'];
};

/** select columns of table "dbt.store_exposed_product_variant" */
export enum Dbt_Store_Exposed_Product_Variant_Select_Column {
  /** column name */
  CompareAtPrice = 'compareAtPrice',
  /** column name */
  Condition = 'condition',
  /** column name */
  InventoryQuantity = 'inventoryQuantity',
  /** column name */
  IsRefurbished = 'isRefurbished',
  /** column name */
  Option1 = 'option1',
  /** column name */
  Option1Name = 'option1Name',
  /** column name */
  Option2 = 'option2',
  /** column name */
  Option2Name = 'option2Name',
  /** column name */
  Option3 = 'option3',
  /** column name */
  Option3Name = 'option3Name',
  /** column name */
  Price = 'price',
  /** column name */
  RequiresShipping = 'requiresShipping',
  /** column name */
  ShopifyId = 'shopify_id',
  /** column name */
  SyncDate = 'syncDate',
  /** column name */
  Title = 'title',
  /** column name */
  UpdatedAt = 'updatedAt',
}

/** input type for updating data in table "dbt.store_exposed_product_variant" */
export type Dbt_Store_Exposed_Product_Variant_Set_Input = {
  compareAtPrice: InputMaybe<Scalars['float8']>;
  condition: InputMaybe<Scalars['Condition']>;
  inventoryQuantity: InputMaybe<Scalars['bigint']>;
  isRefurbished: InputMaybe<Scalars['Boolean']>;
  option1: InputMaybe<Scalars['String']>;
  option1Name: InputMaybe<Scalars['String']>;
  option2: InputMaybe<Scalars['String']>;
  option2Name: InputMaybe<Scalars['String']>;
  option3: InputMaybe<Scalars['String']>;
  option3Name: InputMaybe<Scalars['String']>;
  price: InputMaybe<Scalars['float8']>;
  requiresShipping: InputMaybe<Scalars['Boolean']>;
  shopify_id: InputMaybe<Scalars['bigint']>;
  syncDate: InputMaybe<Scalars['date']>;
  title: InputMaybe<Scalars['String']>;
  updatedAt: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Dbt_Store_Exposed_Product_Variant_Stddev_Fields = {
  __typename?: 'dbt_store_exposed_product_variant_stddev_fields';
  compareAtPrice: Maybe<Scalars['Float']>;
  inventoryQuantity: Maybe<Scalars['Float']>;
  price: Maybe<Scalars['Float']>;
  shopify_id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Dbt_Store_Exposed_Product_Variant_Stddev_Pop_Fields = {
  __typename?: 'dbt_store_exposed_product_variant_stddev_pop_fields';
  compareAtPrice: Maybe<Scalars['Float']>;
  inventoryQuantity: Maybe<Scalars['Float']>;
  price: Maybe<Scalars['Float']>;
  shopify_id: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Dbt_Store_Exposed_Product_Variant_Stddev_Samp_Fields = {
  __typename?: 'dbt_store_exposed_product_variant_stddev_samp_fields';
  compareAtPrice: Maybe<Scalars['Float']>;
  inventoryQuantity: Maybe<Scalars['Float']>;
  price: Maybe<Scalars['Float']>;
  shopify_id: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "dbt_store_exposed_product_variant" */
export type Dbt_Store_Exposed_Product_Variant_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Dbt_Store_Exposed_Product_Variant_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Dbt_Store_Exposed_Product_Variant_Stream_Cursor_Value_Input = {
  compareAtPrice: InputMaybe<Scalars['float8']>;
  condition: InputMaybe<Scalars['Condition']>;
  inventoryQuantity: InputMaybe<Scalars['bigint']>;
  isRefurbished: InputMaybe<Scalars['Boolean']>;
  option1: InputMaybe<Scalars['String']>;
  option1Name: InputMaybe<Scalars['String']>;
  option2: InputMaybe<Scalars['String']>;
  option2Name: InputMaybe<Scalars['String']>;
  option3: InputMaybe<Scalars['String']>;
  option3Name: InputMaybe<Scalars['String']>;
  price: InputMaybe<Scalars['float8']>;
  requiresShipping: InputMaybe<Scalars['Boolean']>;
  shopify_id: InputMaybe<Scalars['bigint']>;
  syncDate: InputMaybe<Scalars['date']>;
  title: InputMaybe<Scalars['String']>;
  updatedAt: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Dbt_Store_Exposed_Product_Variant_Sum_Fields = {
  __typename?: 'dbt_store_exposed_product_variant_sum_fields';
  compareAtPrice: Maybe<Scalars['float8']>;
  inventoryQuantity: Maybe<Scalars['bigint']>;
  price: Maybe<Scalars['float8']>;
  shopify_id: Maybe<Scalars['bigint']>;
};

/** update columns of table "dbt.store_exposed_product_variant" */
export enum Dbt_Store_Exposed_Product_Variant_Update_Column {
  /** column name */
  CompareAtPrice = 'compareAtPrice',
  /** column name */
  Condition = 'condition',
  /** column name */
  InventoryQuantity = 'inventoryQuantity',
  /** column name */
  IsRefurbished = 'isRefurbished',
  /** column name */
  Option1 = 'option1',
  /** column name */
  Option1Name = 'option1Name',
  /** column name */
  Option2 = 'option2',
  /** column name */
  Option2Name = 'option2Name',
  /** column name */
  Option3 = 'option3',
  /** column name */
  Option3Name = 'option3Name',
  /** column name */
  Price = 'price',
  /** column name */
  RequiresShipping = 'requiresShipping',
  /** column name */
  ShopifyId = 'shopify_id',
  /** column name */
  SyncDate = 'syncDate',
  /** column name */
  Title = 'title',
  /** column name */
  UpdatedAt = 'updatedAt',
}

export type Dbt_Store_Exposed_Product_Variant_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Dbt_Store_Exposed_Product_Variant_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Dbt_Store_Exposed_Product_Variant_Set_Input>;
  /** filter the rows which have to be updated */
  where: Dbt_Store_Exposed_Product_Variant_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Dbt_Store_Exposed_Product_Variant_Var_Pop_Fields = {
  __typename?: 'dbt_store_exposed_product_variant_var_pop_fields';
  compareAtPrice: Maybe<Scalars['Float']>;
  inventoryQuantity: Maybe<Scalars['Float']>;
  price: Maybe<Scalars['Float']>;
  shopify_id: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Dbt_Store_Exposed_Product_Variant_Var_Samp_Fields = {
  __typename?: 'dbt_store_exposed_product_variant_var_samp_fields';
  compareAtPrice: Maybe<Scalars['Float']>;
  inventoryQuantity: Maybe<Scalars['Float']>;
  price: Maybe<Scalars['Float']>;
  shopify_id: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Dbt_Store_Exposed_Product_Variant_Variance_Fields = {
  __typename?: 'dbt_store_exposed_product_variant_variance_fields';
  compareAtPrice: Maybe<Scalars['Float']>;
  inventoryQuantity: Maybe<Scalars['Float']>;
  price: Maybe<Scalars['Float']>;
  shopify_id: Maybe<Scalars['Float']>;
};

/** columns and relationships of "dbt.store_product_collection" */
export type Dbt_Store_Product_Collection = {
  __typename?: 'dbt_store_product_collection';
  collection_id: Scalars['String'];
  product_id: Scalars['String'];
  syncDate: Scalars['date'];
};

/** aggregated selection of "dbt.store_product_collection" */
export type Dbt_Store_Product_Collection_Aggregate = {
  __typename?: 'dbt_store_product_collection_aggregate';
  aggregate: Maybe<Dbt_Store_Product_Collection_Aggregate_Fields>;
  nodes: Array<Dbt_Store_Product_Collection>;
};

export type Dbt_Store_Product_Collection_Aggregate_Bool_Exp = {
  count: InputMaybe<Dbt_Store_Product_Collection_Aggregate_Bool_Exp_Count>;
};

export type Dbt_Store_Product_Collection_Aggregate_Bool_Exp_Count = {
  arguments: InputMaybe<Array<Dbt_Store_Product_Collection_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
  filter: InputMaybe<Dbt_Store_Product_Collection_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "dbt.store_product_collection" */
export type Dbt_Store_Product_Collection_Aggregate_Fields = {
  __typename?: 'dbt_store_product_collection_aggregate_fields';
  count: Scalars['Int'];
  max: Maybe<Dbt_Store_Product_Collection_Max_Fields>;
  min: Maybe<Dbt_Store_Product_Collection_Min_Fields>;
};

/** aggregate fields of "dbt.store_product_collection" */
export type Dbt_Store_Product_Collection_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Dbt_Store_Product_Collection_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "dbt.store_product_collection" */
export type Dbt_Store_Product_Collection_Aggregate_Order_By = {
  count: InputMaybe<Order_By>;
  max: InputMaybe<Dbt_Store_Product_Collection_Max_Order_By>;
  min: InputMaybe<Dbt_Store_Product_Collection_Min_Order_By>;
};

/** input type for inserting array relation for remote table "dbt.store_product_collection" */
export type Dbt_Store_Product_Collection_Arr_Rel_Insert_Input = {
  data: Array<Dbt_Store_Product_Collection_Insert_Input>;
  /** upsert condition */
  on_conflict: InputMaybe<Dbt_Store_Product_Collection_On_Conflict>;
};

/** Boolean expression to filter rows from the table "dbt.store_product_collection". All fields are combined with a logical 'AND'. */
export type Dbt_Store_Product_Collection_Bool_Exp = {
  _and: InputMaybe<Array<Dbt_Store_Product_Collection_Bool_Exp>>;
  _not: InputMaybe<Dbt_Store_Product_Collection_Bool_Exp>;
  _or: InputMaybe<Array<Dbt_Store_Product_Collection_Bool_Exp>>;
  collection_id: InputMaybe<String_Comparison_Exp>;
  product_id: InputMaybe<String_Comparison_Exp>;
  syncDate: InputMaybe<Date_Comparison_Exp>;
};

/** unique or primary key constraints on table "dbt.store_product_collection" */
export enum Dbt_Store_Product_Collection_Constraint {
  /** unique or primary key constraint on columns "product_id", "collection_id" */
  StoreProductCollectionPkey = 'store_product_collection_pkey',
}

/** input type for inserting data into table "dbt.store_product_collection" */
export type Dbt_Store_Product_Collection_Insert_Input = {
  collection_id: InputMaybe<Scalars['String']>;
  product_id: InputMaybe<Scalars['String']>;
  syncDate: InputMaybe<Scalars['date']>;
};

/** aggregate max on columns */
export type Dbt_Store_Product_Collection_Max_Fields = {
  __typename?: 'dbt_store_product_collection_max_fields';
  collection_id: Maybe<Scalars['String']>;
  product_id: Maybe<Scalars['String']>;
  syncDate: Maybe<Scalars['date']>;
};

/** order by max() on columns of table "dbt.store_product_collection" */
export type Dbt_Store_Product_Collection_Max_Order_By = {
  collection_id: InputMaybe<Order_By>;
  product_id: InputMaybe<Order_By>;
  syncDate: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Dbt_Store_Product_Collection_Min_Fields = {
  __typename?: 'dbt_store_product_collection_min_fields';
  collection_id: Maybe<Scalars['String']>;
  product_id: Maybe<Scalars['String']>;
  syncDate: Maybe<Scalars['date']>;
};

/** order by min() on columns of table "dbt.store_product_collection" */
export type Dbt_Store_Product_Collection_Min_Order_By = {
  collection_id: InputMaybe<Order_By>;
  product_id: InputMaybe<Order_By>;
  syncDate: InputMaybe<Order_By>;
};

/** response of any mutation on the table "dbt.store_product_collection" */
export type Dbt_Store_Product_Collection_Mutation_Response = {
  __typename?: 'dbt_store_product_collection_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Dbt_Store_Product_Collection>;
};

/** on_conflict condition type for table "dbt.store_product_collection" */
export type Dbt_Store_Product_Collection_On_Conflict = {
  constraint: Dbt_Store_Product_Collection_Constraint;
  update_columns: Array<Dbt_Store_Product_Collection_Update_Column>;
  where: InputMaybe<Dbt_Store_Product_Collection_Bool_Exp>;
};

/** Ordering options when selecting data from "dbt.store_product_collection". */
export type Dbt_Store_Product_Collection_Order_By = {
  collection_id: InputMaybe<Order_By>;
  product_id: InputMaybe<Order_By>;
  syncDate: InputMaybe<Order_By>;
};

/** primary key columns input for table: dbt.store_product_collection */
export type Dbt_Store_Product_Collection_Pk_Columns_Input = {
  collection_id: Scalars['String'];
  product_id: Scalars['String'];
};

/** select columns of table "dbt.store_product_collection" */
export enum Dbt_Store_Product_Collection_Select_Column {
  /** column name */
  CollectionId = 'collection_id',
  /** column name */
  ProductId = 'product_id',
  /** column name */
  SyncDate = 'syncDate',
}

/** input type for updating data in table "dbt.store_product_collection" */
export type Dbt_Store_Product_Collection_Set_Input = {
  collection_id: InputMaybe<Scalars['String']>;
  product_id: InputMaybe<Scalars['String']>;
  syncDate: InputMaybe<Scalars['date']>;
};

/** Streaming cursor of the table "dbt_store_product_collection" */
export type Dbt_Store_Product_Collection_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Dbt_Store_Product_Collection_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Dbt_Store_Product_Collection_Stream_Cursor_Value_Input = {
  collection_id: InputMaybe<Scalars['String']>;
  product_id: InputMaybe<Scalars['String']>;
  syncDate: InputMaybe<Scalars['date']>;
};

/** update columns of table "dbt.store_product_collection" */
export enum Dbt_Store_Product_Collection_Update_Column {
  /** column name */
  CollectionId = 'collection_id',
  /** column name */
  ProductId = 'product_id',
  /** column name */
  SyncDate = 'syncDate',
}

export type Dbt_Store_Product_Collection_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Dbt_Store_Product_Collection_Set_Input>;
  /** filter the rows which have to be updated */
  where: Dbt_Store_Product_Collection_Bool_Exp;
};

/** columns and relationships of "dbt.store_product_for_analytics" */
export type Dbt_Store_Product_For_Analytics = {
  __typename?: 'dbt_store_product_for_analytics';
  brand: Maybe<Scalars['String']>;
  brand_rating: Maybe<Scalars['BrandRating']>;
  calculated_notation: Maybe<Scalars['ProductNotation']>;
  calculated_notation_beta: Maybe<Scalars['ProductNotation']>;
  calculated_scoring: Scalars['float8'];
  condition_from_variants: Maybe<Scalars['Condition']>;
  created_at: Scalars['timestamptz'];
  default_vendor_notation: Maybe<Scalars['ProductNotation']>;
  ean_code: Maybe<Scalars['String']>;
  highest_discount: Scalars['float8'];
  id: Scalars['String'];
  image_count: Scalars['Int'];
  is_bike: Scalars['Boolean'];
  is_new: Maybe<Scalars['Boolean']>;
  manual_notation: Maybe<Scalars['ProductNotation']>;
  model_year: Scalars['Int'];
  model_year_with_override: Scalars['Int'];
  notation: Maybe<Scalars['ProductNotation']>;
  shopify_id: Scalars['bigint'];
  size: Maybe<Scalars['String']>;
  source: Maybe<Scalars['String']>;
  vendor_id: Scalars['uuid'];
  vendor_notation: Maybe<Scalars['ProductNotation']>;
  vendor_overrides_product_scoring: Scalars['Boolean'];
  views_last_30_days: Scalars['bigint'];
};

/** aggregated selection of "dbt.store_product_for_analytics" */
export type Dbt_Store_Product_For_Analytics_Aggregate = {
  __typename?: 'dbt_store_product_for_analytics_aggregate';
  aggregate: Maybe<Dbt_Store_Product_For_Analytics_Aggregate_Fields>;
  nodes: Array<Dbt_Store_Product_For_Analytics>;
};

/** aggregate fields of "dbt.store_product_for_analytics" */
export type Dbt_Store_Product_For_Analytics_Aggregate_Fields = {
  __typename?: 'dbt_store_product_for_analytics_aggregate_fields';
  avg: Maybe<Dbt_Store_Product_For_Analytics_Avg_Fields>;
  count: Scalars['Int'];
  max: Maybe<Dbt_Store_Product_For_Analytics_Max_Fields>;
  min: Maybe<Dbt_Store_Product_For_Analytics_Min_Fields>;
  stddev: Maybe<Dbt_Store_Product_For_Analytics_Stddev_Fields>;
  stddev_pop: Maybe<Dbt_Store_Product_For_Analytics_Stddev_Pop_Fields>;
  stddev_samp: Maybe<Dbt_Store_Product_For_Analytics_Stddev_Samp_Fields>;
  sum: Maybe<Dbt_Store_Product_For_Analytics_Sum_Fields>;
  var_pop: Maybe<Dbt_Store_Product_For_Analytics_Var_Pop_Fields>;
  var_samp: Maybe<Dbt_Store_Product_For_Analytics_Var_Samp_Fields>;
  variance: Maybe<Dbt_Store_Product_For_Analytics_Variance_Fields>;
};

/** aggregate fields of "dbt.store_product_for_analytics" */
export type Dbt_Store_Product_For_Analytics_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Dbt_Store_Product_For_Analytics_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Dbt_Store_Product_For_Analytics_Avg_Fields = {
  __typename?: 'dbt_store_product_for_analytics_avg_fields';
  calculated_scoring: Maybe<Scalars['Float']>;
  highest_discount: Maybe<Scalars['Float']>;
  image_count: Maybe<Scalars['Float']>;
  model_year: Maybe<Scalars['Float']>;
  model_year_with_override: Maybe<Scalars['Float']>;
  shopify_id: Maybe<Scalars['Float']>;
  views_last_30_days: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "dbt.store_product_for_analytics". All fields are combined with a logical 'AND'. */
export type Dbt_Store_Product_For_Analytics_Bool_Exp = {
  _and: InputMaybe<Array<Dbt_Store_Product_For_Analytics_Bool_Exp>>;
  _not: InputMaybe<Dbt_Store_Product_For_Analytics_Bool_Exp>;
  _or: InputMaybe<Array<Dbt_Store_Product_For_Analytics_Bool_Exp>>;
  brand: InputMaybe<String_Comparison_Exp>;
  brand_rating: InputMaybe<BrandRating_Comparison_Exp>;
  calculated_notation: InputMaybe<ProductNotation_Comparison_Exp>;
  calculated_notation_beta: InputMaybe<ProductNotation_Comparison_Exp>;
  calculated_scoring: InputMaybe<Float8_Comparison_Exp>;
  condition_from_variants: InputMaybe<Condition_Comparison_Exp>;
  created_at: InputMaybe<Timestamptz_Comparison_Exp>;
  default_vendor_notation: InputMaybe<ProductNotation_Comparison_Exp>;
  ean_code: InputMaybe<String_Comparison_Exp>;
  highest_discount: InputMaybe<Float8_Comparison_Exp>;
  id: InputMaybe<String_Comparison_Exp>;
  image_count: InputMaybe<Int_Comparison_Exp>;
  is_bike: InputMaybe<Boolean_Comparison_Exp>;
  is_new: InputMaybe<Boolean_Comparison_Exp>;
  manual_notation: InputMaybe<ProductNotation_Comparison_Exp>;
  model_year: InputMaybe<Int_Comparison_Exp>;
  model_year_with_override: InputMaybe<Int_Comparison_Exp>;
  notation: InputMaybe<ProductNotation_Comparison_Exp>;
  shopify_id: InputMaybe<Bigint_Comparison_Exp>;
  size: InputMaybe<String_Comparison_Exp>;
  source: InputMaybe<String_Comparison_Exp>;
  vendor_id: InputMaybe<Uuid_Comparison_Exp>;
  vendor_notation: InputMaybe<ProductNotation_Comparison_Exp>;
  vendor_overrides_product_scoring: InputMaybe<Boolean_Comparison_Exp>;
  views_last_30_days: InputMaybe<Bigint_Comparison_Exp>;
};

/** unique or primary key constraints on table "dbt.store_product_for_analytics" */
export enum Dbt_Store_Product_For_Analytics_Constraint {
  /** unique or primary key constraint on columns "id" */
  StoreProductForAnalyticsIdKey = 'store_product_for_analytics_id_key',
  /** unique or primary key constraint on columns "id" */
  StoreProductForAnalyticsPkey = 'store_product_for_analytics_pkey',
  /** unique or primary key constraint on columns "shopify_id" */
  StoreProductForAnalyticsShopifyIdKey = 'store_product_for_analytics_shopify_id_key',
}

/** input type for incrementing numeric columns in table "dbt.store_product_for_analytics" */
export type Dbt_Store_Product_For_Analytics_Inc_Input = {
  calculated_scoring: InputMaybe<Scalars['float8']>;
  highest_discount: InputMaybe<Scalars['float8']>;
  image_count: InputMaybe<Scalars['Int']>;
  model_year: InputMaybe<Scalars['Int']>;
  model_year_with_override: InputMaybe<Scalars['Int']>;
  shopify_id: InputMaybe<Scalars['bigint']>;
  views_last_30_days: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "dbt.store_product_for_analytics" */
export type Dbt_Store_Product_For_Analytics_Insert_Input = {
  brand: InputMaybe<Scalars['String']>;
  brand_rating: InputMaybe<Scalars['BrandRating']>;
  calculated_notation: InputMaybe<Scalars['ProductNotation']>;
  calculated_notation_beta: InputMaybe<Scalars['ProductNotation']>;
  calculated_scoring: InputMaybe<Scalars['float8']>;
  condition_from_variants: InputMaybe<Scalars['Condition']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  default_vendor_notation: InputMaybe<Scalars['ProductNotation']>;
  ean_code: InputMaybe<Scalars['String']>;
  highest_discount: InputMaybe<Scalars['float8']>;
  id: InputMaybe<Scalars['String']>;
  image_count: InputMaybe<Scalars['Int']>;
  is_bike: InputMaybe<Scalars['Boolean']>;
  is_new: InputMaybe<Scalars['Boolean']>;
  manual_notation: InputMaybe<Scalars['ProductNotation']>;
  model_year: InputMaybe<Scalars['Int']>;
  model_year_with_override: InputMaybe<Scalars['Int']>;
  notation: InputMaybe<Scalars['ProductNotation']>;
  shopify_id: InputMaybe<Scalars['bigint']>;
  size: InputMaybe<Scalars['String']>;
  source: InputMaybe<Scalars['String']>;
  vendor_id: InputMaybe<Scalars['uuid']>;
  vendor_notation: InputMaybe<Scalars['ProductNotation']>;
  vendor_overrides_product_scoring: InputMaybe<Scalars['Boolean']>;
  views_last_30_days: InputMaybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type Dbt_Store_Product_For_Analytics_Max_Fields = {
  __typename?: 'dbt_store_product_for_analytics_max_fields';
  brand: Maybe<Scalars['String']>;
  brand_rating: Maybe<Scalars['BrandRating']>;
  calculated_notation: Maybe<Scalars['ProductNotation']>;
  calculated_notation_beta: Maybe<Scalars['ProductNotation']>;
  calculated_scoring: Maybe<Scalars['float8']>;
  condition_from_variants: Maybe<Scalars['Condition']>;
  created_at: Maybe<Scalars['timestamptz']>;
  default_vendor_notation: Maybe<Scalars['ProductNotation']>;
  ean_code: Maybe<Scalars['String']>;
  highest_discount: Maybe<Scalars['float8']>;
  id: Maybe<Scalars['String']>;
  image_count: Maybe<Scalars['Int']>;
  manual_notation: Maybe<Scalars['ProductNotation']>;
  model_year: Maybe<Scalars['Int']>;
  model_year_with_override: Maybe<Scalars['Int']>;
  notation: Maybe<Scalars['ProductNotation']>;
  shopify_id: Maybe<Scalars['bigint']>;
  size: Maybe<Scalars['String']>;
  source: Maybe<Scalars['String']>;
  vendor_id: Maybe<Scalars['uuid']>;
  vendor_notation: Maybe<Scalars['ProductNotation']>;
  views_last_30_days: Maybe<Scalars['bigint']>;
};

/** aggregate min on columns */
export type Dbt_Store_Product_For_Analytics_Min_Fields = {
  __typename?: 'dbt_store_product_for_analytics_min_fields';
  brand: Maybe<Scalars['String']>;
  brand_rating: Maybe<Scalars['BrandRating']>;
  calculated_notation: Maybe<Scalars['ProductNotation']>;
  calculated_notation_beta: Maybe<Scalars['ProductNotation']>;
  calculated_scoring: Maybe<Scalars['float8']>;
  condition_from_variants: Maybe<Scalars['Condition']>;
  created_at: Maybe<Scalars['timestamptz']>;
  default_vendor_notation: Maybe<Scalars['ProductNotation']>;
  ean_code: Maybe<Scalars['String']>;
  highest_discount: Maybe<Scalars['float8']>;
  id: Maybe<Scalars['String']>;
  image_count: Maybe<Scalars['Int']>;
  manual_notation: Maybe<Scalars['ProductNotation']>;
  model_year: Maybe<Scalars['Int']>;
  model_year_with_override: Maybe<Scalars['Int']>;
  notation: Maybe<Scalars['ProductNotation']>;
  shopify_id: Maybe<Scalars['bigint']>;
  size: Maybe<Scalars['String']>;
  source: Maybe<Scalars['String']>;
  vendor_id: Maybe<Scalars['uuid']>;
  vendor_notation: Maybe<Scalars['ProductNotation']>;
  views_last_30_days: Maybe<Scalars['bigint']>;
};

/** response of any mutation on the table "dbt.store_product_for_analytics" */
export type Dbt_Store_Product_For_Analytics_Mutation_Response = {
  __typename?: 'dbt_store_product_for_analytics_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Dbt_Store_Product_For_Analytics>;
};

/** on_conflict condition type for table "dbt.store_product_for_analytics" */
export type Dbt_Store_Product_For_Analytics_On_Conflict = {
  constraint: Dbt_Store_Product_For_Analytics_Constraint;
  update_columns: Array<Dbt_Store_Product_For_Analytics_Update_Column>;
  where: InputMaybe<Dbt_Store_Product_For_Analytics_Bool_Exp>;
};

/** Ordering options when selecting data from "dbt.store_product_for_analytics". */
export type Dbt_Store_Product_For_Analytics_Order_By = {
  brand: InputMaybe<Order_By>;
  brand_rating: InputMaybe<Order_By>;
  calculated_notation: InputMaybe<Order_By>;
  calculated_notation_beta: InputMaybe<Order_By>;
  calculated_scoring: InputMaybe<Order_By>;
  condition_from_variants: InputMaybe<Order_By>;
  created_at: InputMaybe<Order_By>;
  default_vendor_notation: InputMaybe<Order_By>;
  ean_code: InputMaybe<Order_By>;
  highest_discount: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  image_count: InputMaybe<Order_By>;
  is_bike: InputMaybe<Order_By>;
  is_new: InputMaybe<Order_By>;
  manual_notation: InputMaybe<Order_By>;
  model_year: InputMaybe<Order_By>;
  model_year_with_override: InputMaybe<Order_By>;
  notation: InputMaybe<Order_By>;
  shopify_id: InputMaybe<Order_By>;
  size: InputMaybe<Order_By>;
  source: InputMaybe<Order_By>;
  vendor_id: InputMaybe<Order_By>;
  vendor_notation: InputMaybe<Order_By>;
  vendor_overrides_product_scoring: InputMaybe<Order_By>;
  views_last_30_days: InputMaybe<Order_By>;
};

/** primary key columns input for table: dbt.store_product_for_analytics */
export type Dbt_Store_Product_For_Analytics_Pk_Columns_Input = {
  id: Scalars['String'];
};

/** select columns of table "dbt.store_product_for_analytics" */
export enum Dbt_Store_Product_For_Analytics_Select_Column {
  /** column name */
  Brand = 'brand',
  /** column name */
  BrandRating = 'brand_rating',
  /** column name */
  CalculatedNotation = 'calculated_notation',
  /** column name */
  CalculatedNotationBeta = 'calculated_notation_beta',
  /** column name */
  CalculatedScoring = 'calculated_scoring',
  /** column name */
  ConditionFromVariants = 'condition_from_variants',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DefaultVendorNotation = 'default_vendor_notation',
  /** column name */
  EanCode = 'ean_code',
  /** column name */
  HighestDiscount = 'highest_discount',
  /** column name */
  Id = 'id',
  /** column name */
  ImageCount = 'image_count',
  /** column name */
  IsBike = 'is_bike',
  /** column name */
  IsNew = 'is_new',
  /** column name */
  ManualNotation = 'manual_notation',
  /** column name */
  ModelYear = 'model_year',
  /** column name */
  ModelYearWithOverride = 'model_year_with_override',
  /** column name */
  Notation = 'notation',
  /** column name */
  ShopifyId = 'shopify_id',
  /** column name */
  Size = 'size',
  /** column name */
  Source = 'source',
  /** column name */
  VendorId = 'vendor_id',
  /** column name */
  VendorNotation = 'vendor_notation',
  /** column name */
  VendorOverridesProductScoring = 'vendor_overrides_product_scoring',
  /** column name */
  ViewsLast_30Days = 'views_last_30_days',
}

/** input type for updating data in table "dbt.store_product_for_analytics" */
export type Dbt_Store_Product_For_Analytics_Set_Input = {
  brand: InputMaybe<Scalars['String']>;
  brand_rating: InputMaybe<Scalars['BrandRating']>;
  calculated_notation: InputMaybe<Scalars['ProductNotation']>;
  calculated_notation_beta: InputMaybe<Scalars['ProductNotation']>;
  calculated_scoring: InputMaybe<Scalars['float8']>;
  condition_from_variants: InputMaybe<Scalars['Condition']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  default_vendor_notation: InputMaybe<Scalars['ProductNotation']>;
  ean_code: InputMaybe<Scalars['String']>;
  highest_discount: InputMaybe<Scalars['float8']>;
  id: InputMaybe<Scalars['String']>;
  image_count: InputMaybe<Scalars['Int']>;
  is_bike: InputMaybe<Scalars['Boolean']>;
  is_new: InputMaybe<Scalars['Boolean']>;
  manual_notation: InputMaybe<Scalars['ProductNotation']>;
  model_year: InputMaybe<Scalars['Int']>;
  model_year_with_override: InputMaybe<Scalars['Int']>;
  notation: InputMaybe<Scalars['ProductNotation']>;
  shopify_id: InputMaybe<Scalars['bigint']>;
  size: InputMaybe<Scalars['String']>;
  source: InputMaybe<Scalars['String']>;
  vendor_id: InputMaybe<Scalars['uuid']>;
  vendor_notation: InputMaybe<Scalars['ProductNotation']>;
  vendor_overrides_product_scoring: InputMaybe<Scalars['Boolean']>;
  views_last_30_days: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type Dbt_Store_Product_For_Analytics_Stddev_Fields = {
  __typename?: 'dbt_store_product_for_analytics_stddev_fields';
  calculated_scoring: Maybe<Scalars['Float']>;
  highest_discount: Maybe<Scalars['Float']>;
  image_count: Maybe<Scalars['Float']>;
  model_year: Maybe<Scalars['Float']>;
  model_year_with_override: Maybe<Scalars['Float']>;
  shopify_id: Maybe<Scalars['Float']>;
  views_last_30_days: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Dbt_Store_Product_For_Analytics_Stddev_Pop_Fields = {
  __typename?: 'dbt_store_product_for_analytics_stddev_pop_fields';
  calculated_scoring: Maybe<Scalars['Float']>;
  highest_discount: Maybe<Scalars['Float']>;
  image_count: Maybe<Scalars['Float']>;
  model_year: Maybe<Scalars['Float']>;
  model_year_with_override: Maybe<Scalars['Float']>;
  shopify_id: Maybe<Scalars['Float']>;
  views_last_30_days: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Dbt_Store_Product_For_Analytics_Stddev_Samp_Fields = {
  __typename?: 'dbt_store_product_for_analytics_stddev_samp_fields';
  calculated_scoring: Maybe<Scalars['Float']>;
  highest_discount: Maybe<Scalars['Float']>;
  image_count: Maybe<Scalars['Float']>;
  model_year: Maybe<Scalars['Float']>;
  model_year_with_override: Maybe<Scalars['Float']>;
  shopify_id: Maybe<Scalars['Float']>;
  views_last_30_days: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "dbt_store_product_for_analytics" */
export type Dbt_Store_Product_For_Analytics_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Dbt_Store_Product_For_Analytics_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Dbt_Store_Product_For_Analytics_Stream_Cursor_Value_Input = {
  brand: InputMaybe<Scalars['String']>;
  brand_rating: InputMaybe<Scalars['BrandRating']>;
  calculated_notation: InputMaybe<Scalars['ProductNotation']>;
  calculated_notation_beta: InputMaybe<Scalars['ProductNotation']>;
  calculated_scoring: InputMaybe<Scalars['float8']>;
  condition_from_variants: InputMaybe<Scalars['Condition']>;
  created_at: InputMaybe<Scalars['timestamptz']>;
  default_vendor_notation: InputMaybe<Scalars['ProductNotation']>;
  ean_code: InputMaybe<Scalars['String']>;
  highest_discount: InputMaybe<Scalars['float8']>;
  id: InputMaybe<Scalars['String']>;
  image_count: InputMaybe<Scalars['Int']>;
  is_bike: InputMaybe<Scalars['Boolean']>;
  is_new: InputMaybe<Scalars['Boolean']>;
  manual_notation: InputMaybe<Scalars['ProductNotation']>;
  model_year: InputMaybe<Scalars['Int']>;
  model_year_with_override: InputMaybe<Scalars['Int']>;
  notation: InputMaybe<Scalars['ProductNotation']>;
  shopify_id: InputMaybe<Scalars['bigint']>;
  size: InputMaybe<Scalars['String']>;
  source: InputMaybe<Scalars['String']>;
  vendor_id: InputMaybe<Scalars['uuid']>;
  vendor_notation: InputMaybe<Scalars['ProductNotation']>;
  vendor_overrides_product_scoring: InputMaybe<Scalars['Boolean']>;
  views_last_30_days: InputMaybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type Dbt_Store_Product_For_Analytics_Sum_Fields = {
  __typename?: 'dbt_store_product_for_analytics_sum_fields';
  calculated_scoring: Maybe<Scalars['float8']>;
  highest_discount: Maybe<Scalars['float8']>;
  image_count: Maybe<Scalars['Int']>;
  model_year: Maybe<Scalars['Int']>;
  model_year_with_override: Maybe<Scalars['Int']>;
  shopify_id: Maybe<Scalars['bigint']>;
  views_last_30_days: Maybe<Scalars['bigint']>;
};

/** update columns of table "dbt.store_product_for_analytics" */
export enum Dbt_Store_Product_For_Analytics_Update_Column {
  /** column name */
  Brand = 'brand',
  /** column name */
  BrandRating = 'brand_rating',
  /** column name */
  CalculatedNotation = 'calculated_notation',
  /** column name */
  CalculatedNotationBeta = 'calculated_notation_beta',
  /** column name */
  CalculatedScoring = 'calculated_scoring',
  /** column name */
  ConditionFromVariants = 'condition_from_variants',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DefaultVendorNotation = 'default_vendor_notation',
  /** column name */
  EanCode = 'ean_code',
  /** column name */
  HighestDiscount = 'highest_discount',
  /** column name */
  Id = 'id',
  /** column name */
  ImageCount = 'image_count',
  /** column name */
  IsBike = 'is_bike',
  /** column name */
  IsNew = 'is_new',
  /** column name */
  ManualNotation = 'manual_notation',
  /** column name */
  ModelYear = 'model_year',
  /** column name */
  ModelYearWithOverride = 'model_year_with_override',
  /** column name */
  Notation = 'notation',
  /** column name */
  ShopifyId = 'shopify_id',
  /** column name */
  Size = 'size',
  /** column name */
  Source = 'source',
  /** column name */
  VendorId = 'vendor_id',
  /** column name */
  VendorNotation = 'vendor_notation',
  /** column name */
  VendorOverridesProductScoring = 'vendor_overrides_product_scoring',
  /** column name */
  ViewsLast_30Days = 'views_last_30_days',
}

export type Dbt_Store_Product_For_Analytics_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc: InputMaybe<Dbt_Store_Product_For_Analytics_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Dbt_Store_Product_For_Analytics_Set_Input>;
  /** filter the rows which have to be updated */
  where: Dbt_Store_Product_For_Analytics_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Dbt_Store_Product_For_Analytics_Var_Pop_Fields = {
  __typename?: 'dbt_store_product_for_analytics_var_pop_fields';
  calculated_scoring: Maybe<Scalars['Float']>;
  highest_discount: Maybe<Scalars['Float']>;
  image_count: Maybe<Scalars['Float']>;
  model_year: Maybe<Scalars['Float']>;
  model_year_with_override: Maybe<Scalars['Float']>;
  shopify_id: Maybe<Scalars['Float']>;
  views_last_30_days: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Dbt_Store_Product_For_Analytics_Var_Samp_Fields = {
  __typename?: 'dbt_store_product_for_analytics_var_samp_fields';
  calculated_scoring: Maybe<Scalars['Float']>;
  highest_discount: Maybe<Scalars['Float']>;
  image_count: Maybe<Scalars['Float']>;
  model_year: Maybe<Scalars['Float']>;
  model_year_with_override: Maybe<Scalars['Float']>;
  shopify_id: Maybe<Scalars['Float']>;
  views_last_30_days: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Dbt_Store_Product_For_Analytics_Variance_Fields = {
  __typename?: 'dbt_store_product_for_analytics_variance_fields';
  calculated_scoring: Maybe<Scalars['Float']>;
  highest_discount: Maybe<Scalars['Float']>;
  image_count: Maybe<Scalars['Float']>;
  model_year: Maybe<Scalars['Float']>;
  model_year_with_override: Maybe<Scalars['Float']>;
  shopify_id: Maybe<Scalars['Float']>;
  views_last_30_days: Maybe<Scalars['Float']>;
};

/** Boolean expression to compare columns of type "float8". All fields are combined with logical 'AND'. */
export type Float8_Comparison_Exp = {
  _eq: InputMaybe<Scalars['float8']>;
  _gt: InputMaybe<Scalars['float8']>;
  _gte: InputMaybe<Scalars['float8']>;
  _in: InputMaybe<Array<Scalars['float8']>>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  _lt: InputMaybe<Scalars['float8']>;
  _lte: InputMaybe<Scalars['float8']>;
  _neq: InputMaybe<Scalars['float8']>;
  _nin: InputMaybe<Array<Scalars['float8']>>;
};

export type Jsonb_Cast_Exp = {
  String: InputMaybe<String_Comparison_Exp>;
};

/** Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'. */
export type Jsonb_Comparison_Exp = {
  _cast: InputMaybe<Jsonb_Cast_Exp>;
  /** is the column contained in the given json value */
  _contained_in: InputMaybe<Scalars['jsonb']>;
  /** does the column contain the given json value at the top level */
  _contains: InputMaybe<Scalars['jsonb']>;
  _eq: InputMaybe<Scalars['jsonb']>;
  _gt: InputMaybe<Scalars['jsonb']>;
  _gte: InputMaybe<Scalars['jsonb']>;
  /** does the string exist as a top-level key in the column */
  _has_key: InputMaybe<Scalars['String']>;
  /** do all of these strings exist as top-level keys in the column */
  _has_keys_all: InputMaybe<Array<Scalars['String']>>;
  /** do any of these strings exist as top-level keys in the column */
  _has_keys_any: InputMaybe<Array<Scalars['String']>>;
  _in: InputMaybe<Array<Scalars['jsonb']>>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  _lt: InputMaybe<Scalars['jsonb']>;
  _lte: InputMaybe<Scalars['jsonb']>;
  _neq: InputMaybe<Scalars['jsonb']>;
  _nin: InputMaybe<Array<Scalars['jsonb']>>;
};

/** mutation root */
export type Mutation_Root = {
  __typename?: 'mutation_root';
  /** delete single row from the table: "auth.providers" */
  deleteAuthProvider: Maybe<AuthProviders>;
  /** delete single row from the table: "auth.provider_requests" */
  deleteAuthProviderRequest: Maybe<AuthProviderRequests>;
  /** delete data from the table: "auth.provider_requests" */
  deleteAuthProviderRequests: Maybe<AuthProviderRequests_Mutation_Response>;
  /** delete data from the table: "auth.providers" */
  deleteAuthProviders: Maybe<AuthProviders_Mutation_Response>;
  /** delete single row from the table: "auth.refresh_tokens" */
  deleteAuthRefreshToken: Maybe<AuthRefreshTokens>;
  /** delete data from the table: "auth.refresh_tokens" */
  deleteAuthRefreshTokens: Maybe<AuthRefreshTokens_Mutation_Response>;
  /** delete single row from the table: "auth.user_roles" */
  deleteAuthUserRole: Maybe<AuthUserRoles>;
  /** delete data from the table: "auth.user_roles" */
  deleteAuthUserRoles: Maybe<AuthUserRoles_Mutation_Response>;
  /** delete single row from the table: "auth.user_security_keys" */
  deleteAuthUserSecurityKey: Maybe<AuthUserSecurityKeys>;
  /** delete data from the table: "auth.user_security_keys" */
  deleteAuthUserSecurityKeys: Maybe<AuthUserSecurityKeys_Mutation_Response>;
  /** delete single row from the table: "auth.users" */
  deleteUser: Maybe<Users>;
  /** delete data from the table: "auth.users" */
  deleteUsers: Maybe<Users_Mutation_Response>;
  /** delete data from the table: "Checkout" */
  delete_Checkout: Maybe<Checkout_Mutation_Response>;
  /** delete single row from the table: "Checkout" */
  delete_Checkout_by_pk: Maybe<Checkout>;
  /** delete data from the table: "Collection" */
  delete_Collection: Maybe<Collection_Mutation_Response>;
  /** delete single row from the table: "Collection" */
  delete_Collection_by_pk: Maybe<Collection>;
  /** delete data from the table: "Customer" */
  delete_Customer: Maybe<Customer_Mutation_Response>;
  /** delete single row from the table: "Customer" */
  delete_Customer_by_pk: Maybe<Customer>;
  /** delete data from the table: "Dispute" */
  delete_Dispute: Maybe<Dispute_Mutation_Response>;
  /** delete data from the table: "DisputeAttachment" */
  delete_DisputeAttachment: Maybe<DisputeAttachment_Mutation_Response>;
  /** delete single row from the table: "DisputeAttachment" */
  delete_DisputeAttachment_by_pk: Maybe<DisputeAttachment>;
  /** delete single row from the table: "Dispute" */
  delete_Dispute_by_pk: Maybe<Dispute>;
  /** delete data from the table: "Event" */
  delete_Event: Maybe<Event_Mutation_Response>;
  /** delete single row from the table: "Event" */
  delete_Event_by_pk: Maybe<Event>;
  /** delete data from the table: "FacetFilter" */
  delete_FacetFilter: Maybe<FacetFilter_Mutation_Response>;
  /** delete single row from the table: "FacetFilter" */
  delete_FacetFilter_by_pk: Maybe<FacetFilter>;
  /** delete data from the table: "FavoriteProducts" */
  delete_FavoriteProducts: Maybe<FavoriteProducts_Mutation_Response>;
  /** delete single row from the table: "FavoriteProducts" */
  delete_FavoriteProducts_by_pk: Maybe<FavoriteProducts>;
  /** delete data from the table: "Fulfillment" */
  delete_Fulfillment: Maybe<Fulfillment_Mutation_Response>;
  /** delete data from the table: "FulfillmentItem" */
  delete_FulfillmentItem: Maybe<FulfillmentItem_Mutation_Response>;
  /** delete single row from the table: "FulfillmentItem" */
  delete_FulfillmentItem_by_pk: Maybe<FulfillmentItem>;
  /** delete data from the table: "FulfillmentOrder" */
  delete_FulfillmentOrder: Maybe<FulfillmentOrder_Mutation_Response>;
  /** delete single row from the table: "FulfillmentOrder" */
  delete_FulfillmentOrder_by_pk: Maybe<FulfillmentOrder>;
  /** delete single row from the table: "Fulfillment" */
  delete_Fulfillment_by_pk: Maybe<Fulfillment>;
  /** delete data from the table: "NegociationAgreement" */
  delete_NegociationAgreement: Maybe<NegociationAgreement_Mutation_Response>;
  /** delete single row from the table: "NegociationAgreement" */
  delete_NegociationAgreement_by_pk: Maybe<NegociationAgreement>;
  /** delete data from the table: "NumericFilter" */
  delete_NumericFilter: Maybe<NumericFilter_Mutation_Response>;
  /** delete single row from the table: "NumericFilter" */
  delete_NumericFilter_by_pk: Maybe<NumericFilter>;
  /** delete data from the table: "Order" */
  delete_Order: Maybe<Order_Mutation_Response>;
  /** delete data from the table: "OrderLines" */
  delete_OrderLines: Maybe<OrderLines_Mutation_Response>;
  /** delete single row from the table: "OrderLines" */
  delete_OrderLines_by_pk: Maybe<OrderLines>;
  /** delete single row from the table: "Order" */
  delete_Order_by_pk: Maybe<Order>;
  /** delete data from the table: "Payment" */
  delete_Payment: Maybe<Payment_Mutation_Response>;
  /** delete data from the table: "PaymentAccounts" */
  delete_PaymentAccounts: Maybe<PaymentAccounts_Mutation_Response>;
  /** delete single row from the table: "PaymentAccounts" */
  delete_PaymentAccounts_by_pk: Maybe<PaymentAccounts>;
  /** delete single row from the table: "Payment" */
  delete_Payment_by_pk: Maybe<Payment>;
  /** delete data from the table: "Payout" */
  delete_Payout: Maybe<Payout_Mutation_Response>;
  /** delete single row from the table: "Payout" */
  delete_Payout_by_pk: Maybe<Payout>;
  /** delete data from the table: "PriceOffer" */
  delete_PriceOffer: Maybe<PriceOffer_Mutation_Response>;
  /** delete single row from the table: "PriceOffer" */
  delete_PriceOffer_by_pk: Maybe<PriceOffer>;
  /** delete data from the table: "Product" */
  delete_Product: Maybe<Product_Mutation_Response>;
  /** delete data from the table: "ProductVariant" */
  delete_ProductVariant: Maybe<ProductVariant_Mutation_Response>;
  /** delete single row from the table: "ProductVariant" */
  delete_ProductVariant_by_pk: Maybe<ProductVariant>;
  /** delete single row from the table: "Product" */
  delete_Product_by_pk: Maybe<Product>;
  /** delete data from the table: "Return" */
  delete_Return: Maybe<Return_Mutation_Response>;
  /** delete data from the table: "ReturnItem" */
  delete_ReturnItem: Maybe<ReturnItem_Mutation_Response>;
  /** delete single row from the table: "ReturnItem" */
  delete_ReturnItem_by_pk: Maybe<ReturnItem>;
  /** delete single row from the table: "Return" */
  delete_Return_by_pk: Maybe<Return>;
  /** delete data from the table: "Review" */
  delete_Review: Maybe<Review_Mutation_Response>;
  /** delete single row from the table: "Review" */
  delete_Review_by_pk: Maybe<Review>;
  /** delete data from the table: "SavedSearch" */
  delete_SavedSearch: Maybe<SavedSearch_Mutation_Response>;
  /** delete single row from the table: "SavedSearch" */
  delete_SavedSearch_by_pk: Maybe<SavedSearch>;
  /** delete data from the table: "SearchAlert" */
  delete_SearchAlert: Maybe<SearchAlert_Mutation_Response>;
  /** delete single row from the table: "SearchAlert" */
  delete_SearchAlert_by_pk: Maybe<SearchAlert>;
  /** delete data from the table: "VendorProCategoryMapping" */
  delete_VendorProCategoryMapping: Maybe<VendorProCategoryMapping_Mutation_Response>;
  /** delete single row from the table: "VendorProCategoryMapping" */
  delete_VendorProCategoryMapping_by_pk: Maybe<VendorProCategoryMapping>;
  /** delete data from the table: "VendorProTagMapping" */
  delete_VendorProTagMapping: Maybe<VendorProTagMapping_Mutation_Response>;
  /** delete single row from the table: "VendorProTagMapping" */
  delete_VendorProTagMapping_by_pk: Maybe<VendorProTagMapping>;
  /** delete data from the table: "VendorProTagValueMapping" */
  delete_VendorProTagValueMapping: Maybe<VendorProTagValueMapping_Mutation_Response>;
  /** delete single row from the table: "VendorProTagValueMapping" */
  delete_VendorProTagValueMapping_by_pk: Maybe<VendorProTagValueMapping>;
  /** delete data from the table: "VendorReview" */
  delete_VendorReview: Maybe<VendorReview_Mutation_Response>;
  /** delete single row from the table: "VendorReview" */
  delete_VendorReview_by_pk: Maybe<VendorReview>;
  /** delete data from the table: "auth.roles" */
  delete_auth_roles: Maybe<Auth_Roles_Mutation_Response>;
  /** delete single row from the table: "auth.roles" */
  delete_auth_roles_by_pk: Maybe<Auth_Roles>;
  /** delete data from the table: "auth.user_providers" */
  delete_auth_user_providers: Maybe<Auth_User_Providers_Mutation_Response>;
  /** delete single row from the table: "auth.user_providers" */
  delete_auth_user_providers_by_pk: Maybe<Auth_User_Providers>;
  /** delete data from the table: "dbt.store_base_product" */
  delete_dbt_store_base_product: Maybe<Dbt_Store_Base_Product_Mutation_Response>;
  /** delete single row from the table: "dbt.store_base_product" */
  delete_dbt_store_base_product_by_pk: Maybe<Dbt_Store_Base_Product>;
  /** delete data from the table: "dbt.store_base_product_variant" */
  delete_dbt_store_base_product_variant: Maybe<Dbt_Store_Base_Product_Variant_Mutation_Response>;
  /** delete single row from the table: "dbt.store_base_product_variant" */
  delete_dbt_store_base_product_variant_by_pk: Maybe<Dbt_Store_Base_Product_Variant>;
  /** delete data from the table: "dbt.store_discount" */
  delete_dbt_store_discount: Maybe<Dbt_Store_Discount_Mutation_Response>;
  /** delete data from the table: "dbt.store_discount_collection" */
  delete_dbt_store_discount_collection: Maybe<Dbt_Store_Discount_Collection_Mutation_Response>;
  /** delete single row from the table: "dbt.store_discount_collection" */
  delete_dbt_store_discount_collection_by_pk: Maybe<Dbt_Store_Discount_Collection>;
  /** delete data from the table: "dbt.store_exposed_product" */
  delete_dbt_store_exposed_product: Maybe<Dbt_Store_Exposed_Product_Mutation_Response>;
  /** delete single row from the table: "dbt.store_exposed_product" */
  delete_dbt_store_exposed_product_by_pk: Maybe<Dbt_Store_Exposed_Product>;
  /** delete data from the table: "dbt.store_exposed_product_image" */
  delete_dbt_store_exposed_product_image: Maybe<Dbt_Store_Exposed_Product_Image_Mutation_Response>;
  /** delete single row from the table: "dbt.store_exposed_product_image" */
  delete_dbt_store_exposed_product_image_by_pk: Maybe<Dbt_Store_Exposed_Product_Image>;
  /** delete data from the table: "dbt.store_exposed_product_tag" */
  delete_dbt_store_exposed_product_tag: Maybe<Dbt_Store_Exposed_Product_Tag_Mutation_Response>;
  /** delete data from the table: "dbt.store_exposed_product_variant" */
  delete_dbt_store_exposed_product_variant: Maybe<Dbt_Store_Exposed_Product_Variant_Mutation_Response>;
  /** delete single row from the table: "dbt.store_exposed_product_variant" */
  delete_dbt_store_exposed_product_variant_by_pk: Maybe<Dbt_Store_Exposed_Product_Variant>;
  /** delete data from the table: "dbt.store_product_collection" */
  delete_dbt_store_product_collection: Maybe<Dbt_Store_Product_Collection_Mutation_Response>;
  /** delete single row from the table: "dbt.store_product_collection" */
  delete_dbt_store_product_collection_by_pk: Maybe<Dbt_Store_Product_Collection>;
  /** delete data from the table: "dbt.store_product_for_analytics" */
  delete_dbt_store_product_for_analytics: Maybe<Dbt_Store_Product_For_Analytics_Mutation_Response>;
  /** delete single row from the table: "dbt.store_product_for_analytics" */
  delete_dbt_store_product_for_analytics_by_pk: Maybe<Dbt_Store_Product_For_Analytics>;
  /** insert a single row into the table: "auth.providers" */
  insertAuthProvider: Maybe<AuthProviders>;
  /** insert a single row into the table: "auth.provider_requests" */
  insertAuthProviderRequest: Maybe<AuthProviderRequests>;
  /** insert data into the table: "auth.provider_requests" */
  insertAuthProviderRequests: Maybe<AuthProviderRequests_Mutation_Response>;
  /** insert data into the table: "auth.providers" */
  insertAuthProviders: Maybe<AuthProviders_Mutation_Response>;
  /** insert a single row into the table: "auth.refresh_tokens" */
  insertAuthRefreshToken: Maybe<AuthRefreshTokens>;
  /** insert data into the table: "auth.refresh_tokens" */
  insertAuthRefreshTokens: Maybe<AuthRefreshTokens_Mutation_Response>;
  /** insert a single row into the table: "auth.user_roles" */
  insertAuthUserRole: Maybe<AuthUserRoles>;
  /** insert data into the table: "auth.user_roles" */
  insertAuthUserRoles: Maybe<AuthUserRoles_Mutation_Response>;
  /** insert a single row into the table: "auth.user_security_keys" */
  insertAuthUserSecurityKey: Maybe<AuthUserSecurityKeys>;
  /** insert data into the table: "auth.user_security_keys" */
  insertAuthUserSecurityKeys: Maybe<AuthUserSecurityKeys_Mutation_Response>;
  /** insert a single row into the table: "auth.users" */
  insertUser: Maybe<Users>;
  /** insert data into the table: "auth.users" */
  insertUsers: Maybe<Users_Mutation_Response>;
  /** insert data into the table: "Checkout" */
  insert_Checkout: Maybe<Checkout_Mutation_Response>;
  /** insert a single row into the table: "Checkout" */
  insert_Checkout_one: Maybe<Checkout>;
  /** insert data into the table: "Collection" */
  insert_Collection: Maybe<Collection_Mutation_Response>;
  /** insert a single row into the table: "Collection" */
  insert_Collection_one: Maybe<Collection>;
  /** insert data into the table: "Customer" */
  insert_Customer: Maybe<Customer_Mutation_Response>;
  /** insert a single row into the table: "Customer" */
  insert_Customer_one: Maybe<Customer>;
  /** insert data into the table: "Dispute" */
  insert_Dispute: Maybe<Dispute_Mutation_Response>;
  /** insert data into the table: "DisputeAttachment" */
  insert_DisputeAttachment: Maybe<DisputeAttachment_Mutation_Response>;
  /** insert a single row into the table: "DisputeAttachment" */
  insert_DisputeAttachment_one: Maybe<DisputeAttachment>;
  /** insert a single row into the table: "Dispute" */
  insert_Dispute_one: Maybe<Dispute>;
  /** insert data into the table: "Event" */
  insert_Event: Maybe<Event_Mutation_Response>;
  /** insert a single row into the table: "Event" */
  insert_Event_one: Maybe<Event>;
  /** insert data into the table: "FacetFilter" */
  insert_FacetFilter: Maybe<FacetFilter_Mutation_Response>;
  /** insert a single row into the table: "FacetFilter" */
  insert_FacetFilter_one: Maybe<FacetFilter>;
  /** insert data into the table: "FavoriteProducts" */
  insert_FavoriteProducts: Maybe<FavoriteProducts_Mutation_Response>;
  /** insert a single row into the table: "FavoriteProducts" */
  insert_FavoriteProducts_one: Maybe<FavoriteProducts>;
  /** insert data into the table: "Fulfillment" */
  insert_Fulfillment: Maybe<Fulfillment_Mutation_Response>;
  /** insert data into the table: "FulfillmentItem" */
  insert_FulfillmentItem: Maybe<FulfillmentItem_Mutation_Response>;
  /** insert a single row into the table: "FulfillmentItem" */
  insert_FulfillmentItem_one: Maybe<FulfillmentItem>;
  /** insert data into the table: "FulfillmentOrder" */
  insert_FulfillmentOrder: Maybe<FulfillmentOrder_Mutation_Response>;
  /** insert a single row into the table: "FulfillmentOrder" */
  insert_FulfillmentOrder_one: Maybe<FulfillmentOrder>;
  /** insert a single row into the table: "Fulfillment" */
  insert_Fulfillment_one: Maybe<Fulfillment>;
  /** insert data into the table: "NegociationAgreement" */
  insert_NegociationAgreement: Maybe<NegociationAgreement_Mutation_Response>;
  /** insert a single row into the table: "NegociationAgreement" */
  insert_NegociationAgreement_one: Maybe<NegociationAgreement>;
  /** insert data into the table: "NumericFilter" */
  insert_NumericFilter: Maybe<NumericFilter_Mutation_Response>;
  /** insert a single row into the table: "NumericFilter" */
  insert_NumericFilter_one: Maybe<NumericFilter>;
  /** insert data into the table: "Order" */
  insert_Order: Maybe<Order_Mutation_Response>;
  /** insert data into the table: "OrderLines" */
  insert_OrderLines: Maybe<OrderLines_Mutation_Response>;
  /** insert a single row into the table: "OrderLines" */
  insert_OrderLines_one: Maybe<OrderLines>;
  /** insert a single row into the table: "Order" */
  insert_Order_one: Maybe<Order>;
  /** insert data into the table: "Payment" */
  insert_Payment: Maybe<Payment_Mutation_Response>;
  /** insert data into the table: "PaymentAccounts" */
  insert_PaymentAccounts: Maybe<PaymentAccounts_Mutation_Response>;
  /** insert a single row into the table: "PaymentAccounts" */
  insert_PaymentAccounts_one: Maybe<PaymentAccounts>;
  /** insert a single row into the table: "Payment" */
  insert_Payment_one: Maybe<Payment>;
  /** insert data into the table: "Payout" */
  insert_Payout: Maybe<Payout_Mutation_Response>;
  /** insert a single row into the table: "Payout" */
  insert_Payout_one: Maybe<Payout>;
  /** insert data into the table: "PriceOffer" */
  insert_PriceOffer: Maybe<PriceOffer_Mutation_Response>;
  /** insert a single row into the table: "PriceOffer" */
  insert_PriceOffer_one: Maybe<PriceOffer>;
  /** insert data into the table: "Product" */
  insert_Product: Maybe<Product_Mutation_Response>;
  /** insert data into the table: "ProductVariant" */
  insert_ProductVariant: Maybe<ProductVariant_Mutation_Response>;
  /** insert a single row into the table: "ProductVariant" */
  insert_ProductVariant_one: Maybe<ProductVariant>;
  /** insert a single row into the table: "Product" */
  insert_Product_one: Maybe<Product>;
  /** insert data into the table: "Return" */
  insert_Return: Maybe<Return_Mutation_Response>;
  /** insert data into the table: "ReturnItem" */
  insert_ReturnItem: Maybe<ReturnItem_Mutation_Response>;
  /** insert a single row into the table: "ReturnItem" */
  insert_ReturnItem_one: Maybe<ReturnItem>;
  /** insert a single row into the table: "Return" */
  insert_Return_one: Maybe<Return>;
  /** insert data into the table: "Review" */
  insert_Review: Maybe<Review_Mutation_Response>;
  /** insert a single row into the table: "Review" */
  insert_Review_one: Maybe<Review>;
  /** insert data into the table: "SavedSearch" */
  insert_SavedSearch: Maybe<SavedSearch_Mutation_Response>;
  /** insert a single row into the table: "SavedSearch" */
  insert_SavedSearch_one: Maybe<SavedSearch>;
  /** insert data into the table: "SearchAlert" */
  insert_SearchAlert: Maybe<SearchAlert_Mutation_Response>;
  /** insert a single row into the table: "SearchAlert" */
  insert_SearchAlert_one: Maybe<SearchAlert>;
  /** insert data into the table: "VendorProCategoryMapping" */
  insert_VendorProCategoryMapping: Maybe<VendorProCategoryMapping_Mutation_Response>;
  /** insert a single row into the table: "VendorProCategoryMapping" */
  insert_VendorProCategoryMapping_one: Maybe<VendorProCategoryMapping>;
  /** insert data into the table: "VendorProTagMapping" */
  insert_VendorProTagMapping: Maybe<VendorProTagMapping_Mutation_Response>;
  /** insert a single row into the table: "VendorProTagMapping" */
  insert_VendorProTagMapping_one: Maybe<VendorProTagMapping>;
  /** insert data into the table: "VendorProTagValueMapping" */
  insert_VendorProTagValueMapping: Maybe<VendorProTagValueMapping_Mutation_Response>;
  /** insert a single row into the table: "VendorProTagValueMapping" */
  insert_VendorProTagValueMapping_one: Maybe<VendorProTagValueMapping>;
  /** insert data into the table: "VendorReview" */
  insert_VendorReview: Maybe<VendorReview_Mutation_Response>;
  /** insert a single row into the table: "VendorReview" */
  insert_VendorReview_one: Maybe<VendorReview>;
  /** insert data into the table: "auth.roles" */
  insert_auth_roles: Maybe<Auth_Roles_Mutation_Response>;
  /** insert a single row into the table: "auth.roles" */
  insert_auth_roles_one: Maybe<Auth_Roles>;
  /** insert data into the table: "auth.user_providers" */
  insert_auth_user_providers: Maybe<Auth_User_Providers_Mutation_Response>;
  /** insert a single row into the table: "auth.user_providers" */
  insert_auth_user_providers_one: Maybe<Auth_User_Providers>;
  /** insert data into the table: "dbt.store_base_product" */
  insert_dbt_store_base_product: Maybe<Dbt_Store_Base_Product_Mutation_Response>;
  /** insert a single row into the table: "dbt.store_base_product" */
  insert_dbt_store_base_product_one: Maybe<Dbt_Store_Base_Product>;
  /** insert data into the table: "dbt.store_base_product_variant" */
  insert_dbt_store_base_product_variant: Maybe<Dbt_Store_Base_Product_Variant_Mutation_Response>;
  /** insert a single row into the table: "dbt.store_base_product_variant" */
  insert_dbt_store_base_product_variant_one: Maybe<Dbt_Store_Base_Product_Variant>;
  /** insert data into the table: "dbt.store_discount" */
  insert_dbt_store_discount: Maybe<Dbt_Store_Discount_Mutation_Response>;
  /** insert data into the table: "dbt.store_discount_collection" */
  insert_dbt_store_discount_collection: Maybe<Dbt_Store_Discount_Collection_Mutation_Response>;
  /** insert a single row into the table: "dbt.store_discount_collection" */
  insert_dbt_store_discount_collection_one: Maybe<Dbt_Store_Discount_Collection>;
  /** insert a single row into the table: "dbt.store_discount" */
  insert_dbt_store_discount_one: Maybe<Dbt_Store_Discount>;
  /** insert data into the table: "dbt.store_exposed_product" */
  insert_dbt_store_exposed_product: Maybe<Dbt_Store_Exposed_Product_Mutation_Response>;
  /** insert data into the table: "dbt.store_exposed_product_image" */
  insert_dbt_store_exposed_product_image: Maybe<Dbt_Store_Exposed_Product_Image_Mutation_Response>;
  /** insert a single row into the table: "dbt.store_exposed_product_image" */
  insert_dbt_store_exposed_product_image_one: Maybe<Dbt_Store_Exposed_Product_Image>;
  /** insert a single row into the table: "dbt.store_exposed_product" */
  insert_dbt_store_exposed_product_one: Maybe<Dbt_Store_Exposed_Product>;
  /** insert data into the table: "dbt.store_exposed_product_tag" */
  insert_dbt_store_exposed_product_tag: Maybe<Dbt_Store_Exposed_Product_Tag_Mutation_Response>;
  /** insert a single row into the table: "dbt.store_exposed_product_tag" */
  insert_dbt_store_exposed_product_tag_one: Maybe<Dbt_Store_Exposed_Product_Tag>;
  /** insert data into the table: "dbt.store_exposed_product_variant" */
  insert_dbt_store_exposed_product_variant: Maybe<Dbt_Store_Exposed_Product_Variant_Mutation_Response>;
  /** insert a single row into the table: "dbt.store_exposed_product_variant" */
  insert_dbt_store_exposed_product_variant_one: Maybe<Dbt_Store_Exposed_Product_Variant>;
  /** insert data into the table: "dbt.store_product_collection" */
  insert_dbt_store_product_collection: Maybe<Dbt_Store_Product_Collection_Mutation_Response>;
  /** insert a single row into the table: "dbt.store_product_collection" */
  insert_dbt_store_product_collection_one: Maybe<Dbt_Store_Product_Collection>;
  /** insert data into the table: "dbt.store_product_for_analytics" */
  insert_dbt_store_product_for_analytics: Maybe<Dbt_Store_Product_For_Analytics_Mutation_Response>;
  /** insert a single row into the table: "dbt.store_product_for_analytics" */
  insert_dbt_store_product_for_analytics_one: Maybe<Dbt_Store_Product_For_Analytics>;
  shopify: Maybe<ShopifyMutation>;
  /** update single row of the table: "auth.providers" */
  updateAuthProvider: Maybe<AuthProviders>;
  /** update single row of the table: "auth.provider_requests" */
  updateAuthProviderRequest: Maybe<AuthProviderRequests>;
  /** update data of the table: "auth.provider_requests" */
  updateAuthProviderRequests: Maybe<AuthProviderRequests_Mutation_Response>;
  /** update data of the table: "auth.providers" */
  updateAuthProviders: Maybe<AuthProviders_Mutation_Response>;
  /** update single row of the table: "auth.refresh_tokens" */
  updateAuthRefreshToken: Maybe<AuthRefreshTokens>;
  /** update data of the table: "auth.refresh_tokens" */
  updateAuthRefreshTokens: Maybe<AuthRefreshTokens_Mutation_Response>;
  /** update single row of the table: "auth.user_roles" */
  updateAuthUserRole: Maybe<AuthUserRoles>;
  /** update data of the table: "auth.user_roles" */
  updateAuthUserRoles: Maybe<AuthUserRoles_Mutation_Response>;
  /** update single row of the table: "auth.user_security_keys" */
  updateAuthUserSecurityKey: Maybe<AuthUserSecurityKeys>;
  /** update data of the table: "auth.user_security_keys" */
  updateAuthUserSecurityKeys: Maybe<AuthUserSecurityKeys_Mutation_Response>;
  /** update single row of the table: "auth.users" */
  updateUser: Maybe<Users>;
  /** update data of the table: "auth.users" */
  updateUsers: Maybe<Users_Mutation_Response>;
  /** update data of the table: "Checkout" */
  update_Checkout: Maybe<Checkout_Mutation_Response>;
  /** update single row of the table: "Checkout" */
  update_Checkout_by_pk: Maybe<Checkout>;
  /** update multiples rows of table: "Checkout" */
  update_Checkout_many: Maybe<Array<Maybe<Checkout_Mutation_Response>>>;
  /** update data of the table: "Collection" */
  update_Collection: Maybe<Collection_Mutation_Response>;
  /** update single row of the table: "Collection" */
  update_Collection_by_pk: Maybe<Collection>;
  /** update multiples rows of table: "Collection" */
  update_Collection_many: Maybe<Array<Maybe<Collection_Mutation_Response>>>;
  /** update data of the table: "Customer" */
  update_Customer: Maybe<Customer_Mutation_Response>;
  /** update single row of the table: "Customer" */
  update_Customer_by_pk: Maybe<Customer>;
  /** update multiples rows of table: "Customer" */
  update_Customer_many: Maybe<Array<Maybe<Customer_Mutation_Response>>>;
  /** update data of the table: "Dispute" */
  update_Dispute: Maybe<Dispute_Mutation_Response>;
  /** update data of the table: "DisputeAttachment" */
  update_DisputeAttachment: Maybe<DisputeAttachment_Mutation_Response>;
  /** update single row of the table: "DisputeAttachment" */
  update_DisputeAttachment_by_pk: Maybe<DisputeAttachment>;
  /** update multiples rows of table: "DisputeAttachment" */
  update_DisputeAttachment_many: Maybe<
    Array<Maybe<DisputeAttachment_Mutation_Response>>
  >;
  /** update single row of the table: "Dispute" */
  update_Dispute_by_pk: Maybe<Dispute>;
  /** update multiples rows of table: "Dispute" */
  update_Dispute_many: Maybe<Array<Maybe<Dispute_Mutation_Response>>>;
  /** update data of the table: "Event" */
  update_Event: Maybe<Event_Mutation_Response>;
  /** update single row of the table: "Event" */
  update_Event_by_pk: Maybe<Event>;
  /** update multiples rows of table: "Event" */
  update_Event_many: Maybe<Array<Maybe<Event_Mutation_Response>>>;
  /** update data of the table: "FacetFilter" */
  update_FacetFilter: Maybe<FacetFilter_Mutation_Response>;
  /** update single row of the table: "FacetFilter" */
  update_FacetFilter_by_pk: Maybe<FacetFilter>;
  /** update multiples rows of table: "FacetFilter" */
  update_FacetFilter_many: Maybe<Array<Maybe<FacetFilter_Mutation_Response>>>;
  /** update data of the table: "FavoriteProducts" */
  update_FavoriteProducts: Maybe<FavoriteProducts_Mutation_Response>;
  /** update single row of the table: "FavoriteProducts" */
  update_FavoriteProducts_by_pk: Maybe<FavoriteProducts>;
  /** update multiples rows of table: "FavoriteProducts" */
  update_FavoriteProducts_many: Maybe<
    Array<Maybe<FavoriteProducts_Mutation_Response>>
  >;
  /** update data of the table: "Fulfillment" */
  update_Fulfillment: Maybe<Fulfillment_Mutation_Response>;
  /** update data of the table: "FulfillmentItem" */
  update_FulfillmentItem: Maybe<FulfillmentItem_Mutation_Response>;
  /** update single row of the table: "FulfillmentItem" */
  update_FulfillmentItem_by_pk: Maybe<FulfillmentItem>;
  /** update multiples rows of table: "FulfillmentItem" */
  update_FulfillmentItem_many: Maybe<
    Array<Maybe<FulfillmentItem_Mutation_Response>>
  >;
  /** update data of the table: "FulfillmentOrder" */
  update_FulfillmentOrder: Maybe<FulfillmentOrder_Mutation_Response>;
  /** update single row of the table: "FulfillmentOrder" */
  update_FulfillmentOrder_by_pk: Maybe<FulfillmentOrder>;
  /** update multiples rows of table: "FulfillmentOrder" */
  update_FulfillmentOrder_many: Maybe<
    Array<Maybe<FulfillmentOrder_Mutation_Response>>
  >;
  /** update single row of the table: "Fulfillment" */
  update_Fulfillment_by_pk: Maybe<Fulfillment>;
  /** update multiples rows of table: "Fulfillment" */
  update_Fulfillment_many: Maybe<Array<Maybe<Fulfillment_Mutation_Response>>>;
  /** update data of the table: "NegociationAgreement" */
  update_NegociationAgreement: Maybe<NegociationAgreement_Mutation_Response>;
  /** update single row of the table: "NegociationAgreement" */
  update_NegociationAgreement_by_pk: Maybe<NegociationAgreement>;
  /** update multiples rows of table: "NegociationAgreement" */
  update_NegociationAgreement_many: Maybe<
    Array<Maybe<NegociationAgreement_Mutation_Response>>
  >;
  /** update data of the table: "NumericFilter" */
  update_NumericFilter: Maybe<NumericFilter_Mutation_Response>;
  /** update single row of the table: "NumericFilter" */
  update_NumericFilter_by_pk: Maybe<NumericFilter>;
  /** update multiples rows of table: "NumericFilter" */
  update_NumericFilter_many: Maybe<
    Array<Maybe<NumericFilter_Mutation_Response>>
  >;
  /** update data of the table: "Order" */
  update_Order: Maybe<Order_Mutation_Response>;
  /** update data of the table: "OrderLines" */
  update_OrderLines: Maybe<OrderLines_Mutation_Response>;
  /** update single row of the table: "OrderLines" */
  update_OrderLines_by_pk: Maybe<OrderLines>;
  /** update multiples rows of table: "OrderLines" */
  update_OrderLines_many: Maybe<Array<Maybe<OrderLines_Mutation_Response>>>;
  /** update single row of the table: "Order" */
  update_Order_by_pk: Maybe<Order>;
  /** update multiples rows of table: "Order" */
  update_Order_many: Maybe<Array<Maybe<Order_Mutation_Response>>>;
  /** update data of the table: "Payment" */
  update_Payment: Maybe<Payment_Mutation_Response>;
  /** update data of the table: "PaymentAccounts" */
  update_PaymentAccounts: Maybe<PaymentAccounts_Mutation_Response>;
  /** update single row of the table: "PaymentAccounts" */
  update_PaymentAccounts_by_pk: Maybe<PaymentAccounts>;
  /** update multiples rows of table: "PaymentAccounts" */
  update_PaymentAccounts_many: Maybe<
    Array<Maybe<PaymentAccounts_Mutation_Response>>
  >;
  /** update single row of the table: "Payment" */
  update_Payment_by_pk: Maybe<Payment>;
  /** update multiples rows of table: "Payment" */
  update_Payment_many: Maybe<Array<Maybe<Payment_Mutation_Response>>>;
  /** update data of the table: "Payout" */
  update_Payout: Maybe<Payout_Mutation_Response>;
  /** update single row of the table: "Payout" */
  update_Payout_by_pk: Maybe<Payout>;
  /** update multiples rows of table: "Payout" */
  update_Payout_many: Maybe<Array<Maybe<Payout_Mutation_Response>>>;
  /** update data of the table: "PriceOffer" */
  update_PriceOffer: Maybe<PriceOffer_Mutation_Response>;
  /** update single row of the table: "PriceOffer" */
  update_PriceOffer_by_pk: Maybe<PriceOffer>;
  /** update multiples rows of table: "PriceOffer" */
  update_PriceOffer_many: Maybe<Array<Maybe<PriceOffer_Mutation_Response>>>;
  /** update data of the table: "Product" */
  update_Product: Maybe<Product_Mutation_Response>;
  /** update data of the table: "ProductVariant" */
  update_ProductVariant: Maybe<ProductVariant_Mutation_Response>;
  /** update single row of the table: "ProductVariant" */
  update_ProductVariant_by_pk: Maybe<ProductVariant>;
  /** update multiples rows of table: "ProductVariant" */
  update_ProductVariant_many: Maybe<
    Array<Maybe<ProductVariant_Mutation_Response>>
  >;
  /** update single row of the table: "Product" */
  update_Product_by_pk: Maybe<Product>;
  /** update multiples rows of table: "Product" */
  update_Product_many: Maybe<Array<Maybe<Product_Mutation_Response>>>;
  /** update data of the table: "Return" */
  update_Return: Maybe<Return_Mutation_Response>;
  /** update data of the table: "ReturnItem" */
  update_ReturnItem: Maybe<ReturnItem_Mutation_Response>;
  /** update single row of the table: "ReturnItem" */
  update_ReturnItem_by_pk: Maybe<ReturnItem>;
  /** update multiples rows of table: "ReturnItem" */
  update_ReturnItem_many: Maybe<Array<Maybe<ReturnItem_Mutation_Response>>>;
  /** update single row of the table: "Return" */
  update_Return_by_pk: Maybe<Return>;
  /** update multiples rows of table: "Return" */
  update_Return_many: Maybe<Array<Maybe<Return_Mutation_Response>>>;
  /** update data of the table: "Review" */
  update_Review: Maybe<Review_Mutation_Response>;
  /** update single row of the table: "Review" */
  update_Review_by_pk: Maybe<Review>;
  /** update multiples rows of table: "Review" */
  update_Review_many: Maybe<Array<Maybe<Review_Mutation_Response>>>;
  /** update data of the table: "SavedSearch" */
  update_SavedSearch: Maybe<SavedSearch_Mutation_Response>;
  /** update single row of the table: "SavedSearch" */
  update_SavedSearch_by_pk: Maybe<SavedSearch>;
  /** update multiples rows of table: "SavedSearch" */
  update_SavedSearch_many: Maybe<Array<Maybe<SavedSearch_Mutation_Response>>>;
  /** update data of the table: "SearchAlert" */
  update_SearchAlert: Maybe<SearchAlert_Mutation_Response>;
  /** update single row of the table: "SearchAlert" */
  update_SearchAlert_by_pk: Maybe<SearchAlert>;
  /** update multiples rows of table: "SearchAlert" */
  update_SearchAlert_many: Maybe<Array<Maybe<SearchAlert_Mutation_Response>>>;
  /** update data of the table: "VendorProCategoryMapping" */
  update_VendorProCategoryMapping: Maybe<VendorProCategoryMapping_Mutation_Response>;
  /** update single row of the table: "VendorProCategoryMapping" */
  update_VendorProCategoryMapping_by_pk: Maybe<VendorProCategoryMapping>;
  /** update multiples rows of table: "VendorProCategoryMapping" */
  update_VendorProCategoryMapping_many: Maybe<
    Array<Maybe<VendorProCategoryMapping_Mutation_Response>>
  >;
  /** update data of the table: "VendorProTagMapping" */
  update_VendorProTagMapping: Maybe<VendorProTagMapping_Mutation_Response>;
  /** update single row of the table: "VendorProTagMapping" */
  update_VendorProTagMapping_by_pk: Maybe<VendorProTagMapping>;
  /** update multiples rows of table: "VendorProTagMapping" */
  update_VendorProTagMapping_many: Maybe<
    Array<Maybe<VendorProTagMapping_Mutation_Response>>
  >;
  /** update data of the table: "VendorProTagValueMapping" */
  update_VendorProTagValueMapping: Maybe<VendorProTagValueMapping_Mutation_Response>;
  /** update single row of the table: "VendorProTagValueMapping" */
  update_VendorProTagValueMapping_by_pk: Maybe<VendorProTagValueMapping>;
  /** update multiples rows of table: "VendorProTagValueMapping" */
  update_VendorProTagValueMapping_many: Maybe<
    Array<Maybe<VendorProTagValueMapping_Mutation_Response>>
  >;
  /** update data of the table: "VendorReview" */
  update_VendorReview: Maybe<VendorReview_Mutation_Response>;
  /** update single row of the table: "VendorReview" */
  update_VendorReview_by_pk: Maybe<VendorReview>;
  /** update multiples rows of table: "VendorReview" */
  update_VendorReview_many: Maybe<Array<Maybe<VendorReview_Mutation_Response>>>;
  /** update multiples rows of table: "auth.provider_requests" */
  update_authProviderRequests_many: Maybe<
    Array<Maybe<AuthProviderRequests_Mutation_Response>>
  >;
  /** update multiples rows of table: "auth.providers" */
  update_authProviders_many: Maybe<
    Array<Maybe<AuthProviders_Mutation_Response>>
  >;
  /** update multiples rows of table: "auth.refresh_tokens" */
  update_authRefreshTokens_many: Maybe<
    Array<Maybe<AuthRefreshTokens_Mutation_Response>>
  >;
  /** update multiples rows of table: "auth.user_roles" */
  update_authUserRoles_many: Maybe<
    Array<Maybe<AuthUserRoles_Mutation_Response>>
  >;
  /** update multiples rows of table: "auth.user_security_keys" */
  update_authUserSecurityKeys_many: Maybe<
    Array<Maybe<AuthUserSecurityKeys_Mutation_Response>>
  >;
  /** update data of the table: "auth.roles" */
  update_auth_roles: Maybe<Auth_Roles_Mutation_Response>;
  /** update single row of the table: "auth.roles" */
  update_auth_roles_by_pk: Maybe<Auth_Roles>;
  /** update multiples rows of table: "auth.roles" */
  update_auth_roles_many: Maybe<Array<Maybe<Auth_Roles_Mutation_Response>>>;
  /** update data of the table: "auth.user_providers" */
  update_auth_user_providers: Maybe<Auth_User_Providers_Mutation_Response>;
  /** update single row of the table: "auth.user_providers" */
  update_auth_user_providers_by_pk: Maybe<Auth_User_Providers>;
  /** update multiples rows of table: "auth.user_providers" */
  update_auth_user_providers_many: Maybe<
    Array<Maybe<Auth_User_Providers_Mutation_Response>>
  >;
  /** update data of the table: "dbt.store_base_product" */
  update_dbt_store_base_product: Maybe<Dbt_Store_Base_Product_Mutation_Response>;
  /** update single row of the table: "dbt.store_base_product" */
  update_dbt_store_base_product_by_pk: Maybe<Dbt_Store_Base_Product>;
  /** update multiples rows of table: "dbt.store_base_product" */
  update_dbt_store_base_product_many: Maybe<
    Array<Maybe<Dbt_Store_Base_Product_Mutation_Response>>
  >;
  /** update data of the table: "dbt.store_base_product_variant" */
  update_dbt_store_base_product_variant: Maybe<Dbt_Store_Base_Product_Variant_Mutation_Response>;
  /** update single row of the table: "dbt.store_base_product_variant" */
  update_dbt_store_base_product_variant_by_pk: Maybe<Dbt_Store_Base_Product_Variant>;
  /** update multiples rows of table: "dbt.store_base_product_variant" */
  update_dbt_store_base_product_variant_many: Maybe<
    Array<Maybe<Dbt_Store_Base_Product_Variant_Mutation_Response>>
  >;
  /** update data of the table: "dbt.store_discount" */
  update_dbt_store_discount: Maybe<Dbt_Store_Discount_Mutation_Response>;
  /** update data of the table: "dbt.store_discount_collection" */
  update_dbt_store_discount_collection: Maybe<Dbt_Store_Discount_Collection_Mutation_Response>;
  /** update single row of the table: "dbt.store_discount_collection" */
  update_dbt_store_discount_collection_by_pk: Maybe<Dbt_Store_Discount_Collection>;
  /** update multiples rows of table: "dbt.store_discount_collection" */
  update_dbt_store_discount_collection_many: Maybe<
    Array<Maybe<Dbt_Store_Discount_Collection_Mutation_Response>>
  >;
  /** update multiples rows of table: "dbt.store_discount" */
  update_dbt_store_discount_many: Maybe<
    Array<Maybe<Dbt_Store_Discount_Mutation_Response>>
  >;
  /** update data of the table: "dbt.store_exposed_product" */
  update_dbt_store_exposed_product: Maybe<Dbt_Store_Exposed_Product_Mutation_Response>;
  /** update single row of the table: "dbt.store_exposed_product" */
  update_dbt_store_exposed_product_by_pk: Maybe<Dbt_Store_Exposed_Product>;
  /** update data of the table: "dbt.store_exposed_product_image" */
  update_dbt_store_exposed_product_image: Maybe<Dbt_Store_Exposed_Product_Image_Mutation_Response>;
  /** update single row of the table: "dbt.store_exposed_product_image" */
  update_dbt_store_exposed_product_image_by_pk: Maybe<Dbt_Store_Exposed_Product_Image>;
  /** update multiples rows of table: "dbt.store_exposed_product_image" */
  update_dbt_store_exposed_product_image_many: Maybe<
    Array<Maybe<Dbt_Store_Exposed_Product_Image_Mutation_Response>>
  >;
  /** update multiples rows of table: "dbt.store_exposed_product" */
  update_dbt_store_exposed_product_many: Maybe<
    Array<Maybe<Dbt_Store_Exposed_Product_Mutation_Response>>
  >;
  /** update data of the table: "dbt.store_exposed_product_tag" */
  update_dbt_store_exposed_product_tag: Maybe<Dbt_Store_Exposed_Product_Tag_Mutation_Response>;
  /** update multiples rows of table: "dbt.store_exposed_product_tag" */
  update_dbt_store_exposed_product_tag_many: Maybe<
    Array<Maybe<Dbt_Store_Exposed_Product_Tag_Mutation_Response>>
  >;
  /** update data of the table: "dbt.store_exposed_product_variant" */
  update_dbt_store_exposed_product_variant: Maybe<Dbt_Store_Exposed_Product_Variant_Mutation_Response>;
  /** update single row of the table: "dbt.store_exposed_product_variant" */
  update_dbt_store_exposed_product_variant_by_pk: Maybe<Dbt_Store_Exposed_Product_Variant>;
  /** update multiples rows of table: "dbt.store_exposed_product_variant" */
  update_dbt_store_exposed_product_variant_many: Maybe<
    Array<Maybe<Dbt_Store_Exposed_Product_Variant_Mutation_Response>>
  >;
  /** update data of the table: "dbt.store_product_collection" */
  update_dbt_store_product_collection: Maybe<Dbt_Store_Product_Collection_Mutation_Response>;
  /** update single row of the table: "dbt.store_product_collection" */
  update_dbt_store_product_collection_by_pk: Maybe<Dbt_Store_Product_Collection>;
  /** update multiples rows of table: "dbt.store_product_collection" */
  update_dbt_store_product_collection_many: Maybe<
    Array<Maybe<Dbt_Store_Product_Collection_Mutation_Response>>
  >;
  /** update data of the table: "dbt.store_product_for_analytics" */
  update_dbt_store_product_for_analytics: Maybe<Dbt_Store_Product_For_Analytics_Mutation_Response>;
  /** update single row of the table: "dbt.store_product_for_analytics" */
  update_dbt_store_product_for_analytics_by_pk: Maybe<Dbt_Store_Product_For_Analytics>;
  /** update multiples rows of table: "dbt.store_product_for_analytics" */
  update_dbt_store_product_for_analytics_many: Maybe<
    Array<Maybe<Dbt_Store_Product_For_Analytics_Mutation_Response>>
  >;
  /** update multiples rows of table: "auth.users" */
  update_users_many: Maybe<Array<Maybe<Users_Mutation_Response>>>;
};

/** mutation root */
export type Mutation_RootDeleteAuthProviderArgs = {
  id: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDeleteAuthProviderRequestArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDeleteAuthProviderRequestsArgs = {
  where: AuthProviderRequests_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDeleteAuthProvidersArgs = {
  where: AuthProviders_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDeleteAuthRefreshTokenArgs = {
  refreshToken: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDeleteAuthRefreshTokensArgs = {
  where: AuthRefreshTokens_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDeleteAuthUserRoleArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDeleteAuthUserRolesArgs = {
  where: AuthUserRoles_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDeleteAuthUserSecurityKeyArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDeleteAuthUserSecurityKeysArgs = {
  where: AuthUserSecurityKeys_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDeleteUserArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDeleteUsersArgs = {
  where: Users_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_CheckoutArgs = {
  where: Checkout_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Checkout_By_PkArgs = {
  id: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_CollectionArgs = {
  where: Collection_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Collection_By_PkArgs = {
  id: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_CustomerArgs = {
  where: Customer_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Customer_By_PkArgs = {
  authUserId: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_DisputeArgs = {
  where: Dispute_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_DisputeAttachmentArgs = {
  where: DisputeAttachment_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_DisputeAttachment_By_PkArgs = {
  id: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Dispute_By_PkArgs = {
  id: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_EventArgs = {
  where: Event_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Event_By_PkArgs = {
  id: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_FacetFilterArgs = {
  where: FacetFilter_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_FacetFilter_By_PkArgs = {
  id: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_FavoriteProductsArgs = {
  where: FavoriteProducts_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_FavoriteProducts_By_PkArgs = {
  id: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_FulfillmentArgs = {
  where: Fulfillment_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_FulfillmentItemArgs = {
  where: FulfillmentItem_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_FulfillmentItem_By_PkArgs = {
  id: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_FulfillmentOrderArgs = {
  where: FulfillmentOrder_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_FulfillmentOrder_By_PkArgs = {
  id: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Fulfillment_By_PkArgs = {
  id: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_NegociationAgreementArgs = {
  where: NegociationAgreement_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_NegociationAgreement_By_PkArgs = {
  id: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_NumericFilterArgs = {
  where: NumericFilter_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_NumericFilter_By_PkArgs = {
  id: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_OrderArgs = {
  where: Order_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_OrderLinesArgs = {
  where: OrderLines_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_OrderLines_By_PkArgs = {
  id: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Order_By_PkArgs = {
  id: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_PaymentArgs = {
  where: Payment_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_PaymentAccountsArgs = {
  where: PaymentAccounts_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_PaymentAccounts_By_PkArgs = {
  id: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Payment_By_PkArgs = {
  id: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_PayoutArgs = {
  where: Payout_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Payout_By_PkArgs = {
  id: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_PriceOfferArgs = {
  where: PriceOffer_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_PriceOffer_By_PkArgs = {
  id: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_ProductArgs = {
  where: Product_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_ProductVariantArgs = {
  where: ProductVariant_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_ProductVariant_By_PkArgs = {
  id: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Product_By_PkArgs = {
  id: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_ReturnArgs = {
  where: Return_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_ReturnItemArgs = {
  where: ReturnItem_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_ReturnItem_By_PkArgs = {
  id: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Return_By_PkArgs = {
  id: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_ReviewArgs = {
  where: Review_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Review_By_PkArgs = {
  id: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_SavedSearchArgs = {
  where: SavedSearch_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_SavedSearch_By_PkArgs = {
  id: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_SearchAlertArgs = {
  where: SearchAlert_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_SearchAlert_By_PkArgs = {
  id: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_VendorProCategoryMappingArgs = {
  where: VendorProCategoryMapping_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_VendorProCategoryMapping_By_PkArgs = {
  id: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_VendorProTagMappingArgs = {
  where: VendorProTagMapping_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_VendorProTagMapping_By_PkArgs = {
  id: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_VendorProTagValueMappingArgs = {
  where: VendorProTagValueMapping_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_VendorProTagValueMapping_By_PkArgs = {
  id: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_VendorReviewArgs = {
  where: VendorReview_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_VendorReview_By_PkArgs = {
  reviewId: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Auth_RolesArgs = {
  where: Auth_Roles_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Auth_Roles_By_PkArgs = {
  role: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Auth_User_ProvidersArgs = {
  where: Auth_User_Providers_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Auth_User_Providers_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Dbt_Store_Base_ProductArgs = {
  where: Dbt_Store_Base_Product_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Dbt_Store_Base_Product_By_PkArgs = {
  id: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Dbt_Store_Base_Product_VariantArgs = {
  where: Dbt_Store_Base_Product_Variant_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Dbt_Store_Base_Product_Variant_By_PkArgs = {
  shopify_id: Scalars['bigint'];
};

/** mutation root */
export type Mutation_RootDelete_Dbt_Store_DiscountArgs = {
  where: Dbt_Store_Discount_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Dbt_Store_Discount_CollectionArgs = {
  where: Dbt_Store_Discount_Collection_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Dbt_Store_Discount_Collection_By_PkArgs = {
  collection_internal_id: Scalars['String'];
  discount_id: Scalars['bigint'];
};

/** mutation root */
export type Mutation_RootDelete_Dbt_Store_Exposed_ProductArgs = {
  where: Dbt_Store_Exposed_Product_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Dbt_Store_Exposed_Product_By_PkArgs = {
  id: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Dbt_Store_Exposed_Product_ImageArgs = {
  where: Dbt_Store_Exposed_Product_Image_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Dbt_Store_Exposed_Product_Image_By_PkArgs = {
  shopify_id: Scalars['bigint'];
};

/** mutation root */
export type Mutation_RootDelete_Dbt_Store_Exposed_Product_TagArgs = {
  where: Dbt_Store_Exposed_Product_Tag_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Dbt_Store_Exposed_Product_VariantArgs = {
  where: Dbt_Store_Exposed_Product_Variant_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Dbt_Store_Exposed_Product_Variant_By_PkArgs = {
  shopify_id: Scalars['bigint'];
};

/** mutation root */
export type Mutation_RootDelete_Dbt_Store_Product_CollectionArgs = {
  where: Dbt_Store_Product_Collection_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Dbt_Store_Product_Collection_By_PkArgs = {
  collection_id: Scalars['String'];
  product_id: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Dbt_Store_Product_For_AnalyticsArgs = {
  where: Dbt_Store_Product_For_Analytics_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Dbt_Store_Product_For_Analytics_By_PkArgs = {
  id: Scalars['String'];
};

/** mutation root */
export type Mutation_RootInsertAuthProviderArgs = {
  object: AuthProviders_Insert_Input;
  on_conflict: InputMaybe<AuthProviders_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsertAuthProviderRequestArgs = {
  object: AuthProviderRequests_Insert_Input;
  on_conflict: InputMaybe<AuthProviderRequests_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsertAuthProviderRequestsArgs = {
  objects: Array<AuthProviderRequests_Insert_Input>;
  on_conflict: InputMaybe<AuthProviderRequests_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsertAuthProvidersArgs = {
  objects: Array<AuthProviders_Insert_Input>;
  on_conflict: InputMaybe<AuthProviders_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsertAuthRefreshTokenArgs = {
  object: AuthRefreshTokens_Insert_Input;
  on_conflict: InputMaybe<AuthRefreshTokens_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsertAuthRefreshTokensArgs = {
  objects: Array<AuthRefreshTokens_Insert_Input>;
  on_conflict: InputMaybe<AuthRefreshTokens_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsertAuthUserRoleArgs = {
  object: AuthUserRoles_Insert_Input;
  on_conflict: InputMaybe<AuthUserRoles_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsertAuthUserRolesArgs = {
  objects: Array<AuthUserRoles_Insert_Input>;
  on_conflict: InputMaybe<AuthUserRoles_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsertAuthUserSecurityKeyArgs = {
  object: AuthUserSecurityKeys_Insert_Input;
  on_conflict: InputMaybe<AuthUserSecurityKeys_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsertAuthUserSecurityKeysArgs = {
  objects: Array<AuthUserSecurityKeys_Insert_Input>;
  on_conflict: InputMaybe<AuthUserSecurityKeys_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsertUserArgs = {
  object: Users_Insert_Input;
  on_conflict: InputMaybe<Users_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsertUsersArgs = {
  objects: Array<Users_Insert_Input>;
  on_conflict: InputMaybe<Users_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_CheckoutArgs = {
  objects: Array<Checkout_Insert_Input>;
  on_conflict: InputMaybe<Checkout_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Checkout_OneArgs = {
  object: Checkout_Insert_Input;
  on_conflict: InputMaybe<Checkout_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_CollectionArgs = {
  objects: Array<Collection_Insert_Input>;
  on_conflict: InputMaybe<Collection_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Collection_OneArgs = {
  object: Collection_Insert_Input;
  on_conflict: InputMaybe<Collection_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_CustomerArgs = {
  objects: Array<Customer_Insert_Input>;
  on_conflict: InputMaybe<Customer_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Customer_OneArgs = {
  object: Customer_Insert_Input;
  on_conflict: InputMaybe<Customer_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_DisputeArgs = {
  objects: Array<Dispute_Insert_Input>;
  on_conflict: InputMaybe<Dispute_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_DisputeAttachmentArgs = {
  objects: Array<DisputeAttachment_Insert_Input>;
  on_conflict: InputMaybe<DisputeAttachment_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_DisputeAttachment_OneArgs = {
  object: DisputeAttachment_Insert_Input;
  on_conflict: InputMaybe<DisputeAttachment_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Dispute_OneArgs = {
  object: Dispute_Insert_Input;
  on_conflict: InputMaybe<Dispute_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_EventArgs = {
  objects: Array<Event_Insert_Input>;
  on_conflict: InputMaybe<Event_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Event_OneArgs = {
  object: Event_Insert_Input;
  on_conflict: InputMaybe<Event_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_FacetFilterArgs = {
  objects: Array<FacetFilter_Insert_Input>;
  on_conflict: InputMaybe<FacetFilter_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_FacetFilter_OneArgs = {
  object: FacetFilter_Insert_Input;
  on_conflict: InputMaybe<FacetFilter_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_FavoriteProductsArgs = {
  objects: Array<FavoriteProducts_Insert_Input>;
  on_conflict: InputMaybe<FavoriteProducts_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_FavoriteProducts_OneArgs = {
  object: FavoriteProducts_Insert_Input;
  on_conflict: InputMaybe<FavoriteProducts_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_FulfillmentArgs = {
  objects: Array<Fulfillment_Insert_Input>;
  on_conflict: InputMaybe<Fulfillment_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_FulfillmentItemArgs = {
  objects: Array<FulfillmentItem_Insert_Input>;
  on_conflict: InputMaybe<FulfillmentItem_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_FulfillmentItem_OneArgs = {
  object: FulfillmentItem_Insert_Input;
  on_conflict: InputMaybe<FulfillmentItem_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_FulfillmentOrderArgs = {
  objects: Array<FulfillmentOrder_Insert_Input>;
  on_conflict: InputMaybe<FulfillmentOrder_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_FulfillmentOrder_OneArgs = {
  object: FulfillmentOrder_Insert_Input;
  on_conflict: InputMaybe<FulfillmentOrder_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Fulfillment_OneArgs = {
  object: Fulfillment_Insert_Input;
  on_conflict: InputMaybe<Fulfillment_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_NegociationAgreementArgs = {
  objects: Array<NegociationAgreement_Insert_Input>;
  on_conflict: InputMaybe<NegociationAgreement_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_NegociationAgreement_OneArgs = {
  object: NegociationAgreement_Insert_Input;
  on_conflict: InputMaybe<NegociationAgreement_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_NumericFilterArgs = {
  objects: Array<NumericFilter_Insert_Input>;
  on_conflict: InputMaybe<NumericFilter_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_NumericFilter_OneArgs = {
  object: NumericFilter_Insert_Input;
  on_conflict: InputMaybe<NumericFilter_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_OrderArgs = {
  objects: Array<Order_Insert_Input>;
  on_conflict: InputMaybe<Order_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_OrderLinesArgs = {
  objects: Array<OrderLines_Insert_Input>;
  on_conflict: InputMaybe<OrderLines_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_OrderLines_OneArgs = {
  object: OrderLines_Insert_Input;
  on_conflict: InputMaybe<OrderLines_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Order_OneArgs = {
  object: Order_Insert_Input;
  on_conflict: InputMaybe<Order_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_PaymentArgs = {
  objects: Array<Payment_Insert_Input>;
  on_conflict: InputMaybe<Payment_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_PaymentAccountsArgs = {
  objects: Array<PaymentAccounts_Insert_Input>;
  on_conflict: InputMaybe<PaymentAccounts_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_PaymentAccounts_OneArgs = {
  object: PaymentAccounts_Insert_Input;
  on_conflict: InputMaybe<PaymentAccounts_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Payment_OneArgs = {
  object: Payment_Insert_Input;
  on_conflict: InputMaybe<Payment_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_PayoutArgs = {
  objects: Array<Payout_Insert_Input>;
  on_conflict: InputMaybe<Payout_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Payout_OneArgs = {
  object: Payout_Insert_Input;
  on_conflict: InputMaybe<Payout_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_PriceOfferArgs = {
  objects: Array<PriceOffer_Insert_Input>;
  on_conflict: InputMaybe<PriceOffer_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_PriceOffer_OneArgs = {
  object: PriceOffer_Insert_Input;
  on_conflict: InputMaybe<PriceOffer_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_ProductArgs = {
  objects: Array<Product_Insert_Input>;
  on_conflict: InputMaybe<Product_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_ProductVariantArgs = {
  objects: Array<ProductVariant_Insert_Input>;
  on_conflict: InputMaybe<ProductVariant_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_ProductVariant_OneArgs = {
  object: ProductVariant_Insert_Input;
  on_conflict: InputMaybe<ProductVariant_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Product_OneArgs = {
  object: Product_Insert_Input;
  on_conflict: InputMaybe<Product_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_ReturnArgs = {
  objects: Array<Return_Insert_Input>;
  on_conflict: InputMaybe<Return_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_ReturnItemArgs = {
  objects: Array<ReturnItem_Insert_Input>;
  on_conflict: InputMaybe<ReturnItem_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_ReturnItem_OneArgs = {
  object: ReturnItem_Insert_Input;
  on_conflict: InputMaybe<ReturnItem_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Return_OneArgs = {
  object: Return_Insert_Input;
  on_conflict: InputMaybe<Return_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_ReviewArgs = {
  objects: Array<Review_Insert_Input>;
  on_conflict: InputMaybe<Review_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Review_OneArgs = {
  object: Review_Insert_Input;
  on_conflict: InputMaybe<Review_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_SavedSearchArgs = {
  objects: Array<SavedSearch_Insert_Input>;
  on_conflict: InputMaybe<SavedSearch_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_SavedSearch_OneArgs = {
  object: SavedSearch_Insert_Input;
  on_conflict: InputMaybe<SavedSearch_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_SearchAlertArgs = {
  objects: Array<SearchAlert_Insert_Input>;
  on_conflict: InputMaybe<SearchAlert_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_SearchAlert_OneArgs = {
  object: SearchAlert_Insert_Input;
  on_conflict: InputMaybe<SearchAlert_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_VendorProCategoryMappingArgs = {
  objects: Array<VendorProCategoryMapping_Insert_Input>;
  on_conflict: InputMaybe<VendorProCategoryMapping_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_VendorProCategoryMapping_OneArgs = {
  object: VendorProCategoryMapping_Insert_Input;
  on_conflict: InputMaybe<VendorProCategoryMapping_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_VendorProTagMappingArgs = {
  objects: Array<VendorProTagMapping_Insert_Input>;
  on_conflict: InputMaybe<VendorProTagMapping_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_VendorProTagMapping_OneArgs = {
  object: VendorProTagMapping_Insert_Input;
  on_conflict: InputMaybe<VendorProTagMapping_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_VendorProTagValueMappingArgs = {
  objects: Array<VendorProTagValueMapping_Insert_Input>;
  on_conflict: InputMaybe<VendorProTagValueMapping_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_VendorProTagValueMapping_OneArgs = {
  object: VendorProTagValueMapping_Insert_Input;
  on_conflict: InputMaybe<VendorProTagValueMapping_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_VendorReviewArgs = {
  objects: Array<VendorReview_Insert_Input>;
  on_conflict: InputMaybe<VendorReview_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_VendorReview_OneArgs = {
  object: VendorReview_Insert_Input;
  on_conflict: InputMaybe<VendorReview_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Auth_RolesArgs = {
  objects: Array<Auth_Roles_Insert_Input>;
  on_conflict: InputMaybe<Auth_Roles_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Auth_Roles_OneArgs = {
  object: Auth_Roles_Insert_Input;
  on_conflict: InputMaybe<Auth_Roles_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Auth_User_ProvidersArgs = {
  objects: Array<Auth_User_Providers_Insert_Input>;
  on_conflict: InputMaybe<Auth_User_Providers_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Auth_User_Providers_OneArgs = {
  object: Auth_User_Providers_Insert_Input;
  on_conflict: InputMaybe<Auth_User_Providers_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Dbt_Store_Base_ProductArgs = {
  objects: Array<Dbt_Store_Base_Product_Insert_Input>;
  on_conflict: InputMaybe<Dbt_Store_Base_Product_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Dbt_Store_Base_Product_OneArgs = {
  object: Dbt_Store_Base_Product_Insert_Input;
  on_conflict: InputMaybe<Dbt_Store_Base_Product_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Dbt_Store_Base_Product_VariantArgs = {
  objects: Array<Dbt_Store_Base_Product_Variant_Insert_Input>;
  on_conflict: InputMaybe<Dbt_Store_Base_Product_Variant_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Dbt_Store_Base_Product_Variant_OneArgs = {
  object: Dbt_Store_Base_Product_Variant_Insert_Input;
  on_conflict: InputMaybe<Dbt_Store_Base_Product_Variant_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Dbt_Store_DiscountArgs = {
  objects: Array<Dbt_Store_Discount_Insert_Input>;
  on_conflict: InputMaybe<Dbt_Store_Discount_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Dbt_Store_Discount_CollectionArgs = {
  objects: Array<Dbt_Store_Discount_Collection_Insert_Input>;
  on_conflict: InputMaybe<Dbt_Store_Discount_Collection_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Dbt_Store_Discount_Collection_OneArgs = {
  object: Dbt_Store_Discount_Collection_Insert_Input;
  on_conflict: InputMaybe<Dbt_Store_Discount_Collection_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Dbt_Store_Discount_OneArgs = {
  object: Dbt_Store_Discount_Insert_Input;
  on_conflict: InputMaybe<Dbt_Store_Discount_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Dbt_Store_Exposed_ProductArgs = {
  objects: Array<Dbt_Store_Exposed_Product_Insert_Input>;
  on_conflict: InputMaybe<Dbt_Store_Exposed_Product_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Dbt_Store_Exposed_Product_ImageArgs = {
  objects: Array<Dbt_Store_Exposed_Product_Image_Insert_Input>;
  on_conflict: InputMaybe<Dbt_Store_Exposed_Product_Image_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Dbt_Store_Exposed_Product_Image_OneArgs = {
  object: Dbt_Store_Exposed_Product_Image_Insert_Input;
  on_conflict: InputMaybe<Dbt_Store_Exposed_Product_Image_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Dbt_Store_Exposed_Product_OneArgs = {
  object: Dbt_Store_Exposed_Product_Insert_Input;
  on_conflict: InputMaybe<Dbt_Store_Exposed_Product_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Dbt_Store_Exposed_Product_TagArgs = {
  objects: Array<Dbt_Store_Exposed_Product_Tag_Insert_Input>;
  on_conflict: InputMaybe<Dbt_Store_Exposed_Product_Tag_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Dbt_Store_Exposed_Product_Tag_OneArgs = {
  object: Dbt_Store_Exposed_Product_Tag_Insert_Input;
  on_conflict: InputMaybe<Dbt_Store_Exposed_Product_Tag_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Dbt_Store_Exposed_Product_VariantArgs = {
  objects: Array<Dbt_Store_Exposed_Product_Variant_Insert_Input>;
  on_conflict: InputMaybe<Dbt_Store_Exposed_Product_Variant_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Dbt_Store_Exposed_Product_Variant_OneArgs = {
  object: Dbt_Store_Exposed_Product_Variant_Insert_Input;
  on_conflict: InputMaybe<Dbt_Store_Exposed_Product_Variant_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Dbt_Store_Product_CollectionArgs = {
  objects: Array<Dbt_Store_Product_Collection_Insert_Input>;
  on_conflict: InputMaybe<Dbt_Store_Product_Collection_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Dbt_Store_Product_Collection_OneArgs = {
  object: Dbt_Store_Product_Collection_Insert_Input;
  on_conflict: InputMaybe<Dbt_Store_Product_Collection_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Dbt_Store_Product_For_AnalyticsArgs = {
  objects: Array<Dbt_Store_Product_For_Analytics_Insert_Input>;
  on_conflict: InputMaybe<Dbt_Store_Product_For_Analytics_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Dbt_Store_Product_For_Analytics_OneArgs = {
  object: Dbt_Store_Product_For_Analytics_Insert_Input;
  on_conflict: InputMaybe<Dbt_Store_Product_For_Analytics_On_Conflict>;
};

/** mutation root */
export type Mutation_RootUpdateAuthProviderArgs = {
  _set: InputMaybe<AuthProviders_Set_Input>;
  pk_columns: AuthProviders_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdateAuthProviderRequestArgs = {
  _append: InputMaybe<AuthProviderRequests_Append_Input>;
  _delete_at_path: InputMaybe<AuthProviderRequests_Delete_At_Path_Input>;
  _delete_elem: InputMaybe<AuthProviderRequests_Delete_Elem_Input>;
  _delete_key: InputMaybe<AuthProviderRequests_Delete_Key_Input>;
  _prepend: InputMaybe<AuthProviderRequests_Prepend_Input>;
  _set: InputMaybe<AuthProviderRequests_Set_Input>;
  pk_columns: AuthProviderRequests_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdateAuthProviderRequestsArgs = {
  _append: InputMaybe<AuthProviderRequests_Append_Input>;
  _delete_at_path: InputMaybe<AuthProviderRequests_Delete_At_Path_Input>;
  _delete_elem: InputMaybe<AuthProviderRequests_Delete_Elem_Input>;
  _delete_key: InputMaybe<AuthProviderRequests_Delete_Key_Input>;
  _prepend: InputMaybe<AuthProviderRequests_Prepend_Input>;
  _set: InputMaybe<AuthProviderRequests_Set_Input>;
  where: AuthProviderRequests_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdateAuthProvidersArgs = {
  _set: InputMaybe<AuthProviders_Set_Input>;
  where: AuthProviders_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdateAuthRefreshTokenArgs = {
  _set: InputMaybe<AuthRefreshTokens_Set_Input>;
  pk_columns: AuthRefreshTokens_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdateAuthRefreshTokensArgs = {
  _set: InputMaybe<AuthRefreshTokens_Set_Input>;
  where: AuthRefreshTokens_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdateAuthUserRoleArgs = {
  _set: InputMaybe<AuthUserRoles_Set_Input>;
  pk_columns: AuthUserRoles_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdateAuthUserRolesArgs = {
  _set: InputMaybe<AuthUserRoles_Set_Input>;
  where: AuthUserRoles_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdateAuthUserSecurityKeyArgs = {
  _inc: InputMaybe<AuthUserSecurityKeys_Inc_Input>;
  _set: InputMaybe<AuthUserSecurityKeys_Set_Input>;
  pk_columns: AuthUserSecurityKeys_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdateAuthUserSecurityKeysArgs = {
  _inc: InputMaybe<AuthUserSecurityKeys_Inc_Input>;
  _set: InputMaybe<AuthUserSecurityKeys_Set_Input>;
  where: AuthUserSecurityKeys_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdateUserArgs = {
  _append: InputMaybe<Users_Append_Input>;
  _delete_at_path: InputMaybe<Users_Delete_At_Path_Input>;
  _delete_elem: InputMaybe<Users_Delete_Elem_Input>;
  _delete_key: InputMaybe<Users_Delete_Key_Input>;
  _prepend: InputMaybe<Users_Prepend_Input>;
  _set: InputMaybe<Users_Set_Input>;
  pk_columns: Users_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdateUsersArgs = {
  _append: InputMaybe<Users_Append_Input>;
  _delete_at_path: InputMaybe<Users_Delete_At_Path_Input>;
  _delete_elem: InputMaybe<Users_Delete_Elem_Input>;
  _delete_key: InputMaybe<Users_Delete_Key_Input>;
  _prepend: InputMaybe<Users_Prepend_Input>;
  _set: InputMaybe<Users_Set_Input>;
  where: Users_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_CheckoutArgs = {
  _set: InputMaybe<Checkout_Set_Input>;
  where: Checkout_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Checkout_By_PkArgs = {
  _set: InputMaybe<Checkout_Set_Input>;
  pk_columns: Checkout_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Checkout_ManyArgs = {
  updates: Array<Checkout_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_CollectionArgs = {
  _append: InputMaybe<Collection_Append_Input>;
  _delete_at_path: InputMaybe<Collection_Delete_At_Path_Input>;
  _delete_elem: InputMaybe<Collection_Delete_Elem_Input>;
  _delete_key: InputMaybe<Collection_Delete_Key_Input>;
  _prepend: InputMaybe<Collection_Prepend_Input>;
  _set: InputMaybe<Collection_Set_Input>;
  where: Collection_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Collection_By_PkArgs = {
  _append: InputMaybe<Collection_Append_Input>;
  _delete_at_path: InputMaybe<Collection_Delete_At_Path_Input>;
  _delete_elem: InputMaybe<Collection_Delete_Elem_Input>;
  _delete_key: InputMaybe<Collection_Delete_Key_Input>;
  _prepend: InputMaybe<Collection_Prepend_Input>;
  _set: InputMaybe<Collection_Set_Input>;
  pk_columns: Collection_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Collection_ManyArgs = {
  updates: Array<Collection_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_CustomerArgs = {
  _inc: InputMaybe<Customer_Inc_Input>;
  _set: InputMaybe<Customer_Set_Input>;
  where: Customer_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Customer_By_PkArgs = {
  _inc: InputMaybe<Customer_Inc_Input>;
  _set: InputMaybe<Customer_Set_Input>;
  pk_columns: Customer_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Customer_ManyArgs = {
  updates: Array<Customer_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_DisputeArgs = {
  _set: InputMaybe<Dispute_Set_Input>;
  where: Dispute_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_DisputeAttachmentArgs = {
  _set: InputMaybe<DisputeAttachment_Set_Input>;
  where: DisputeAttachment_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_DisputeAttachment_By_PkArgs = {
  _set: InputMaybe<DisputeAttachment_Set_Input>;
  pk_columns: DisputeAttachment_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_DisputeAttachment_ManyArgs = {
  updates: Array<DisputeAttachment_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Dispute_By_PkArgs = {
  _set: InputMaybe<Dispute_Set_Input>;
  pk_columns: Dispute_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Dispute_ManyArgs = {
  updates: Array<Dispute_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_EventArgs = {
  _append: InputMaybe<Event_Append_Input>;
  _delete_at_path: InputMaybe<Event_Delete_At_Path_Input>;
  _delete_elem: InputMaybe<Event_Delete_Elem_Input>;
  _delete_key: InputMaybe<Event_Delete_Key_Input>;
  _prepend: InputMaybe<Event_Prepend_Input>;
  _set: InputMaybe<Event_Set_Input>;
  where: Event_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Event_By_PkArgs = {
  _append: InputMaybe<Event_Append_Input>;
  _delete_at_path: InputMaybe<Event_Delete_At_Path_Input>;
  _delete_elem: InputMaybe<Event_Delete_Elem_Input>;
  _delete_key: InputMaybe<Event_Delete_Key_Input>;
  _prepend: InputMaybe<Event_Prepend_Input>;
  _set: InputMaybe<Event_Set_Input>;
  pk_columns: Event_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Event_ManyArgs = {
  updates: Array<Event_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_FacetFilterArgs = {
  _set: InputMaybe<FacetFilter_Set_Input>;
  where: FacetFilter_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_FacetFilter_By_PkArgs = {
  _set: InputMaybe<FacetFilter_Set_Input>;
  pk_columns: FacetFilter_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_FacetFilter_ManyArgs = {
  updates: Array<FacetFilter_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_FavoriteProductsArgs = {
  _inc: InputMaybe<FavoriteProducts_Inc_Input>;
  _set: InputMaybe<FavoriteProducts_Set_Input>;
  where: FavoriteProducts_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_FavoriteProducts_By_PkArgs = {
  _inc: InputMaybe<FavoriteProducts_Inc_Input>;
  _set: InputMaybe<FavoriteProducts_Set_Input>;
  pk_columns: FavoriteProducts_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_FavoriteProducts_ManyArgs = {
  updates: Array<FavoriteProducts_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_FulfillmentArgs = {
  _inc: InputMaybe<Fulfillment_Inc_Input>;
  _set: InputMaybe<Fulfillment_Set_Input>;
  where: Fulfillment_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_FulfillmentItemArgs = {
  _inc: InputMaybe<FulfillmentItem_Inc_Input>;
  _set: InputMaybe<FulfillmentItem_Set_Input>;
  where: FulfillmentItem_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_FulfillmentItem_By_PkArgs = {
  _inc: InputMaybe<FulfillmentItem_Inc_Input>;
  _set: InputMaybe<FulfillmentItem_Set_Input>;
  pk_columns: FulfillmentItem_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_FulfillmentItem_ManyArgs = {
  updates: Array<FulfillmentItem_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_FulfillmentOrderArgs = {
  _inc: InputMaybe<FulfillmentOrder_Inc_Input>;
  _set: InputMaybe<FulfillmentOrder_Set_Input>;
  where: FulfillmentOrder_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_FulfillmentOrder_By_PkArgs = {
  _inc: InputMaybe<FulfillmentOrder_Inc_Input>;
  _set: InputMaybe<FulfillmentOrder_Set_Input>;
  pk_columns: FulfillmentOrder_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_FulfillmentOrder_ManyArgs = {
  updates: Array<FulfillmentOrder_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Fulfillment_By_PkArgs = {
  _inc: InputMaybe<Fulfillment_Inc_Input>;
  _set: InputMaybe<Fulfillment_Set_Input>;
  pk_columns: Fulfillment_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Fulfillment_ManyArgs = {
  updates: Array<Fulfillment_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_NegociationAgreementArgs = {
  _inc: InputMaybe<NegociationAgreement_Inc_Input>;
  _set: InputMaybe<NegociationAgreement_Set_Input>;
  where: NegociationAgreement_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_NegociationAgreement_By_PkArgs = {
  _inc: InputMaybe<NegociationAgreement_Inc_Input>;
  _set: InputMaybe<NegociationAgreement_Set_Input>;
  pk_columns: NegociationAgreement_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_NegociationAgreement_ManyArgs = {
  updates: Array<NegociationAgreement_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_NumericFilterArgs = {
  _set: InputMaybe<NumericFilter_Set_Input>;
  where: NumericFilter_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_NumericFilter_By_PkArgs = {
  _set: InputMaybe<NumericFilter_Set_Input>;
  pk_columns: NumericFilter_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_NumericFilter_ManyArgs = {
  updates: Array<NumericFilter_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_OrderArgs = {
  _inc: InputMaybe<Order_Inc_Input>;
  _set: InputMaybe<Order_Set_Input>;
  where: Order_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_OrderLinesArgs = {
  _inc: InputMaybe<OrderLines_Inc_Input>;
  _set: InputMaybe<OrderLines_Set_Input>;
  where: OrderLines_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_OrderLines_By_PkArgs = {
  _inc: InputMaybe<OrderLines_Inc_Input>;
  _set: InputMaybe<OrderLines_Set_Input>;
  pk_columns: OrderLines_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_OrderLines_ManyArgs = {
  updates: Array<OrderLines_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Order_By_PkArgs = {
  _inc: InputMaybe<Order_Inc_Input>;
  _set: InputMaybe<Order_Set_Input>;
  pk_columns: Order_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Order_ManyArgs = {
  updates: Array<Order_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_PaymentArgs = {
  _inc: InputMaybe<Payment_Inc_Input>;
  _set: InputMaybe<Payment_Set_Input>;
  where: Payment_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_PaymentAccountsArgs = {
  _set: InputMaybe<PaymentAccounts_Set_Input>;
  where: PaymentAccounts_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_PaymentAccounts_By_PkArgs = {
  _set: InputMaybe<PaymentAccounts_Set_Input>;
  pk_columns: PaymentAccounts_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_PaymentAccounts_ManyArgs = {
  updates: Array<PaymentAccounts_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Payment_By_PkArgs = {
  _inc: InputMaybe<Payment_Inc_Input>;
  _set: InputMaybe<Payment_Set_Input>;
  pk_columns: Payment_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Payment_ManyArgs = {
  updates: Array<Payment_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_PayoutArgs = {
  _inc: InputMaybe<Payout_Inc_Input>;
  _set: InputMaybe<Payout_Set_Input>;
  where: Payout_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Payout_By_PkArgs = {
  _inc: InputMaybe<Payout_Inc_Input>;
  _set: InputMaybe<Payout_Set_Input>;
  pk_columns: Payout_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Payout_ManyArgs = {
  updates: Array<Payout_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_PriceOfferArgs = {
  _inc: InputMaybe<PriceOffer_Inc_Input>;
  _set: InputMaybe<PriceOffer_Set_Input>;
  where: PriceOffer_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_PriceOffer_By_PkArgs = {
  _inc: InputMaybe<PriceOffer_Inc_Input>;
  _set: InputMaybe<PriceOffer_Set_Input>;
  pk_columns: PriceOffer_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_PriceOffer_ManyArgs = {
  updates: Array<PriceOffer_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_ProductArgs = {
  _inc: InputMaybe<Product_Inc_Input>;
  _set: InputMaybe<Product_Set_Input>;
  where: Product_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_ProductVariantArgs = {
  _inc: InputMaybe<ProductVariant_Inc_Input>;
  _set: InputMaybe<ProductVariant_Set_Input>;
  where: ProductVariant_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_ProductVariant_By_PkArgs = {
  _inc: InputMaybe<ProductVariant_Inc_Input>;
  _set: InputMaybe<ProductVariant_Set_Input>;
  pk_columns: ProductVariant_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_ProductVariant_ManyArgs = {
  updates: Array<ProductVariant_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Product_By_PkArgs = {
  _inc: InputMaybe<Product_Inc_Input>;
  _set: InputMaybe<Product_Set_Input>;
  pk_columns: Product_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Product_ManyArgs = {
  updates: Array<Product_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_ReturnArgs = {
  _set: InputMaybe<Return_Set_Input>;
  where: Return_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_ReturnItemArgs = {
  _inc: InputMaybe<ReturnItem_Inc_Input>;
  _set: InputMaybe<ReturnItem_Set_Input>;
  where: ReturnItem_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_ReturnItem_By_PkArgs = {
  _inc: InputMaybe<ReturnItem_Inc_Input>;
  _set: InputMaybe<ReturnItem_Set_Input>;
  pk_columns: ReturnItem_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_ReturnItem_ManyArgs = {
  updates: Array<ReturnItem_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Return_By_PkArgs = {
  _set: InputMaybe<Return_Set_Input>;
  pk_columns: Return_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Return_ManyArgs = {
  updates: Array<Return_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_ReviewArgs = {
  _inc: InputMaybe<Review_Inc_Input>;
  _set: InputMaybe<Review_Set_Input>;
  where: Review_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Review_By_PkArgs = {
  _inc: InputMaybe<Review_Inc_Input>;
  _set: InputMaybe<Review_Set_Input>;
  pk_columns: Review_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Review_ManyArgs = {
  updates: Array<Review_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_SavedSearchArgs = {
  _set: InputMaybe<SavedSearch_Set_Input>;
  where: SavedSearch_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_SavedSearch_By_PkArgs = {
  _set: InputMaybe<SavedSearch_Set_Input>;
  pk_columns: SavedSearch_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_SavedSearch_ManyArgs = {
  updates: Array<SavedSearch_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_SearchAlertArgs = {
  _inc: InputMaybe<SearchAlert_Inc_Input>;
  _set: InputMaybe<SearchAlert_Set_Input>;
  where: SearchAlert_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_SearchAlert_By_PkArgs = {
  _inc: InputMaybe<SearchAlert_Inc_Input>;
  _set: InputMaybe<SearchAlert_Set_Input>;
  pk_columns: SearchAlert_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_SearchAlert_ManyArgs = {
  updates: Array<SearchAlert_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_VendorProCategoryMappingArgs = {
  _append: InputMaybe<VendorProCategoryMapping_Append_Input>;
  _delete_at_path: InputMaybe<VendorProCategoryMapping_Delete_At_Path_Input>;
  _delete_elem: InputMaybe<VendorProCategoryMapping_Delete_Elem_Input>;
  _delete_key: InputMaybe<VendorProCategoryMapping_Delete_Key_Input>;
  _prepend: InputMaybe<VendorProCategoryMapping_Prepend_Input>;
  _set: InputMaybe<VendorProCategoryMapping_Set_Input>;
  where: VendorProCategoryMapping_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_VendorProCategoryMapping_By_PkArgs = {
  _append: InputMaybe<VendorProCategoryMapping_Append_Input>;
  _delete_at_path: InputMaybe<VendorProCategoryMapping_Delete_At_Path_Input>;
  _delete_elem: InputMaybe<VendorProCategoryMapping_Delete_Elem_Input>;
  _delete_key: InputMaybe<VendorProCategoryMapping_Delete_Key_Input>;
  _prepend: InputMaybe<VendorProCategoryMapping_Prepend_Input>;
  _set: InputMaybe<VendorProCategoryMapping_Set_Input>;
  pk_columns: VendorProCategoryMapping_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_VendorProCategoryMapping_ManyArgs = {
  updates: Array<VendorProCategoryMapping_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_VendorProTagMappingArgs = {
  _set: InputMaybe<VendorProTagMapping_Set_Input>;
  where: VendorProTagMapping_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_VendorProTagMapping_By_PkArgs = {
  _set: InputMaybe<VendorProTagMapping_Set_Input>;
  pk_columns: VendorProTagMapping_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_VendorProTagMapping_ManyArgs = {
  updates: Array<VendorProTagMapping_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_VendorProTagValueMappingArgs = {
  _append: InputMaybe<VendorProTagValueMapping_Append_Input>;
  _delete_at_path: InputMaybe<VendorProTagValueMapping_Delete_At_Path_Input>;
  _delete_elem: InputMaybe<VendorProTagValueMapping_Delete_Elem_Input>;
  _delete_key: InputMaybe<VendorProTagValueMapping_Delete_Key_Input>;
  _prepend: InputMaybe<VendorProTagValueMapping_Prepend_Input>;
  _set: InputMaybe<VendorProTagValueMapping_Set_Input>;
  where: VendorProTagValueMapping_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_VendorProTagValueMapping_By_PkArgs = {
  _append: InputMaybe<VendorProTagValueMapping_Append_Input>;
  _delete_at_path: InputMaybe<VendorProTagValueMapping_Delete_At_Path_Input>;
  _delete_elem: InputMaybe<VendorProTagValueMapping_Delete_Elem_Input>;
  _delete_key: InputMaybe<VendorProTagValueMapping_Delete_Key_Input>;
  _prepend: InputMaybe<VendorProTagValueMapping_Prepend_Input>;
  _set: InputMaybe<VendorProTagValueMapping_Set_Input>;
  pk_columns: VendorProTagValueMapping_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_VendorProTagValueMapping_ManyArgs = {
  updates: Array<VendorProTagValueMapping_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_VendorReviewArgs = {
  _set: InputMaybe<VendorReview_Set_Input>;
  where: VendorReview_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_VendorReview_By_PkArgs = {
  _set: InputMaybe<VendorReview_Set_Input>;
  pk_columns: VendorReview_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_VendorReview_ManyArgs = {
  updates: Array<VendorReview_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_AuthProviderRequests_ManyArgs = {
  updates: Array<AuthProviderRequests_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_AuthProviders_ManyArgs = {
  updates: Array<AuthProviders_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_AuthRefreshTokens_ManyArgs = {
  updates: Array<AuthRefreshTokens_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_AuthUserRoles_ManyArgs = {
  updates: Array<AuthUserRoles_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_AuthUserSecurityKeys_ManyArgs = {
  updates: Array<AuthUserSecurityKeys_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Auth_RolesArgs = {
  _set: InputMaybe<Auth_Roles_Set_Input>;
  where: Auth_Roles_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Auth_Roles_By_PkArgs = {
  _set: InputMaybe<Auth_Roles_Set_Input>;
  pk_columns: Auth_Roles_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Auth_Roles_ManyArgs = {
  updates: Array<Auth_Roles_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Auth_User_ProvidersArgs = {
  _set: InputMaybe<Auth_User_Providers_Set_Input>;
  where: Auth_User_Providers_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Auth_User_Providers_By_PkArgs = {
  _set: InputMaybe<Auth_User_Providers_Set_Input>;
  pk_columns: Auth_User_Providers_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Auth_User_Providers_ManyArgs = {
  updates: Array<Auth_User_Providers_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Dbt_Store_Base_ProductArgs = {
  _inc: InputMaybe<Dbt_Store_Base_Product_Inc_Input>;
  _set: InputMaybe<Dbt_Store_Base_Product_Set_Input>;
  where: Dbt_Store_Base_Product_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Dbt_Store_Base_Product_By_PkArgs = {
  _inc: InputMaybe<Dbt_Store_Base_Product_Inc_Input>;
  _set: InputMaybe<Dbt_Store_Base_Product_Set_Input>;
  pk_columns: Dbt_Store_Base_Product_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Dbt_Store_Base_Product_ManyArgs = {
  updates: Array<Dbt_Store_Base_Product_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Dbt_Store_Base_Product_VariantArgs = {
  _inc: InputMaybe<Dbt_Store_Base_Product_Variant_Inc_Input>;
  _set: InputMaybe<Dbt_Store_Base_Product_Variant_Set_Input>;
  where: Dbt_Store_Base_Product_Variant_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Dbt_Store_Base_Product_Variant_By_PkArgs = {
  _inc: InputMaybe<Dbt_Store_Base_Product_Variant_Inc_Input>;
  _set: InputMaybe<Dbt_Store_Base_Product_Variant_Set_Input>;
  pk_columns: Dbt_Store_Base_Product_Variant_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Dbt_Store_Base_Product_Variant_ManyArgs = {
  updates: Array<Dbt_Store_Base_Product_Variant_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Dbt_Store_DiscountArgs = {
  _inc: InputMaybe<Dbt_Store_Discount_Inc_Input>;
  _set: InputMaybe<Dbt_Store_Discount_Set_Input>;
  where: Dbt_Store_Discount_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Dbt_Store_Discount_CollectionArgs = {
  _inc: InputMaybe<Dbt_Store_Discount_Collection_Inc_Input>;
  _set: InputMaybe<Dbt_Store_Discount_Collection_Set_Input>;
  where: Dbt_Store_Discount_Collection_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Dbt_Store_Discount_Collection_By_PkArgs = {
  _inc: InputMaybe<Dbt_Store_Discount_Collection_Inc_Input>;
  _set: InputMaybe<Dbt_Store_Discount_Collection_Set_Input>;
  pk_columns: Dbt_Store_Discount_Collection_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Dbt_Store_Discount_Collection_ManyArgs = {
  updates: Array<Dbt_Store_Discount_Collection_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Dbt_Store_Discount_ManyArgs = {
  updates: Array<Dbt_Store_Discount_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Dbt_Store_Exposed_ProductArgs = {
  _inc: InputMaybe<Dbt_Store_Exposed_Product_Inc_Input>;
  _set: InputMaybe<Dbt_Store_Exposed_Product_Set_Input>;
  where: Dbt_Store_Exposed_Product_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Dbt_Store_Exposed_Product_By_PkArgs = {
  _inc: InputMaybe<Dbt_Store_Exposed_Product_Inc_Input>;
  _set: InputMaybe<Dbt_Store_Exposed_Product_Set_Input>;
  pk_columns: Dbt_Store_Exposed_Product_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Dbt_Store_Exposed_Product_ImageArgs = {
  _inc: InputMaybe<Dbt_Store_Exposed_Product_Image_Inc_Input>;
  _set: InputMaybe<Dbt_Store_Exposed_Product_Image_Set_Input>;
  where: Dbt_Store_Exposed_Product_Image_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Dbt_Store_Exposed_Product_Image_By_PkArgs = {
  _inc: InputMaybe<Dbt_Store_Exposed_Product_Image_Inc_Input>;
  _set: InputMaybe<Dbt_Store_Exposed_Product_Image_Set_Input>;
  pk_columns: Dbt_Store_Exposed_Product_Image_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Dbt_Store_Exposed_Product_Image_ManyArgs = {
  updates: Array<Dbt_Store_Exposed_Product_Image_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Dbt_Store_Exposed_Product_ManyArgs = {
  updates: Array<Dbt_Store_Exposed_Product_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Dbt_Store_Exposed_Product_TagArgs = {
  _set: InputMaybe<Dbt_Store_Exposed_Product_Tag_Set_Input>;
  where: Dbt_Store_Exposed_Product_Tag_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Dbt_Store_Exposed_Product_Tag_ManyArgs = {
  updates: Array<Dbt_Store_Exposed_Product_Tag_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Dbt_Store_Exposed_Product_VariantArgs = {
  _inc: InputMaybe<Dbt_Store_Exposed_Product_Variant_Inc_Input>;
  _set: InputMaybe<Dbt_Store_Exposed_Product_Variant_Set_Input>;
  where: Dbt_Store_Exposed_Product_Variant_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Dbt_Store_Exposed_Product_Variant_By_PkArgs = {
  _inc: InputMaybe<Dbt_Store_Exposed_Product_Variant_Inc_Input>;
  _set: InputMaybe<Dbt_Store_Exposed_Product_Variant_Set_Input>;
  pk_columns: Dbt_Store_Exposed_Product_Variant_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Dbt_Store_Exposed_Product_Variant_ManyArgs = {
  updates: Array<Dbt_Store_Exposed_Product_Variant_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Dbt_Store_Product_CollectionArgs = {
  _set: InputMaybe<Dbt_Store_Product_Collection_Set_Input>;
  where: Dbt_Store_Product_Collection_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Dbt_Store_Product_Collection_By_PkArgs = {
  _set: InputMaybe<Dbt_Store_Product_Collection_Set_Input>;
  pk_columns: Dbt_Store_Product_Collection_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Dbt_Store_Product_Collection_ManyArgs = {
  updates: Array<Dbt_Store_Product_Collection_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Dbt_Store_Product_For_AnalyticsArgs = {
  _inc: InputMaybe<Dbt_Store_Product_For_Analytics_Inc_Input>;
  _set: InputMaybe<Dbt_Store_Product_For_Analytics_Set_Input>;
  where: Dbt_Store_Product_For_Analytics_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Dbt_Store_Product_For_Analytics_By_PkArgs = {
  _inc: InputMaybe<Dbt_Store_Product_For_Analytics_Inc_Input>;
  _set: InputMaybe<Dbt_Store_Product_For_Analytics_Set_Input>;
  pk_columns: Dbt_Store_Product_For_Analytics_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Dbt_Store_Product_For_Analytics_ManyArgs = {
  updates: Array<Dbt_Store_Product_For_Analytics_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Users_ManyArgs = {
  updates: Array<Users_Updates>;
};

/** column ordering options */
export enum Order_By {
  /** in ascending order, nulls last */
  Asc = 'asc',
  /** in ascending order, nulls first */
  AscNullsFirst = 'asc_nulls_first',
  /** in ascending order, nulls last */
  AscNullsLast = 'asc_nulls_last',
  /** in descending order, nulls first */
  Desc = 'desc',
  /** in descending order, nulls first */
  DescNullsFirst = 'desc_nulls_first',
  /** in descending order, nulls last */
  DescNullsLast = 'desc_nulls_last',
}

export type Query_Root = {
  __typename?: 'query_root';
  /** fetch data from the table: "Checkout" */
  Checkout: Array<Checkout>;
  /** fetch aggregated fields from the table: "Checkout" */
  Checkout_aggregate: Checkout_Aggregate;
  /** fetch data from the table: "Checkout" using primary key columns */
  Checkout_by_pk: Maybe<Checkout>;
  /** fetch data from the table: "Collection" */
  Collection: Array<Collection>;
  /** fetch aggregated fields from the table: "Collection" */
  Collection_aggregate: Collection_Aggregate;
  /** fetch data from the table: "Collection" using primary key columns */
  Collection_by_pk: Maybe<Collection>;
  /** fetch data from the table: "Customer" */
  Customer: Array<Customer>;
  /** fetch aggregated fields from the table: "Customer" */
  Customer_aggregate: Customer_Aggregate;
  /** fetch data from the table: "Customer" using primary key columns */
  Customer_by_pk: Maybe<Customer>;
  /** fetch data from the table: "Dispute" */
  Dispute: Array<Dispute>;
  /** fetch data from the table: "DisputeAttachment" */
  DisputeAttachment: Array<DisputeAttachment>;
  /** fetch aggregated fields from the table: "DisputeAttachment" */
  DisputeAttachment_aggregate: DisputeAttachment_Aggregate;
  /** fetch data from the table: "DisputeAttachment" using primary key columns */
  DisputeAttachment_by_pk: Maybe<DisputeAttachment>;
  /** fetch aggregated fields from the table: "Dispute" */
  Dispute_aggregate: Dispute_Aggregate;
  /** fetch data from the table: "Dispute" using primary key columns */
  Dispute_by_pk: Maybe<Dispute>;
  /** fetch data from the table: "Event" */
  Event: Array<Event>;
  /** fetch aggregated fields from the table: "Event" */
  Event_aggregate: Event_Aggregate;
  /** fetch data from the table: "Event" using primary key columns */
  Event_by_pk: Maybe<Event>;
  /** fetch data from the table: "FacetFilter" */
  FacetFilter: Array<FacetFilter>;
  /** fetch aggregated fields from the table: "FacetFilter" */
  FacetFilter_aggregate: FacetFilter_Aggregate;
  /** fetch data from the table: "FacetFilter" using primary key columns */
  FacetFilter_by_pk: Maybe<FacetFilter>;
  /** fetch data from the table: "FavoriteProducts" */
  FavoriteProducts: Array<FavoriteProducts>;
  /** fetch aggregated fields from the table: "FavoriteProducts" */
  FavoriteProducts_aggregate: FavoriteProducts_Aggregate;
  /** fetch data from the table: "FavoriteProducts" using primary key columns */
  FavoriteProducts_by_pk: Maybe<FavoriteProducts>;
  /** fetch data from the table: "Fulfillment" */
  Fulfillment: Array<Fulfillment>;
  /** fetch data from the table: "FulfillmentItem" */
  FulfillmentItem: Array<FulfillmentItem>;
  /** fetch aggregated fields from the table: "FulfillmentItem" */
  FulfillmentItem_aggregate: FulfillmentItem_Aggregate;
  /** fetch data from the table: "FulfillmentItem" using primary key columns */
  FulfillmentItem_by_pk: Maybe<FulfillmentItem>;
  /** fetch data from the table: "FulfillmentOrder" */
  FulfillmentOrder: Array<FulfillmentOrder>;
  /** fetch aggregated fields from the table: "FulfillmentOrder" */
  FulfillmentOrder_aggregate: FulfillmentOrder_Aggregate;
  /** fetch data from the table: "FulfillmentOrder" using primary key columns */
  FulfillmentOrder_by_pk: Maybe<FulfillmentOrder>;
  /** fetch aggregated fields from the table: "Fulfillment" */
  Fulfillment_aggregate: Fulfillment_Aggregate;
  /** fetch data from the table: "Fulfillment" using primary key columns */
  Fulfillment_by_pk: Maybe<Fulfillment>;
  /** fetch data from the table: "NegociationAgreement" */
  NegociationAgreement: Array<NegociationAgreement>;
  /** fetch aggregated fields from the table: "NegociationAgreement" */
  NegociationAgreement_aggregate: NegociationAgreement_Aggregate;
  /** fetch data from the table: "NegociationAgreement" using primary key columns */
  NegociationAgreement_by_pk: Maybe<NegociationAgreement>;
  /** fetch data from the table: "NumericFilter" */
  NumericFilter: Array<NumericFilter>;
  /** fetch aggregated fields from the table: "NumericFilter" */
  NumericFilter_aggregate: NumericFilter_Aggregate;
  /** fetch data from the table: "NumericFilter" using primary key columns */
  NumericFilter_by_pk: Maybe<NumericFilter>;
  /** fetch data from the table: "Order" */
  Order: Array<Order>;
  /** fetch data from the table: "OrderLines" */
  OrderLines: Array<OrderLines>;
  /** fetch aggregated fields from the table: "OrderLines" */
  OrderLines_aggregate: OrderLines_Aggregate;
  /** fetch data from the table: "OrderLines" using primary key columns */
  OrderLines_by_pk: Maybe<OrderLines>;
  /** fetch aggregated fields from the table: "Order" */
  Order_aggregate: Order_Aggregate;
  /** fetch data from the table: "Order" using primary key columns */
  Order_by_pk: Maybe<Order>;
  /** fetch data from the table: "Payment" */
  Payment: Array<Payment>;
  /** fetch data from the table: "PaymentAccounts" */
  PaymentAccounts: Array<PaymentAccounts>;
  /** fetch aggregated fields from the table: "PaymentAccounts" */
  PaymentAccounts_aggregate: PaymentAccounts_Aggregate;
  /** fetch data from the table: "PaymentAccounts" using primary key columns */
  PaymentAccounts_by_pk: Maybe<PaymentAccounts>;
  /** fetch aggregated fields from the table: "Payment" */
  Payment_aggregate: Payment_Aggregate;
  /** fetch data from the table: "Payment" using primary key columns */
  Payment_by_pk: Maybe<Payment>;
  /** fetch data from the table: "Payout" */
  Payout: Array<Payout>;
  /** fetch aggregated fields from the table: "Payout" */
  Payout_aggregate: Payout_Aggregate;
  /** fetch data from the table: "Payout" using primary key columns */
  Payout_by_pk: Maybe<Payout>;
  /** fetch data from the table: "PriceOffer" */
  PriceOffer: Array<PriceOffer>;
  /** fetch aggregated fields from the table: "PriceOffer" */
  PriceOffer_aggregate: PriceOffer_Aggregate;
  /** fetch data from the table: "PriceOffer" using primary key columns */
  PriceOffer_by_pk: Maybe<PriceOffer>;
  /** fetch data from the table: "Product" */
  Product: Array<Product>;
  /** fetch data from the table: "ProductVariant" */
  ProductVariant: Array<ProductVariant>;
  /** fetch aggregated fields from the table: "ProductVariant" */
  ProductVariant_aggregate: ProductVariant_Aggregate;
  /** fetch data from the table: "ProductVariant" using primary key columns */
  ProductVariant_by_pk: Maybe<ProductVariant>;
  /** fetch aggregated fields from the table: "Product" */
  Product_aggregate: Product_Aggregate;
  /** fetch data from the table: "Product" using primary key columns */
  Product_by_pk: Maybe<Product>;
  /** fetch data from the table: "Return" */
  Return: Array<Return>;
  /** fetch data from the table: "ReturnItem" */
  ReturnItem: Array<ReturnItem>;
  /** fetch aggregated fields from the table: "ReturnItem" */
  ReturnItem_aggregate: ReturnItem_Aggregate;
  /** fetch data from the table: "ReturnItem" using primary key columns */
  ReturnItem_by_pk: Maybe<ReturnItem>;
  /** fetch aggregated fields from the table: "Return" */
  Return_aggregate: Return_Aggregate;
  /** fetch data from the table: "Return" using primary key columns */
  Return_by_pk: Maybe<Return>;
  /** fetch data from the table: "Review" */
  Review: Array<Review>;
  /** fetch aggregated fields from the table: "Review" */
  Review_aggregate: Review_Aggregate;
  /** fetch data from the table: "Review" using primary key columns */
  Review_by_pk: Maybe<Review>;
  /** fetch data from the table: "SavedSearch" */
  SavedSearch: Array<SavedSearch>;
  /** fetch aggregated fields from the table: "SavedSearch" */
  SavedSearch_aggregate: SavedSearch_Aggregate;
  /** fetch data from the table: "SavedSearch" using primary key columns */
  SavedSearch_by_pk: Maybe<SavedSearch>;
  /** fetch data from the table: "SearchAlert" */
  SearchAlert: Array<SearchAlert>;
  /** fetch aggregated fields from the table: "SearchAlert" */
  SearchAlert_aggregate: SearchAlert_Aggregate;
  /** fetch data from the table: "SearchAlert" using primary key columns */
  SearchAlert_by_pk: Maybe<SearchAlert>;
  /** fetch data from the table: "VendorProCategoryMapping" */
  VendorProCategoryMapping: Array<VendorProCategoryMapping>;
  /** fetch aggregated fields from the table: "VendorProCategoryMapping" */
  VendorProCategoryMapping_aggregate: VendorProCategoryMapping_Aggregate;
  /** fetch data from the table: "VendorProCategoryMapping" using primary key columns */
  VendorProCategoryMapping_by_pk: Maybe<VendorProCategoryMapping>;
  /** fetch data from the table: "VendorProTagMapping" */
  VendorProTagMapping: Array<VendorProTagMapping>;
  /** fetch aggregated fields from the table: "VendorProTagMapping" */
  VendorProTagMapping_aggregate: VendorProTagMapping_Aggregate;
  /** fetch data from the table: "VendorProTagMapping" using primary key columns */
  VendorProTagMapping_by_pk: Maybe<VendorProTagMapping>;
  /** fetch data from the table: "VendorProTagValueMapping" */
  VendorProTagValueMapping: Array<VendorProTagValueMapping>;
  /** fetch aggregated fields from the table: "VendorProTagValueMapping" */
  VendorProTagValueMapping_aggregate: VendorProTagValueMapping_Aggregate;
  /** fetch data from the table: "VendorProTagValueMapping" using primary key columns */
  VendorProTagValueMapping_by_pk: Maybe<VendorProTagValueMapping>;
  /** An array relationship */
  VendorReview: Array<VendorReview>;
  /** An aggregate relationship */
  VendorReview_aggregate: VendorReview_Aggregate;
  /** fetch data from the table: "VendorReview" using primary key columns */
  VendorReview_by_pk: Maybe<VendorReview>;
  /** fetch data from the table: "auth.providers" using primary key columns */
  authProvider: Maybe<AuthProviders>;
  /** fetch data from the table: "auth.provider_requests" using primary key columns */
  authProviderRequest: Maybe<AuthProviderRequests>;
  /** fetch data from the table: "auth.provider_requests" */
  authProviderRequests: Array<AuthProviderRequests>;
  /** fetch aggregated fields from the table: "auth.provider_requests" */
  authProviderRequestsAggregate: AuthProviderRequests_Aggregate;
  /** fetch data from the table: "auth.providers" */
  authProviders: Array<AuthProviders>;
  /** fetch aggregated fields from the table: "auth.providers" */
  authProvidersAggregate: AuthProviders_Aggregate;
  /** fetch data from the table: "auth.refresh_tokens" using primary key columns */
  authRefreshToken: Maybe<AuthRefreshTokens>;
  /** fetch data from the table: "auth.refresh_tokens" */
  authRefreshTokens: Array<AuthRefreshTokens>;
  /** fetch aggregated fields from the table: "auth.refresh_tokens" */
  authRefreshTokensAggregate: AuthRefreshTokens_Aggregate;
  /** fetch data from the table: "auth.user_roles" using primary key columns */
  authUserRole: Maybe<AuthUserRoles>;
  /** fetch data from the table: "auth.user_roles" */
  authUserRoles: Array<AuthUserRoles>;
  /** fetch aggregated fields from the table: "auth.user_roles" */
  authUserRolesAggregate: AuthUserRoles_Aggregate;
  /** fetch data from the table: "auth.user_security_keys" using primary key columns */
  authUserSecurityKey: Maybe<AuthUserSecurityKeys>;
  /** fetch data from the table: "auth.user_security_keys" */
  authUserSecurityKeys: Array<AuthUserSecurityKeys>;
  /** fetch aggregated fields from the table: "auth.user_security_keys" */
  authUserSecurityKeysAggregate: AuthUserSecurityKeys_Aggregate;
  /** fetch data from the table: "auth.roles" */
  auth_roles: Array<Auth_Roles>;
  /** fetch aggregated fields from the table: "auth.roles" */
  auth_roles_aggregate: Auth_Roles_Aggregate;
  /** fetch data from the table: "auth.roles" using primary key columns */
  auth_roles_by_pk: Maybe<Auth_Roles>;
  /** fetch data from the table: "auth.user_providers" */
  auth_user_providers: Array<Auth_User_Providers>;
  /** fetch aggregated fields from the table: "auth.user_providers" */
  auth_user_providers_aggregate: Auth_User_Providers_Aggregate;
  /** fetch data from the table: "auth.user_providers" using primary key columns */
  auth_user_providers_by_pk: Maybe<Auth_User_Providers>;
  /** fetch data from the table: "dbt.store_base_product" */
  dbt_store_base_product: Array<Dbt_Store_Base_Product>;
  /** fetch aggregated fields from the table: "dbt.store_base_product" */
  dbt_store_base_product_aggregate: Dbt_Store_Base_Product_Aggregate;
  /** fetch data from the table: "dbt.store_base_product" using primary key columns */
  dbt_store_base_product_by_pk: Maybe<Dbt_Store_Base_Product>;
  /** fetch data from the table: "dbt.store_base_product_variant" */
  dbt_store_base_product_variant: Array<Dbt_Store_Base_Product_Variant>;
  /** fetch aggregated fields from the table: "dbt.store_base_product_variant" */
  dbt_store_base_product_variant_aggregate: Dbt_Store_Base_Product_Variant_Aggregate;
  /** fetch data from the table: "dbt.store_base_product_variant" using primary key columns */
  dbt_store_base_product_variant_by_pk: Maybe<Dbt_Store_Base_Product_Variant>;
  /** fetch data from the table: "dbt.store_discount" */
  dbt_store_discount: Array<Dbt_Store_Discount>;
  /** fetch aggregated fields from the table: "dbt.store_discount" */
  dbt_store_discount_aggregate: Dbt_Store_Discount_Aggregate;
  /** fetch data from the table: "dbt.store_discount_collection" */
  dbt_store_discount_collection: Array<Dbt_Store_Discount_Collection>;
  /** fetch aggregated fields from the table: "dbt.store_discount_collection" */
  dbt_store_discount_collection_aggregate: Dbt_Store_Discount_Collection_Aggregate;
  /** fetch data from the table: "dbt.store_discount_collection" using primary key columns */
  dbt_store_discount_collection_by_pk: Maybe<Dbt_Store_Discount_Collection>;
  /** fetch data from the table: "dbt.store_exposed_product" */
  dbt_store_exposed_product: Array<Dbt_Store_Exposed_Product>;
  /** fetch aggregated fields from the table: "dbt.store_exposed_product" */
  dbt_store_exposed_product_aggregate: Dbt_Store_Exposed_Product_Aggregate;
  /** fetch data from the table: "dbt.store_exposed_product" using primary key columns */
  dbt_store_exposed_product_by_pk: Maybe<Dbt_Store_Exposed_Product>;
  /** fetch data from the table: "dbt.store_exposed_product_image" */
  dbt_store_exposed_product_image: Array<Dbt_Store_Exposed_Product_Image>;
  /** fetch aggregated fields from the table: "dbt.store_exposed_product_image" */
  dbt_store_exposed_product_image_aggregate: Dbt_Store_Exposed_Product_Image_Aggregate;
  /** fetch data from the table: "dbt.store_exposed_product_image" using primary key columns */
  dbt_store_exposed_product_image_by_pk: Maybe<Dbt_Store_Exposed_Product_Image>;
  /** fetch data from the table: "dbt.store_exposed_product_tag" */
  dbt_store_exposed_product_tag: Array<Dbt_Store_Exposed_Product_Tag>;
  /** fetch aggregated fields from the table: "dbt.store_exposed_product_tag" */
  dbt_store_exposed_product_tag_aggregate: Dbt_Store_Exposed_Product_Tag_Aggregate;
  /** fetch data from the table: "dbt.store_exposed_product_variant" */
  dbt_store_exposed_product_variant: Array<Dbt_Store_Exposed_Product_Variant>;
  /** fetch aggregated fields from the table: "dbt.store_exposed_product_variant" */
  dbt_store_exposed_product_variant_aggregate: Dbt_Store_Exposed_Product_Variant_Aggregate;
  /** fetch data from the table: "dbt.store_exposed_product_variant" using primary key columns */
  dbt_store_exposed_product_variant_by_pk: Maybe<Dbt_Store_Exposed_Product_Variant>;
  /** fetch data from the table: "dbt.store_product_collection" */
  dbt_store_product_collection: Array<Dbt_Store_Product_Collection>;
  /** fetch aggregated fields from the table: "dbt.store_product_collection" */
  dbt_store_product_collection_aggregate: Dbt_Store_Product_Collection_Aggregate;
  /** fetch data from the table: "dbt.store_product_collection" using primary key columns */
  dbt_store_product_collection_by_pk: Maybe<Dbt_Store_Product_Collection>;
  /** fetch data from the table: "dbt.store_product_for_analytics" */
  dbt_store_product_for_analytics: Array<Dbt_Store_Product_For_Analytics>;
  /** fetch aggregated fields from the table: "dbt.store_product_for_analytics" */
  dbt_store_product_for_analytics_aggregate: Dbt_Store_Product_For_Analytics_Aggregate;
  /** fetch data from the table: "dbt.store_product_for_analytics" using primary key columns */
  dbt_store_product_for_analytics_by_pk: Maybe<Dbt_Store_Product_For_Analytics>;
  shopify: Maybe<ShopifyQueryRoot>;
  /** fetch data from the table: "auth.users" using primary key columns */
  user: Maybe<Users>;
  /** fetch data from the table: "auth.users" */
  users: Array<Users>;
  /** fetch aggregated fields from the table: "auth.users" */
  usersAggregate: Users_Aggregate;
};

export type Query_RootCheckoutArgs = {
  distinct_on: InputMaybe<Array<Checkout_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Checkout_Order_By>>;
  where: InputMaybe<Checkout_Bool_Exp>;
};

export type Query_RootCheckout_AggregateArgs = {
  distinct_on: InputMaybe<Array<Checkout_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Checkout_Order_By>>;
  where: InputMaybe<Checkout_Bool_Exp>;
};

export type Query_RootCheckout_By_PkArgs = {
  id: Scalars['String'];
};

export type Query_RootCollectionArgs = {
  distinct_on: InputMaybe<Array<Collection_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Collection_Order_By>>;
  where: InputMaybe<Collection_Bool_Exp>;
};

export type Query_RootCollection_AggregateArgs = {
  distinct_on: InputMaybe<Array<Collection_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Collection_Order_By>>;
  where: InputMaybe<Collection_Bool_Exp>;
};

export type Query_RootCollection_By_PkArgs = {
  id: Scalars['String'];
};

export type Query_RootCustomerArgs = {
  distinct_on: InputMaybe<Array<Customer_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Customer_Order_By>>;
  where: InputMaybe<Customer_Bool_Exp>;
};

export type Query_RootCustomer_AggregateArgs = {
  distinct_on: InputMaybe<Array<Customer_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Customer_Order_By>>;
  where: InputMaybe<Customer_Bool_Exp>;
};

export type Query_RootCustomer_By_PkArgs = {
  authUserId: Scalars['uuid'];
};

export type Query_RootDisputeArgs = {
  distinct_on: InputMaybe<Array<Dispute_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dispute_Order_By>>;
  where: InputMaybe<Dispute_Bool_Exp>;
};

export type Query_RootDisputeAttachmentArgs = {
  distinct_on: InputMaybe<Array<DisputeAttachment_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<DisputeAttachment_Order_By>>;
  where: InputMaybe<DisputeAttachment_Bool_Exp>;
};

export type Query_RootDisputeAttachment_AggregateArgs = {
  distinct_on: InputMaybe<Array<DisputeAttachment_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<DisputeAttachment_Order_By>>;
  where: InputMaybe<DisputeAttachment_Bool_Exp>;
};

export type Query_RootDisputeAttachment_By_PkArgs = {
  id: Scalars['String'];
};

export type Query_RootDispute_AggregateArgs = {
  distinct_on: InputMaybe<Array<Dispute_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dispute_Order_By>>;
  where: InputMaybe<Dispute_Bool_Exp>;
};

export type Query_RootDispute_By_PkArgs = {
  id: Scalars['String'];
};

export type Query_RootEventArgs = {
  distinct_on: InputMaybe<Array<Event_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Event_Order_By>>;
  where: InputMaybe<Event_Bool_Exp>;
};

export type Query_RootEvent_AggregateArgs = {
  distinct_on: InputMaybe<Array<Event_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Event_Order_By>>;
  where: InputMaybe<Event_Bool_Exp>;
};

export type Query_RootEvent_By_PkArgs = {
  id: Scalars['String'];
};

export type Query_RootFacetFilterArgs = {
  distinct_on: InputMaybe<Array<FacetFilter_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<FacetFilter_Order_By>>;
  where: InputMaybe<FacetFilter_Bool_Exp>;
};

export type Query_RootFacetFilter_AggregateArgs = {
  distinct_on: InputMaybe<Array<FacetFilter_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<FacetFilter_Order_By>>;
  where: InputMaybe<FacetFilter_Bool_Exp>;
};

export type Query_RootFacetFilter_By_PkArgs = {
  id: Scalars['String'];
};

export type Query_RootFavoriteProductsArgs = {
  distinct_on: InputMaybe<Array<FavoriteProducts_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<FavoriteProducts_Order_By>>;
  where: InputMaybe<FavoriteProducts_Bool_Exp>;
};

export type Query_RootFavoriteProducts_AggregateArgs = {
  distinct_on: InputMaybe<Array<FavoriteProducts_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<FavoriteProducts_Order_By>>;
  where: InputMaybe<FavoriteProducts_Bool_Exp>;
};

export type Query_RootFavoriteProducts_By_PkArgs = {
  id: Scalars['String'];
};

export type Query_RootFulfillmentArgs = {
  distinct_on: InputMaybe<Array<Fulfillment_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Fulfillment_Order_By>>;
  where: InputMaybe<Fulfillment_Bool_Exp>;
};

export type Query_RootFulfillmentItemArgs = {
  distinct_on: InputMaybe<Array<FulfillmentItem_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<FulfillmentItem_Order_By>>;
  where: InputMaybe<FulfillmentItem_Bool_Exp>;
};

export type Query_RootFulfillmentItem_AggregateArgs = {
  distinct_on: InputMaybe<Array<FulfillmentItem_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<FulfillmentItem_Order_By>>;
  where: InputMaybe<FulfillmentItem_Bool_Exp>;
};

export type Query_RootFulfillmentItem_By_PkArgs = {
  id: Scalars['String'];
};

export type Query_RootFulfillmentOrderArgs = {
  distinct_on: InputMaybe<Array<FulfillmentOrder_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<FulfillmentOrder_Order_By>>;
  where: InputMaybe<FulfillmentOrder_Bool_Exp>;
};

export type Query_RootFulfillmentOrder_AggregateArgs = {
  distinct_on: InputMaybe<Array<FulfillmentOrder_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<FulfillmentOrder_Order_By>>;
  where: InputMaybe<FulfillmentOrder_Bool_Exp>;
};

export type Query_RootFulfillmentOrder_By_PkArgs = {
  id: Scalars['String'];
};

export type Query_RootFulfillment_AggregateArgs = {
  distinct_on: InputMaybe<Array<Fulfillment_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Fulfillment_Order_By>>;
  where: InputMaybe<Fulfillment_Bool_Exp>;
};

export type Query_RootFulfillment_By_PkArgs = {
  id: Scalars['String'];
};

export type Query_RootNegociationAgreementArgs = {
  distinct_on: InputMaybe<Array<NegociationAgreement_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<NegociationAgreement_Order_By>>;
  where: InputMaybe<NegociationAgreement_Bool_Exp>;
};

export type Query_RootNegociationAgreement_AggregateArgs = {
  distinct_on: InputMaybe<Array<NegociationAgreement_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<NegociationAgreement_Order_By>>;
  where: InputMaybe<NegociationAgreement_Bool_Exp>;
};

export type Query_RootNegociationAgreement_By_PkArgs = {
  id: Scalars['String'];
};

export type Query_RootNumericFilterArgs = {
  distinct_on: InputMaybe<Array<NumericFilter_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<NumericFilter_Order_By>>;
  where: InputMaybe<NumericFilter_Bool_Exp>;
};

export type Query_RootNumericFilter_AggregateArgs = {
  distinct_on: InputMaybe<Array<NumericFilter_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<NumericFilter_Order_By>>;
  where: InputMaybe<NumericFilter_Bool_Exp>;
};

export type Query_RootNumericFilter_By_PkArgs = {
  id: Scalars['String'];
};

export type Query_RootOrderArgs = {
  distinct_on: InputMaybe<Array<Order_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Order_Order_By>>;
  where: InputMaybe<Order_Bool_Exp>;
};

export type Query_RootOrderLinesArgs = {
  distinct_on: InputMaybe<Array<OrderLines_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<OrderLines_Order_By>>;
  where: InputMaybe<OrderLines_Bool_Exp>;
};

export type Query_RootOrderLines_AggregateArgs = {
  distinct_on: InputMaybe<Array<OrderLines_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<OrderLines_Order_By>>;
  where: InputMaybe<OrderLines_Bool_Exp>;
};

export type Query_RootOrderLines_By_PkArgs = {
  id: Scalars['String'];
};

export type Query_RootOrder_AggregateArgs = {
  distinct_on: InputMaybe<Array<Order_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Order_Order_By>>;
  where: InputMaybe<Order_Bool_Exp>;
};

export type Query_RootOrder_By_PkArgs = {
  id: Scalars['String'];
};

export type Query_RootPaymentArgs = {
  distinct_on: InputMaybe<Array<Payment_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Payment_Order_By>>;
  where: InputMaybe<Payment_Bool_Exp>;
};

export type Query_RootPaymentAccountsArgs = {
  distinct_on: InputMaybe<Array<PaymentAccounts_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<PaymentAccounts_Order_By>>;
  where: InputMaybe<PaymentAccounts_Bool_Exp>;
};

export type Query_RootPaymentAccounts_AggregateArgs = {
  distinct_on: InputMaybe<Array<PaymentAccounts_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<PaymentAccounts_Order_By>>;
  where: InputMaybe<PaymentAccounts_Bool_Exp>;
};

export type Query_RootPaymentAccounts_By_PkArgs = {
  id: Scalars['String'];
};

export type Query_RootPayment_AggregateArgs = {
  distinct_on: InputMaybe<Array<Payment_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Payment_Order_By>>;
  where: InputMaybe<Payment_Bool_Exp>;
};

export type Query_RootPayment_By_PkArgs = {
  id: Scalars['String'];
};

export type Query_RootPayoutArgs = {
  distinct_on: InputMaybe<Array<Payout_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Payout_Order_By>>;
  where: InputMaybe<Payout_Bool_Exp>;
};

export type Query_RootPayout_AggregateArgs = {
  distinct_on: InputMaybe<Array<Payout_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Payout_Order_By>>;
  where: InputMaybe<Payout_Bool_Exp>;
};

export type Query_RootPayout_By_PkArgs = {
  id: Scalars['String'];
};

export type Query_RootPriceOfferArgs = {
  distinct_on: InputMaybe<Array<PriceOffer_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<PriceOffer_Order_By>>;
  where: InputMaybe<PriceOffer_Bool_Exp>;
};

export type Query_RootPriceOffer_AggregateArgs = {
  distinct_on: InputMaybe<Array<PriceOffer_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<PriceOffer_Order_By>>;
  where: InputMaybe<PriceOffer_Bool_Exp>;
};

export type Query_RootPriceOffer_By_PkArgs = {
  id: Scalars['String'];
};

export type Query_RootProductArgs = {
  distinct_on: InputMaybe<Array<Product_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Product_Order_By>>;
  where: InputMaybe<Product_Bool_Exp>;
};

export type Query_RootProductVariantArgs = {
  distinct_on: InputMaybe<Array<ProductVariant_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<ProductVariant_Order_By>>;
  where: InputMaybe<ProductVariant_Bool_Exp>;
};

export type Query_RootProductVariant_AggregateArgs = {
  distinct_on: InputMaybe<Array<ProductVariant_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<ProductVariant_Order_By>>;
  where: InputMaybe<ProductVariant_Bool_Exp>;
};

export type Query_RootProductVariant_By_PkArgs = {
  id: Scalars['String'];
};

export type Query_RootProduct_AggregateArgs = {
  distinct_on: InputMaybe<Array<Product_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Product_Order_By>>;
  where: InputMaybe<Product_Bool_Exp>;
};

export type Query_RootProduct_By_PkArgs = {
  id: Scalars['String'];
};

export type Query_RootReturnArgs = {
  distinct_on: InputMaybe<Array<Return_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Return_Order_By>>;
  where: InputMaybe<Return_Bool_Exp>;
};

export type Query_RootReturnItemArgs = {
  distinct_on: InputMaybe<Array<ReturnItem_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<ReturnItem_Order_By>>;
  where: InputMaybe<ReturnItem_Bool_Exp>;
};

export type Query_RootReturnItem_AggregateArgs = {
  distinct_on: InputMaybe<Array<ReturnItem_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<ReturnItem_Order_By>>;
  where: InputMaybe<ReturnItem_Bool_Exp>;
};

export type Query_RootReturnItem_By_PkArgs = {
  id: Scalars['String'];
};

export type Query_RootReturn_AggregateArgs = {
  distinct_on: InputMaybe<Array<Return_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Return_Order_By>>;
  where: InputMaybe<Return_Bool_Exp>;
};

export type Query_RootReturn_By_PkArgs = {
  id: Scalars['String'];
};

export type Query_RootReviewArgs = {
  distinct_on: InputMaybe<Array<Review_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Review_Order_By>>;
  where: InputMaybe<Review_Bool_Exp>;
};

export type Query_RootReview_AggregateArgs = {
  distinct_on: InputMaybe<Array<Review_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Review_Order_By>>;
  where: InputMaybe<Review_Bool_Exp>;
};

export type Query_RootReview_By_PkArgs = {
  id: Scalars['String'];
};

export type Query_RootSavedSearchArgs = {
  distinct_on: InputMaybe<Array<SavedSearch_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<SavedSearch_Order_By>>;
  where: InputMaybe<SavedSearch_Bool_Exp>;
};

export type Query_RootSavedSearch_AggregateArgs = {
  distinct_on: InputMaybe<Array<SavedSearch_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<SavedSearch_Order_By>>;
  where: InputMaybe<SavedSearch_Bool_Exp>;
};

export type Query_RootSavedSearch_By_PkArgs = {
  id: Scalars['String'];
};

export type Query_RootSearchAlertArgs = {
  distinct_on: InputMaybe<Array<SearchAlert_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<SearchAlert_Order_By>>;
  where: InputMaybe<SearchAlert_Bool_Exp>;
};

export type Query_RootSearchAlert_AggregateArgs = {
  distinct_on: InputMaybe<Array<SearchAlert_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<SearchAlert_Order_By>>;
  where: InputMaybe<SearchAlert_Bool_Exp>;
};

export type Query_RootSearchAlert_By_PkArgs = {
  id: Scalars['String'];
};

export type Query_RootVendorProCategoryMappingArgs = {
  distinct_on: InputMaybe<Array<VendorProCategoryMapping_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<VendorProCategoryMapping_Order_By>>;
  where: InputMaybe<VendorProCategoryMapping_Bool_Exp>;
};

export type Query_RootVendorProCategoryMapping_AggregateArgs = {
  distinct_on: InputMaybe<Array<VendorProCategoryMapping_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<VendorProCategoryMapping_Order_By>>;
  where: InputMaybe<VendorProCategoryMapping_Bool_Exp>;
};

export type Query_RootVendorProCategoryMapping_By_PkArgs = {
  id: Scalars['String'];
};

export type Query_RootVendorProTagMappingArgs = {
  distinct_on: InputMaybe<Array<VendorProTagMapping_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<VendorProTagMapping_Order_By>>;
  where: InputMaybe<VendorProTagMapping_Bool_Exp>;
};

export type Query_RootVendorProTagMapping_AggregateArgs = {
  distinct_on: InputMaybe<Array<VendorProTagMapping_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<VendorProTagMapping_Order_By>>;
  where: InputMaybe<VendorProTagMapping_Bool_Exp>;
};

export type Query_RootVendorProTagMapping_By_PkArgs = {
  id: Scalars['String'];
};

export type Query_RootVendorProTagValueMappingArgs = {
  distinct_on: InputMaybe<Array<VendorProTagValueMapping_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<VendorProTagValueMapping_Order_By>>;
  where: InputMaybe<VendorProTagValueMapping_Bool_Exp>;
};

export type Query_RootVendorProTagValueMapping_AggregateArgs = {
  distinct_on: InputMaybe<Array<VendorProTagValueMapping_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<VendorProTagValueMapping_Order_By>>;
  where: InputMaybe<VendorProTagValueMapping_Bool_Exp>;
};

export type Query_RootVendorProTagValueMapping_By_PkArgs = {
  id: Scalars['String'];
};

export type Query_RootVendorReviewArgs = {
  distinct_on: InputMaybe<Array<VendorReview_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<VendorReview_Order_By>>;
  where: InputMaybe<VendorReview_Bool_Exp>;
};

export type Query_RootVendorReview_AggregateArgs = {
  distinct_on: InputMaybe<Array<VendorReview_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<VendorReview_Order_By>>;
  where: InputMaybe<VendorReview_Bool_Exp>;
};

export type Query_RootVendorReview_By_PkArgs = {
  reviewId: Scalars['String'];
};

export type Query_RootAuthProviderArgs = {
  id: Scalars['String'];
};

export type Query_RootAuthProviderRequestArgs = {
  id: Scalars['uuid'];
};

export type Query_RootAuthProviderRequestsArgs = {
  distinct_on: InputMaybe<Array<AuthProviderRequests_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<AuthProviderRequests_Order_By>>;
  where: InputMaybe<AuthProviderRequests_Bool_Exp>;
};

export type Query_RootAuthProviderRequestsAggregateArgs = {
  distinct_on: InputMaybe<Array<AuthProviderRequests_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<AuthProviderRequests_Order_By>>;
  where: InputMaybe<AuthProviderRequests_Bool_Exp>;
};

export type Query_RootAuthProvidersArgs = {
  distinct_on: InputMaybe<Array<AuthProviders_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<AuthProviders_Order_By>>;
  where: InputMaybe<AuthProviders_Bool_Exp>;
};

export type Query_RootAuthProvidersAggregateArgs = {
  distinct_on: InputMaybe<Array<AuthProviders_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<AuthProviders_Order_By>>;
  where: InputMaybe<AuthProviders_Bool_Exp>;
};

export type Query_RootAuthRefreshTokenArgs = {
  refreshToken: Scalars['uuid'];
};

export type Query_RootAuthRefreshTokensArgs = {
  distinct_on: InputMaybe<Array<AuthRefreshTokens_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<AuthRefreshTokens_Order_By>>;
  where: InputMaybe<AuthRefreshTokens_Bool_Exp>;
};

export type Query_RootAuthRefreshTokensAggregateArgs = {
  distinct_on: InputMaybe<Array<AuthRefreshTokens_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<AuthRefreshTokens_Order_By>>;
  where: InputMaybe<AuthRefreshTokens_Bool_Exp>;
};

export type Query_RootAuthUserRoleArgs = {
  id: Scalars['uuid'];
};

export type Query_RootAuthUserRolesArgs = {
  distinct_on: InputMaybe<Array<AuthUserRoles_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<AuthUserRoles_Order_By>>;
  where: InputMaybe<AuthUserRoles_Bool_Exp>;
};

export type Query_RootAuthUserRolesAggregateArgs = {
  distinct_on: InputMaybe<Array<AuthUserRoles_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<AuthUserRoles_Order_By>>;
  where: InputMaybe<AuthUserRoles_Bool_Exp>;
};

export type Query_RootAuthUserSecurityKeyArgs = {
  id: Scalars['uuid'];
};

export type Query_RootAuthUserSecurityKeysArgs = {
  distinct_on: InputMaybe<Array<AuthUserSecurityKeys_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<AuthUserSecurityKeys_Order_By>>;
  where: InputMaybe<AuthUserSecurityKeys_Bool_Exp>;
};

export type Query_RootAuthUserSecurityKeysAggregateArgs = {
  distinct_on: InputMaybe<Array<AuthUserSecurityKeys_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<AuthUserSecurityKeys_Order_By>>;
  where: InputMaybe<AuthUserSecurityKeys_Bool_Exp>;
};

export type Query_RootAuth_RolesArgs = {
  distinct_on: InputMaybe<Array<Auth_Roles_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Auth_Roles_Order_By>>;
  where: InputMaybe<Auth_Roles_Bool_Exp>;
};

export type Query_RootAuth_Roles_AggregateArgs = {
  distinct_on: InputMaybe<Array<Auth_Roles_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Auth_Roles_Order_By>>;
  where: InputMaybe<Auth_Roles_Bool_Exp>;
};

export type Query_RootAuth_Roles_By_PkArgs = {
  role: Scalars['String'];
};

export type Query_RootAuth_User_ProvidersArgs = {
  distinct_on: InputMaybe<Array<Auth_User_Providers_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Auth_User_Providers_Order_By>>;
  where: InputMaybe<Auth_User_Providers_Bool_Exp>;
};

export type Query_RootAuth_User_Providers_AggregateArgs = {
  distinct_on: InputMaybe<Array<Auth_User_Providers_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Auth_User_Providers_Order_By>>;
  where: InputMaybe<Auth_User_Providers_Bool_Exp>;
};

export type Query_RootAuth_User_Providers_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootDbt_Store_Base_ProductArgs = {
  distinct_on: InputMaybe<Array<Dbt_Store_Base_Product_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Base_Product_Order_By>>;
  where: InputMaybe<Dbt_Store_Base_Product_Bool_Exp>;
};

export type Query_RootDbt_Store_Base_Product_AggregateArgs = {
  distinct_on: InputMaybe<Array<Dbt_Store_Base_Product_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Base_Product_Order_By>>;
  where: InputMaybe<Dbt_Store_Base_Product_Bool_Exp>;
};

export type Query_RootDbt_Store_Base_Product_By_PkArgs = {
  id: Scalars['String'];
};

export type Query_RootDbt_Store_Base_Product_VariantArgs = {
  distinct_on: InputMaybe<Array<Dbt_Store_Base_Product_Variant_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Base_Product_Variant_Order_By>>;
  where: InputMaybe<Dbt_Store_Base_Product_Variant_Bool_Exp>;
};

export type Query_RootDbt_Store_Base_Product_Variant_AggregateArgs = {
  distinct_on: InputMaybe<Array<Dbt_Store_Base_Product_Variant_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Base_Product_Variant_Order_By>>;
  where: InputMaybe<Dbt_Store_Base_Product_Variant_Bool_Exp>;
};

export type Query_RootDbt_Store_Base_Product_Variant_By_PkArgs = {
  shopify_id: Scalars['bigint'];
};

export type Query_RootDbt_Store_DiscountArgs = {
  distinct_on: InputMaybe<Array<Dbt_Store_Discount_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Discount_Order_By>>;
  where: InputMaybe<Dbt_Store_Discount_Bool_Exp>;
};

export type Query_RootDbt_Store_Discount_AggregateArgs = {
  distinct_on: InputMaybe<Array<Dbt_Store_Discount_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Discount_Order_By>>;
  where: InputMaybe<Dbt_Store_Discount_Bool_Exp>;
};

export type Query_RootDbt_Store_Discount_CollectionArgs = {
  distinct_on: InputMaybe<Array<Dbt_Store_Discount_Collection_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Discount_Collection_Order_By>>;
  where: InputMaybe<Dbt_Store_Discount_Collection_Bool_Exp>;
};

export type Query_RootDbt_Store_Discount_Collection_AggregateArgs = {
  distinct_on: InputMaybe<Array<Dbt_Store_Discount_Collection_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Discount_Collection_Order_By>>;
  where: InputMaybe<Dbt_Store_Discount_Collection_Bool_Exp>;
};

export type Query_RootDbt_Store_Discount_Collection_By_PkArgs = {
  collection_internal_id: Scalars['String'];
  discount_id: Scalars['bigint'];
};

export type Query_RootDbt_Store_Exposed_ProductArgs = {
  distinct_on: InputMaybe<Array<Dbt_Store_Exposed_Product_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Exposed_Product_Order_By>>;
  where: InputMaybe<Dbt_Store_Exposed_Product_Bool_Exp>;
};

export type Query_RootDbt_Store_Exposed_Product_AggregateArgs = {
  distinct_on: InputMaybe<Array<Dbt_Store_Exposed_Product_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Exposed_Product_Order_By>>;
  where: InputMaybe<Dbt_Store_Exposed_Product_Bool_Exp>;
};

export type Query_RootDbt_Store_Exposed_Product_By_PkArgs = {
  id: Scalars['String'];
};

export type Query_RootDbt_Store_Exposed_Product_ImageArgs = {
  distinct_on: InputMaybe<Array<Dbt_Store_Exposed_Product_Image_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Exposed_Product_Image_Order_By>>;
  where: InputMaybe<Dbt_Store_Exposed_Product_Image_Bool_Exp>;
};

export type Query_RootDbt_Store_Exposed_Product_Image_AggregateArgs = {
  distinct_on: InputMaybe<Array<Dbt_Store_Exposed_Product_Image_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Exposed_Product_Image_Order_By>>;
  where: InputMaybe<Dbt_Store_Exposed_Product_Image_Bool_Exp>;
};

export type Query_RootDbt_Store_Exposed_Product_Image_By_PkArgs = {
  shopify_id: Scalars['bigint'];
};

export type Query_RootDbt_Store_Exposed_Product_TagArgs = {
  distinct_on: InputMaybe<Array<Dbt_Store_Exposed_Product_Tag_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Exposed_Product_Tag_Order_By>>;
  where: InputMaybe<Dbt_Store_Exposed_Product_Tag_Bool_Exp>;
};

export type Query_RootDbt_Store_Exposed_Product_Tag_AggregateArgs = {
  distinct_on: InputMaybe<Array<Dbt_Store_Exposed_Product_Tag_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Exposed_Product_Tag_Order_By>>;
  where: InputMaybe<Dbt_Store_Exposed_Product_Tag_Bool_Exp>;
};

export type Query_RootDbt_Store_Exposed_Product_VariantArgs = {
  distinct_on: InputMaybe<
    Array<Dbt_Store_Exposed_Product_Variant_Select_Column>
  >;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Exposed_Product_Variant_Order_By>>;
  where: InputMaybe<Dbt_Store_Exposed_Product_Variant_Bool_Exp>;
};

export type Query_RootDbt_Store_Exposed_Product_Variant_AggregateArgs = {
  distinct_on: InputMaybe<
    Array<Dbt_Store_Exposed_Product_Variant_Select_Column>
  >;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Exposed_Product_Variant_Order_By>>;
  where: InputMaybe<Dbt_Store_Exposed_Product_Variant_Bool_Exp>;
};

export type Query_RootDbt_Store_Exposed_Product_Variant_By_PkArgs = {
  shopify_id: Scalars['bigint'];
};

export type Query_RootDbt_Store_Product_CollectionArgs = {
  distinct_on: InputMaybe<Array<Dbt_Store_Product_Collection_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Product_Collection_Order_By>>;
  where: InputMaybe<Dbt_Store_Product_Collection_Bool_Exp>;
};

export type Query_RootDbt_Store_Product_Collection_AggregateArgs = {
  distinct_on: InputMaybe<Array<Dbt_Store_Product_Collection_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Product_Collection_Order_By>>;
  where: InputMaybe<Dbt_Store_Product_Collection_Bool_Exp>;
};

export type Query_RootDbt_Store_Product_Collection_By_PkArgs = {
  collection_id: Scalars['String'];
  product_id: Scalars['String'];
};

export type Query_RootDbt_Store_Product_For_AnalyticsArgs = {
  distinct_on: InputMaybe<Array<Dbt_Store_Product_For_Analytics_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Product_For_Analytics_Order_By>>;
  where: InputMaybe<Dbt_Store_Product_For_Analytics_Bool_Exp>;
};

export type Query_RootDbt_Store_Product_For_Analytics_AggregateArgs = {
  distinct_on: InputMaybe<Array<Dbt_Store_Product_For_Analytics_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Product_For_Analytics_Order_By>>;
  where: InputMaybe<Dbt_Store_Product_For_Analytics_Bool_Exp>;
};

export type Query_RootDbt_Store_Product_For_Analytics_By_PkArgs = {
  id: Scalars['String'];
};

export type Query_RootUserArgs = {
  id: Scalars['uuid'];
};

export type Query_RootUsersArgs = {
  distinct_on: InputMaybe<Array<Users_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Users_Order_By>>;
  where: InputMaybe<Users_Bool_Exp>;
};

export type Query_RootUsersAggregateArgs = {
  distinct_on: InputMaybe<Array<Users_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Users_Order_By>>;
  where: InputMaybe<Users_Bool_Exp>;
};

export type ShopifyMutation = {
  __typename?: 'shopifyMutation';
  /** Updates the attributes on a cart. */
  cartAttributesUpdate: Maybe<Shopify_CartAttributesUpdatePayload>;
  /**
   * Updates customer information associated with a cart.
   * Buyer identity is used to determine
   * [international pricing](https://shopify.dev/custom-storefronts/internationalization/international-pricing)
   * and should match the customer's shipping address.
   *
   */
  cartBuyerIdentityUpdate: Maybe<Shopify_CartBuyerIdentityUpdatePayload>;
  /** Creates a new cart. */
  cartCreate: Maybe<Shopify_CartCreatePayload>;
  /** Updates the discount codes applied to the cart. */
  cartDiscountCodesUpdate: Maybe<Shopify_CartDiscountCodesUpdatePayload>;
  /** Adds a merchandise line to the cart. */
  cartLinesAdd: Maybe<Shopify_CartLinesAddPayload>;
  /** Removes one or more merchandise lines from the cart. */
  cartLinesRemove: Maybe<Shopify_CartLinesRemovePayload>;
  /** Updates one or more merchandise lines on a cart. */
  cartLinesUpdate: Maybe<Shopify_CartLinesUpdatePayload>;
  /** Deletes a cart metafield. */
  cartMetafieldDelete: Maybe<Shopify_CartMetafieldDeletePayload>;
  /**
   * Sets cart metafield values. Cart metafield values will be set regardless if they were previously created or not.
   *
   * Allows a maximum of 25 cart metafields to be set at a time.
   *
   */
  cartMetafieldsSet: Maybe<Shopify_CartMetafieldsSetPayload>;
  /** Updates the note on the cart. */
  cartNoteUpdate: Maybe<Shopify_CartNoteUpdatePayload>;
  /** Update the customer's payment method that will be used to checkout. */
  cartPaymentUpdate: Maybe<Shopify_CartPaymentUpdatePayload>;
  /** Update the selected delivery options for a delivery group. */
  cartSelectedDeliveryOptionsUpdate: Maybe<Shopify_CartSelectedDeliveryOptionsUpdatePayload>;
  /** Submit the cart for checkout completion. */
  cartSubmitForCompletion: Maybe<Shopify_CartSubmitForCompletionPayload>;
  /** Updates the attributes of a checkout if `allowPartialAddresses` is `true`. */
  checkoutAttributesUpdateV2: Maybe<Shopify_CheckoutAttributesUpdateV2Payload>;
  /** Completes a checkout without providing payment information. You can use this mutation for free items or items whose purchase price is covered by a gift card. */
  checkoutCompleteFree: Maybe<Shopify_CheckoutCompleteFreePayload>;
  /** Completes a checkout using a credit card token from Shopify's card vault. Before you can complete checkouts using CheckoutCompleteWithCreditCardV2, you need to  [_request payment processing_](https://shopify.dev/apps/channels/getting-started#request-payment-processing). */
  checkoutCompleteWithCreditCardV2: Maybe<Shopify_CheckoutCompleteWithCreditCardV2Payload>;
  /** Completes a checkout with a tokenized payment. */
  checkoutCompleteWithTokenizedPaymentV3: Maybe<Shopify_CheckoutCompleteWithTokenizedPaymentV3Payload>;
  /** Creates a new checkout. */
  checkoutCreate: Maybe<Shopify_CheckoutCreatePayload>;
  /** Associates a customer to the checkout. */
  checkoutCustomerAssociateV2: Maybe<Shopify_CheckoutCustomerAssociateV2Payload>;
  /** Disassociates the current checkout customer from the checkout. */
  checkoutCustomerDisassociateV2: Maybe<Shopify_CheckoutCustomerDisassociateV2Payload>;
  /** Applies a discount to an existing checkout using a discount code. */
  checkoutDiscountCodeApplyV2: Maybe<Shopify_CheckoutDiscountCodeApplyV2Payload>;
  /** Removes the applied discounts from an existing checkout. */
  checkoutDiscountCodeRemove: Maybe<Shopify_CheckoutDiscountCodeRemovePayload>;
  /** Updates the email on an existing checkout. */
  checkoutEmailUpdateV2: Maybe<Shopify_CheckoutEmailUpdateV2Payload>;
  /** Removes an applied gift card from the checkout. */
  checkoutGiftCardRemoveV2: Maybe<Shopify_CheckoutGiftCardRemoveV2Payload>;
  /** Appends gift cards to an existing checkout. */
  checkoutGiftCardsAppend: Maybe<Shopify_CheckoutGiftCardsAppendPayload>;
  /** Adds a list of line items to a checkout. */
  checkoutLineItemsAdd: Maybe<Shopify_CheckoutLineItemsAddPayload>;
  /** Removes line items from an existing checkout. */
  checkoutLineItemsRemove: Maybe<Shopify_CheckoutLineItemsRemovePayload>;
  /** Sets a list of line items to a checkout. */
  checkoutLineItemsReplace: Maybe<Shopify_CheckoutLineItemsReplacePayload>;
  /** Updates line items on a checkout. */
  checkoutLineItemsUpdate: Maybe<Shopify_CheckoutLineItemsUpdatePayload>;
  /** Updates the shipping address of an existing checkout. */
  checkoutShippingAddressUpdateV2: Maybe<Shopify_CheckoutShippingAddressUpdateV2Payload>;
  /** Updates the shipping lines on an existing checkout. */
  checkoutShippingLineUpdate: Maybe<Shopify_CheckoutShippingLineUpdatePayload>;
  /**
   * Creates a customer access token.
   * The customer access token is required to modify the customer object in any way.
   *
   */
  customerAccessTokenCreate: Maybe<Shopify_CustomerAccessTokenCreatePayload>;
  /**
   * Creates a customer access token using a
   * [multipass token](https://shopify.dev/api/multipass) instead of email and
   * password. A customer record is created if the customer doesn't exist. If a customer
   * record already exists but the record is disabled, then the customer record is enabled.
   *
   */
  customerAccessTokenCreateWithMultipass: Maybe<Shopify_CustomerAccessTokenCreateWithMultipassPayload>;
  /** Permanently destroys a customer access token. */
  customerAccessTokenDelete: Maybe<Shopify_CustomerAccessTokenDeletePayload>;
  /**
   * Renews a customer access token.
   *
   * Access token renewal must happen *before* a token expires.
   * If a token has already expired, a new one should be created instead via `customerAccessTokenCreate`.
   *
   */
  customerAccessTokenRenew: Maybe<Shopify_CustomerAccessTokenRenewPayload>;
  /** Activates a customer. */
  customerActivate: Maybe<Shopify_CustomerActivatePayload>;
  /** Activates a customer with the activation url received from `customerCreate`. */
  customerActivateByUrl: Maybe<Shopify_CustomerActivateByUrlPayload>;
  /** Creates a new address for a customer. */
  customerAddressCreate: Maybe<Shopify_CustomerAddressCreatePayload>;
  /** Permanently deletes the address of an existing customer. */
  customerAddressDelete: Maybe<Shopify_CustomerAddressDeletePayload>;
  /** Updates the address of an existing customer. */
  customerAddressUpdate: Maybe<Shopify_CustomerAddressUpdatePayload>;
  /** Creates a new customer. */
  customerCreate: Maybe<Shopify_CustomerCreatePayload>;
  /** Updates the default address of an existing customer. */
  customerDefaultAddressUpdate: Maybe<Shopify_CustomerDefaultAddressUpdatePayload>;
  /**
   * Sends a reset password email to the customer. The reset password
   * email contains a reset password URL and token that you can pass to
   * the [`customerResetByUrl`](https://shopify.dev/api/storefront/latest/mutations/customerResetByUrl) or
   * [`customerReset`](https://shopify.dev/api/storefront/latest/mutations/customerReset) mutation to reset the
   * customer password.
   *
   * This mutation is throttled by IP. With private access,
   * you can provide a [`Shopify-Storefront-Buyer-IP`](https://shopify.dev/api/usage/authentication#optional-ip-header) instead of the request IP.
   * The header is case-sensitive and must be sent as `Shopify-Storefront-Buyer-IP`.
   *
   * Make sure that the value provided to `Shopify-Storefront-Buyer-IP` is trusted. Unthrottled access to this
   * mutation presents a security risk.
   *
   */
  customerRecover: Maybe<Shopify_CustomerRecoverPayload>;
  /**
   * "Resets a customers password with the token received from a reset password email. You can send a reset password email with the [`customerRecover`](https://shopify.dev/api/storefront/latest/mutations/customerRecover) mutation."
   *
   */
  customerReset: Maybe<Shopify_CustomerResetPayload>;
  /**
   * "Resets a customers password with the reset password URL received from a reset password email. You can send a reset password email with the [`customerRecover`](https://shopify.dev/api/storefront/latest/mutations/customerRecover) mutation."
   *
   */
  customerResetByUrl: Maybe<Shopify_CustomerResetByUrlPayload>;
  /** Updates an existing customer. */
  customerUpdate: Maybe<Shopify_CustomerUpdatePayload>;
};

export type ShopifyMutationCartAttributesUpdateArgs = {
  attributes: Array<Shopify_AttributeInput>;
  cartId: Scalars['ID'];
};

export type ShopifyMutationCartBuyerIdentityUpdateArgs = {
  buyerIdentity: Shopify_CartBuyerIdentityInput;
  cartId: Scalars['ID'];
};

export type ShopifyMutationCartCreateArgs = {
  input: InputMaybe<Shopify_CartInput>;
};

export type ShopifyMutationCartDiscountCodesUpdateArgs = {
  cartId: Scalars['ID'];
  discountCodes: InputMaybe<Array<Scalars['String']>>;
};

export type ShopifyMutationCartLinesAddArgs = {
  cartId: Scalars['ID'];
  lines: Array<Shopify_CartLineInput>;
};

export type ShopifyMutationCartLinesRemoveArgs = {
  cartId: Scalars['ID'];
  lineIds: Array<Scalars['ID']>;
};

export type ShopifyMutationCartLinesUpdateArgs = {
  cartId: Scalars['ID'];
  lines: Array<Shopify_CartLineUpdateInput>;
};

export type ShopifyMutationCartMetafieldDeleteArgs = {
  input: Shopify_CartMetafieldDeleteInput;
};

export type ShopifyMutationCartMetafieldsSetArgs = {
  metafields: Array<Shopify_CartMetafieldsSetInput>;
};

export type ShopifyMutationCartNoteUpdateArgs = {
  cartId: Scalars['ID'];
  note: InputMaybe<Scalars['String']>;
};

export type ShopifyMutationCartPaymentUpdateArgs = {
  cartId: Scalars['ID'];
  payment: Shopify_CartPaymentInput;
};

export type ShopifyMutationCartSelectedDeliveryOptionsUpdateArgs = {
  cartId: Scalars['ID'];
  selectedDeliveryOptions: Array<Shopify_CartSelectedDeliveryOptionInput>;
};

export type ShopifyMutationCartSubmitForCompletionArgs = {
  attemptToken: Scalars['String'];
  cartId: Scalars['ID'];
};

export type ShopifyMutationCheckoutAttributesUpdateV2Args = {
  checkoutId: Scalars['ID'];
  input: Shopify_CheckoutAttributesUpdateV2Input;
};

export type ShopifyMutationCheckoutCompleteFreeArgs = {
  checkoutId: Scalars['ID'];
};

export type ShopifyMutationCheckoutCompleteWithCreditCardV2Args = {
  checkoutId: Scalars['ID'];
  payment: Shopify_CreditCardPaymentInputV2;
};

export type ShopifyMutationCheckoutCompleteWithTokenizedPaymentV3Args = {
  checkoutId: Scalars['ID'];
  payment: Shopify_TokenizedPaymentInputV3;
};

export type ShopifyMutationCheckoutCreateArgs = {
  input: Shopify_CheckoutCreateInput;
  queueToken: InputMaybe<Scalars['String']>;
};

export type ShopifyMutationCheckoutCustomerAssociateV2Args = {
  checkoutId: Scalars['ID'];
  customerAccessToken: Scalars['String'];
};

export type ShopifyMutationCheckoutCustomerDisassociateV2Args = {
  checkoutId: Scalars['ID'];
};

export type ShopifyMutationCheckoutDiscountCodeApplyV2Args = {
  checkoutId: Scalars['ID'];
  discountCode: Scalars['String'];
};

export type ShopifyMutationCheckoutDiscountCodeRemoveArgs = {
  checkoutId: Scalars['ID'];
};

export type ShopifyMutationCheckoutEmailUpdateV2Args = {
  checkoutId: Scalars['ID'];
  email: Scalars['String'];
};

export type ShopifyMutationCheckoutGiftCardRemoveV2Args = {
  appliedGiftCardId: Scalars['ID'];
  checkoutId: Scalars['ID'];
};

export type ShopifyMutationCheckoutGiftCardsAppendArgs = {
  checkoutId: Scalars['ID'];
  giftCardCodes: Array<Scalars['String']>;
};

export type ShopifyMutationCheckoutLineItemsAddArgs = {
  checkoutId: Scalars['ID'];
  lineItems: Array<Shopify_CheckoutLineItemInput>;
};

export type ShopifyMutationCheckoutLineItemsRemoveArgs = {
  checkoutId: Scalars['ID'];
  lineItemIds: Array<Scalars['ID']>;
};

export type ShopifyMutationCheckoutLineItemsReplaceArgs = {
  checkoutId: Scalars['ID'];
  lineItems: Array<Shopify_CheckoutLineItemInput>;
};

export type ShopifyMutationCheckoutLineItemsUpdateArgs = {
  checkoutId: Scalars['ID'];
  lineItems: Array<Shopify_CheckoutLineItemUpdateInput>;
};

export type ShopifyMutationCheckoutShippingAddressUpdateV2Args = {
  checkoutId: Scalars['ID'];
  shippingAddress: Shopify_MailingAddressInput;
};

export type ShopifyMutationCheckoutShippingLineUpdateArgs = {
  checkoutId: Scalars['ID'];
  shippingRateHandle: Scalars['String'];
};

export type ShopifyMutationCustomerAccessTokenCreateArgs = {
  input: Shopify_CustomerAccessTokenCreateInput;
};

export type ShopifyMutationCustomerAccessTokenCreateWithMultipassArgs = {
  multipassToken: Scalars['String'];
};

export type ShopifyMutationCustomerAccessTokenDeleteArgs = {
  customerAccessToken: Scalars['String'];
};

export type ShopifyMutationCustomerAccessTokenRenewArgs = {
  customerAccessToken: Scalars['String'];
};

export type ShopifyMutationCustomerActivateArgs = {
  id: Scalars['ID'];
  input: Shopify_CustomerActivateInput;
};

export type ShopifyMutationCustomerActivateByUrlArgs = {
  activationUrl: Scalars['shopify_URL'];
  password: Scalars['String'];
};

export type ShopifyMutationCustomerAddressCreateArgs = {
  address: Shopify_MailingAddressInput;
  customerAccessToken: Scalars['String'];
};

export type ShopifyMutationCustomerAddressDeleteArgs = {
  customerAccessToken: Scalars['String'];
  id: Scalars['ID'];
};

export type ShopifyMutationCustomerAddressUpdateArgs = {
  address: Shopify_MailingAddressInput;
  customerAccessToken: Scalars['String'];
  id: Scalars['ID'];
};

export type ShopifyMutationCustomerCreateArgs = {
  input: Shopify_CustomerCreateInput;
};

export type ShopifyMutationCustomerDefaultAddressUpdateArgs = {
  addressId: Scalars['ID'];
  customerAccessToken: Scalars['String'];
};

export type ShopifyMutationCustomerRecoverArgs = {
  email: Scalars['String'];
};

export type ShopifyMutationCustomerResetArgs = {
  id: Scalars['ID'];
  input: Shopify_CustomerResetInput;
};

export type ShopifyMutationCustomerResetByUrlArgs = {
  password: Scalars['String'];
  resetUrl: Scalars['shopify_URL'];
};

export type ShopifyMutationCustomerUpdateArgs = {
  customer: Shopify_CustomerUpdateInput;
  customerAccessToken: Scalars['String'];
};

export type ShopifyQueryRoot = {
  __typename?: 'shopifyQueryRoot';
  /** Fetch a specific Article by its ID. */
  article: Maybe<Shopify_Article>;
  /** List of the shop's articles. */
  articles: Shopify_ArticleConnection;
  /** Fetch a specific `Blog` by one of its unique attributes. */
  blog: Maybe<Shopify_Blog>;
  /** Find a blog by its handle. */
  blogByHandle: Maybe<Shopify_Blog>;
  /** List of the shop's blogs. */
  blogs: Shopify_BlogConnection;
  /**
   * Retrieve a cart by its ID. For more information, refer to
   * [Manage a cart with the Storefront API](https://shopify.dev/custom-storefronts/cart/manage).
   *
   */
  cart: Maybe<Shopify_Cart>;
  /**
   * A poll for the status of the cart checkout completion and order creation.
   *
   */
  cartCompletionAttempt: Maybe<Shopify_CartCompletionAttemptResult>;
  /** Fetch a specific `Collection` by one of its unique attributes. */
  collection: Maybe<Shopify_Collection>;
  /** Find a collection by its handle. */
  collectionByHandle: Maybe<Shopify_Collection>;
  /** List of the shops collections. */
  collections: Shopify_CollectionConnection;
  /**
   * The customer associated with the given access token. Tokens are obtained by using the
   * [`customerAccessTokenCreate` mutation](https://shopify.dev/docs/api/storefront/latest/mutations/customerAccessTokenCreate).
   *
   */
  customer: Maybe<Shopify_Customer>;
  /** Returns the localized experiences configured for the shop. */
  localization: Shopify_Localization;
  /**
   * List of the shop's locations that support in-store pickup.
   *
   * When sorting by distance, you must specify a location via the `near` argument.
   *
   *
   */
  locations: Shopify_LocationConnection;
  /** Retrieve a [navigation menu](https://help.shopify.com/manual/online-store/menus-and-links) by its handle. */
  menu: Maybe<Shopify_Menu>;
  /** Fetch a specific Metaobject by one of its unique identifiers. */
  metaobject: Maybe<Shopify_Metaobject>;
  /** All active metaobjects for the shop. */
  metaobjects: Shopify_MetaobjectConnection;
  /** Returns a specific node by ID. */
  node: Maybe<Shopify_Node>;
  /** Returns the list of nodes with the given IDs. */
  nodes: Array<Maybe<Shopify_Node>>;
  /** Fetch a specific `Page` by one of its unique attributes. */
  page: Maybe<Shopify_Page>;
  /** Find a page by its handle. */
  pageByHandle: Maybe<Shopify_Page>;
  /** List of the shop's pages. */
  pages: Shopify_PageConnection;
  /** Fetch a specific `Product` by one of its unique attributes. */
  product: Maybe<Shopify_Product>;
  /** Find a product by its handle. */
  productByHandle: Maybe<Shopify_Product>;
  /**
   * Find recommended products related to a given `product_id`.
   * To learn more about how recommendations are generated, see
   * [*Showing product recommendations on product pages*](https://help.shopify.com/themes/development/recommended-products).
   *
   */
  productRecommendations: Maybe<Array<Shopify_Product>>;
  /**
   * Tags added to products.
   * Additional access scope required: unauthenticated_read_product_tags.
   *
   */
  productTags: Shopify_StringConnection;
  /** List of product types for the shop's products that are published to your app. */
  productTypes: Shopify_StringConnection;
  /** List of the shops products. For storefront search, use [`search` query](https://shopify.dev/docs/api/storefront/latest/queries/search). */
  products: Shopify_ProductConnection;
  /** The list of public Storefront API versions, including supported, release candidate and unstable versions. */
  publicApiVersions: Array<Shopify_ApiVersion>;
  /** The shop associated with the storefront access token. */
  shop: Shopify_Shop;
  /** A list of redirects for a shop. */
  urlRedirects: Shopify_UrlRedirectConnection;
};

export type ShopifyQueryRootArticleArgs = {
  id: Scalars['ID'];
};

export type ShopifyQueryRootArticlesArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  query: InputMaybe<Scalars['String']>;
  reverse?: InputMaybe<Scalars['Boolean']>;
  sortKey?: InputMaybe<Shopify_ArticleSortKeys>;
};

export type ShopifyQueryRootBlogArgs = {
  handle: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['ID']>;
};

export type ShopifyQueryRootBlogByHandleArgs = {
  handle: Scalars['String'];
};

export type ShopifyQueryRootBlogsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  query: InputMaybe<Scalars['String']>;
  reverse?: InputMaybe<Scalars['Boolean']>;
  sortKey?: InputMaybe<Shopify_BlogSortKeys>;
};

export type ShopifyQueryRootCartArgs = {
  id: Scalars['ID'];
};

export type ShopifyQueryRootCartCompletionAttemptArgs = {
  attemptId: Scalars['String'];
};

export type ShopifyQueryRootCollectionArgs = {
  handle: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['ID']>;
};

export type ShopifyQueryRootCollectionByHandleArgs = {
  handle: Scalars['String'];
};

export type ShopifyQueryRootCollectionsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  query: InputMaybe<Scalars['String']>;
  reverse?: InputMaybe<Scalars['Boolean']>;
  sortKey?: InputMaybe<Shopify_CollectionSortKeys>;
};

export type ShopifyQueryRootCustomerArgs = {
  customerAccessToken: Scalars['String'];
};

export type ShopifyQueryRootLocationsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  near: InputMaybe<Shopify_GeoCoordinateInput>;
  reverse?: InputMaybe<Scalars['Boolean']>;
  sortKey?: InputMaybe<Shopify_LocationSortKeys>;
};

export type ShopifyQueryRootMenuArgs = {
  handle: Scalars['String'];
};

export type ShopifyQueryRootMetaobjectArgs = {
  handle: InputMaybe<Shopify_MetaobjectHandleInput>;
  id: InputMaybe<Scalars['ID']>;
};

export type ShopifyQueryRootMetaobjectsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  reverse?: InputMaybe<Scalars['Boolean']>;
  sortKey: InputMaybe<Scalars['String']>;
  type: Scalars['String'];
};

export type ShopifyQueryRootNodeArgs = {
  id: Scalars['ID'];
};

export type ShopifyQueryRootNodesArgs = {
  ids: Array<Scalars['ID']>;
};

export type ShopifyQueryRootPageArgs = {
  handle: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['ID']>;
};

export type ShopifyQueryRootPageByHandleArgs = {
  handle: Scalars['String'];
};

export type ShopifyQueryRootPagesArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  query: InputMaybe<Scalars['String']>;
  reverse?: InputMaybe<Scalars['Boolean']>;
  sortKey?: InputMaybe<Shopify_PageSortKeys>;
};

export type ShopifyQueryRootProductArgs = {
  handle: InputMaybe<Scalars['String']>;
  id: InputMaybe<Scalars['ID']>;
};

export type ShopifyQueryRootProductByHandleArgs = {
  handle: Scalars['String'];
};

export type ShopifyQueryRootProductRecommendationsArgs = {
  intent?: InputMaybe<Shopify_ProductRecommendationIntent>;
  productId: Scalars['ID'];
};

export type ShopifyQueryRootProductTagsArgs = {
  first: Scalars['Int'];
};

export type ShopifyQueryRootProductTypesArgs = {
  first: Scalars['Int'];
};

export type ShopifyQueryRootProductsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  query: InputMaybe<Scalars['String']>;
  reverse?: InputMaybe<Scalars['Boolean']>;
  sortKey?: InputMaybe<Shopify_ProductSortKeys>;
};

export type ShopifyQueryRootUrlRedirectsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  query: InputMaybe<Scalars['String']>;
  reverse?: InputMaybe<Scalars['Boolean']>;
};

/**
 * A version of the API, as defined by [Shopify API versioning](https://shopify.dev/api/usage/versioning).
 * Versions are commonly referred to by their handle (for example, `2021-10`).
 *
 */
export type Shopify_ApiVersion = {
  __typename?: 'shopify_ApiVersion';
  /** The human-readable name of the version. */
  displayName: Scalars['String'];
  /** The unique identifier of an ApiVersion. All supported API versions have a date-based (YYYY-MM) or `unstable` handle. */
  handle: Scalars['String'];
  /** Whether the version is actively supported by Shopify. Supported API versions are guaranteed to be stable. Unsupported API versions include unstable, release candidate, and end-of-life versions that are marked as unsupported. For more information, refer to [Versioning](https://shopify.dev/api/usage/versioning). */
  supported: Scalars['Boolean'];
};

/**
 * The input fields for submitting Apple Pay payment method information for checkout.
 *
 */
export type Shopify_ApplePayWalletContentInput = {
  /** The customer's billing address. */
  billingAddress: Shopify_MailingAddressInput;
  /** The data for the Apple Pay wallet. */
  data: Scalars['String'];
  /** The header data for the Apple Pay wallet. */
  header: Shopify_ApplePayWalletHeaderInput;
  /** The last digits of the card used to create the payment. */
  lastDigits: InputMaybe<Scalars['String']>;
  /** The signature for the Apple Pay wallet. */
  signature: Scalars['String'];
  /** The version for the Apple Pay wallet. */
  version: Scalars['String'];
};

/**
 * The input fields for submitting wallet payment method information for checkout.
 *
 */
export type Shopify_ApplePayWalletHeaderInput = {
  /** The application data for the Apple Pay wallet. */
  applicationData: InputMaybe<Scalars['String']>;
  /** The ephemeral public key for the Apple Pay wallet. */
  ephemeralPublicKey: Scalars['String'];
  /** The public key hash for the Apple Pay wallet. */
  publicKeyHash: Scalars['String'];
  /** The transaction ID for the Apple Pay wallet. */
  transactionId: Scalars['String'];
};

/** Details about the gift card used on the checkout. */
export type Shopify_AppliedGiftCard = Shopify_Node & {
  __typename?: 'shopify_AppliedGiftCard';
  /** The amount that was taken from the gift card by applying it. */
  amountUsed: Shopify_MoneyV2;
  /** The amount that was taken from the gift card by applying it. */
  amountUsedV2: Shopify_MoneyV2;
  /** The amount left on the gift card. */
  balance: Shopify_MoneyV2;
  /** The amount left on the gift card. */
  balanceV2: Shopify_MoneyV2;
  /** A globally-unique ID. */
  id: Scalars['ID'];
  /** The last characters of the gift card. */
  lastCharacters: Scalars['String'];
  /** The amount that was applied to the checkout in its currency. */
  presentmentAmountUsed: Shopify_MoneyV2;
};

/** An article in an online store blog. */
export type Shopify_Article = Shopify_HasMetafields &
  Shopify_Node &
  Shopify_OnlineStorePublishable & {
    __typename?: 'shopify_Article';
    /** The article's author. */
    author: Shopify_ArticleAuthor;
    /** The article's author. */
    authorV2: Maybe<Shopify_ArticleAuthor>;
    /** The blog that the article belongs to. */
    blog: Shopify_Blog;
    /** List of comments posted on the article. */
    comments: Shopify_CommentConnection;
    /** Stripped content of the article, single line with HTML tags removed. */
    content: Scalars['String'];
    /** The content of the article, complete with HTML formatting. */
    contentHtml: Scalars['shopify_HTML'];
    /** Stripped excerpt of the article, single line with HTML tags removed. */
    excerpt: Maybe<Scalars['String']>;
    /** The excerpt of the article, complete with HTML formatting. */
    excerptHtml: Maybe<Scalars['shopify_HTML']>;
    /** A human-friendly unique string for the Article automatically generated from its title. */
    handle: Scalars['String'];
    /** A globally-unique ID. */
    id: Scalars['ID'];
    /** The image associated with the article. */
    image: Maybe<Shopify_Image>;
    /** Returns a metafield found by namespace and key. */
    metafield: Maybe<Shopify_Metafield>;
    /** The metafields associated with the resource matching the supplied list of namespaces and keys. */
    metafields: Array<Maybe<Shopify_Metafield>>;
    /** The URL used for viewing the resource on the shop's Online Store. Returns `null` if the resource is currently not published to the Online Store sales channel. */
    onlineStoreUrl: Maybe<Scalars['shopify_URL']>;
    /** The date and time when the article was published. */
    publishedAt: Scalars['shopify_DateTime'];
    /** The articles SEO information. */
    seo: Maybe<Shopify_Seo>;
    /**
     * A categorization that a article can be tagged with.
     *
     */
    tags: Array<Scalars['String']>;
    /** The articles name. */
    title: Scalars['String'];
  };

/** An article in an online store blog. */
export type Shopify_ArticleCommentsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  reverse?: InputMaybe<Scalars['Boolean']>;
};

/** An article in an online store blog. */
export type Shopify_ArticleContentArgs = {
  truncateAt: InputMaybe<Scalars['Int']>;
};

/** An article in an online store blog. */
export type Shopify_ArticleExcerptArgs = {
  truncateAt: InputMaybe<Scalars['Int']>;
};

/** An article in an online store blog. */
export type Shopify_ArticleMetafieldArgs = {
  key: Scalars['String'];
  namespace: Scalars['String'];
};

/** An article in an online store blog. */
export type Shopify_ArticleMetafieldsArgs = {
  identifiers: Array<Shopify_HasMetafieldsIdentifier>;
};

/** The author of an article. */
export type Shopify_ArticleAuthor = {
  __typename?: 'shopify_ArticleAuthor';
  /** The author's bio. */
  bio: Maybe<Scalars['String']>;
  /** The authors email. */
  email: Scalars['String'];
  /** The author's first name. */
  firstName: Scalars['String'];
  /** The author's last name. */
  lastName: Scalars['String'];
  /** The author's full name. */
  name: Scalars['String'];
};

/**
 * An auto-generated type for paginating through multiple Articles.
 *
 */
export type Shopify_ArticleConnection = {
  __typename?: 'shopify_ArticleConnection';
  /** A list of edges. */
  edges: Array<Shopify_ArticleEdge>;
  /** A list of the nodes contained in ArticleEdge. */
  nodes: Array<Shopify_Article>;
  /** Information to aid in pagination. */
  pageInfo: Shopify_PageInfo;
};

/**
 * An auto-generated type which holds one Article and a cursor during pagination.
 *
 */
export type Shopify_ArticleEdge = {
  __typename?: 'shopify_ArticleEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of ArticleEdge. */
  node: Shopify_Article;
};

/** The set of valid sort keys for the Article query. */
export enum Shopify_ArticleSortKeys {
  /** Sort by the `author` value. */
  Author = 'AUTHOR',
  /** Sort by the `blog_title` value. */
  BlogTitle = 'BLOG_TITLE',
  /** Sort by the `id` value. */
  Id = 'ID',
  /** Sort by the `published_at` value. */
  PublishedAt = 'PUBLISHED_AT',
  /**
   * Sort by relevance to the search terms when the `query` parameter is specified on the connection.
   * Don't use this sort key when no search query is specified.
   *
   */
  Relevance = 'RELEVANCE',
  /** Sort by the `title` value. */
  Title = 'TITLE',
  /** Sort by the `updated_at` value. */
  UpdatedAt = 'UPDATED_AT',
}

/** Represents a generic custom attribute. */
export type Shopify_Attribute = {
  __typename?: 'shopify_Attribute';
  /** Key or name of the attribute. */
  key: Scalars['String'];
  /** Value of the attribute. */
  value: Maybe<Scalars['String']>;
};

/** The input fields for an attribute. */
export type Shopify_AttributeInput = {
  /** Key or name of the attribute. */
  key: Scalars['String'];
  /** Value of the attribute. */
  value: Scalars['String'];
};

/**
 * Automatic discount applications capture the intentions of a discount that was automatically applied.
 *
 */
export type Shopify_AutomaticDiscountApplication =
  Shopify_DiscountApplication & {
    __typename?: 'shopify_AutomaticDiscountApplication';
    /** The method by which the discount's value is allocated to its entitled items. */
    allocationMethod: Shopify_DiscountApplicationAllocationMethod;
    /** Which lines of targetType that the discount is allocated over. */
    targetSelection: Shopify_DiscountApplicationTargetSelection;
    /** The type of line that the discount is applicable towards. */
    targetType: Shopify_DiscountApplicationTargetType;
    /** The title of the application. */
    title: Scalars['String'];
    /** The value of the discount application. */
    value: Shopify_PricingValue;
  };

/** A collection of available shipping rates for a checkout. */
export type Shopify_AvailableShippingRates = {
  __typename?: 'shopify_AvailableShippingRates';
  /**
   * Whether or not the shipping rates are ready.
   * The `shippingRates` field is `null` when this value is `false`.
   * This field should be polled until its value becomes `true`.
   *
   */
  ready: Scalars['Boolean'];
  /** The fetched shipping rates. `null` until the `ready` field is `true`. */
  shippingRates: Maybe<Array<Shopify_ShippingRate>>;
};

/** Represents a cart line common fields. */
export type Shopify_BaseCartLine = {
  /** An attribute associated with the cart line. */
  attribute: Maybe<Shopify_Attribute>;
  /** The attributes associated with the cart line. Attributes are represented as key-value pairs. */
  attributes: Array<Shopify_Attribute>;
  /** The cost of the merchandise that the buyer will pay for at checkout. The costs are subject to change and changes will be reflected at checkout. */
  cost: Shopify_CartLineCost;
  /** The discounts that have been applied to the cart line. */
  discountAllocations: Array<Shopify_CartDiscountAllocation>;
  /** The estimated cost of the merchandise that the buyer will pay for at checkout. The estimated costs are subject to change and changes will be reflected at checkout. */
  estimatedCost: Shopify_CartLineEstimatedCost;
  /** A globally-unique ID. */
  id: Scalars['ID'];
  /** The merchandise that the buyer intends to purchase. */
  merchandise: Shopify_Merchandise;
  /** The quantity of the merchandise that the customer intends to purchase. */
  quantity: Scalars['Int'];
  /** The selling plan associated with the cart line and the effect that each selling plan has on variants when they're purchased. */
  sellingPlanAllocation: Maybe<Shopify_SellingPlanAllocation>;
};

/** Represents a cart line common fields. */
export type Shopify_BaseCartLineAttributeArgs = {
  key: Scalars['String'];
};

/**
 * An auto-generated type for paginating through multiple BaseCartLines.
 *
 */
export type Shopify_BaseCartLineConnection = {
  __typename?: 'shopify_BaseCartLineConnection';
  /** A list of edges. */
  edges: Array<Shopify_BaseCartLineEdge>;
  /** A list of the nodes contained in BaseCartLineEdge. */
  nodes: Array<Shopify_BaseCartLine>;
  /** Information to aid in pagination. */
  pageInfo: Shopify_PageInfo;
};

/**
 * An auto-generated type which holds one BaseCartLine and a cursor during pagination.
 *
 */
export type Shopify_BaseCartLineEdge = {
  __typename?: 'shopify_BaseCartLineEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of BaseCartLineEdge. */
  node: Shopify_BaseCartLine;
};

/** An online store blog. */
export type Shopify_Blog = Shopify_HasMetafields &
  Shopify_Node &
  Shopify_OnlineStorePublishable & {
    __typename?: 'shopify_Blog';
    /** Find an article by its handle. */
    articleByHandle: Maybe<Shopify_Article>;
    /** List of the blog's articles. */
    articles: Shopify_ArticleConnection;
    /** The authors who have contributed to the blog. */
    authors: Array<Shopify_ArticleAuthor>;
    /**
     * A human-friendly unique string for the Blog automatically generated from its title.
     *
     */
    handle: Scalars['String'];
    /** A globally-unique ID. */
    id: Scalars['ID'];
    /** Returns a metafield found by namespace and key. */
    metafield: Maybe<Shopify_Metafield>;
    /** The metafields associated with the resource matching the supplied list of namespaces and keys. */
    metafields: Array<Maybe<Shopify_Metafield>>;
    /** The URL used for viewing the resource on the shop's Online Store. Returns `null` if the resource is currently not published to the Online Store sales channel. */
    onlineStoreUrl: Maybe<Scalars['shopify_URL']>;
    /** The blog's SEO information. */
    seo: Maybe<Shopify_Seo>;
    /** The blogss title. */
    title: Scalars['String'];
  };

/** An online store blog. */
export type Shopify_BlogArticleByHandleArgs = {
  handle: Scalars['String'];
};

/** An online store blog. */
export type Shopify_BlogArticlesArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  query: InputMaybe<Scalars['String']>;
  reverse?: InputMaybe<Scalars['Boolean']>;
  sortKey?: InputMaybe<Shopify_ArticleSortKeys>;
};

/** An online store blog. */
export type Shopify_BlogMetafieldArgs = {
  key: Scalars['String'];
  namespace: Scalars['String'];
};

/** An online store blog. */
export type Shopify_BlogMetafieldsArgs = {
  identifiers: Array<Shopify_HasMetafieldsIdentifier>;
};

/**
 * An auto-generated type for paginating through multiple Blogs.
 *
 */
export type Shopify_BlogConnection = {
  __typename?: 'shopify_BlogConnection';
  /** A list of edges. */
  edges: Array<Shopify_BlogEdge>;
  /** A list of the nodes contained in BlogEdge. */
  nodes: Array<Shopify_Blog>;
  /** Information to aid in pagination. */
  pageInfo: Shopify_PageInfo;
};

/**
 * An auto-generated type which holds one Blog and a cursor during pagination.
 *
 */
export type Shopify_BlogEdge = {
  __typename?: 'shopify_BlogEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of BlogEdge. */
  node: Shopify_Blog;
};

/** The set of valid sort keys for the Blog query. */
export enum Shopify_BlogSortKeys {
  /** Sort by the `handle` value. */
  Handle = 'HANDLE',
  /** Sort by the `id` value. */
  Id = 'ID',
  /**
   * Sort by relevance to the search terms when the `query` parameter is specified on the connection.
   * Don't use this sort key when no search query is specified.
   *
   */
  Relevance = 'RELEVANCE',
  /** Sort by the `title` value. */
  Title = 'TITLE',
}

/**
 * The store's [branding configuration](https://help.shopify.com/en/manual/promoting-marketing/managing-brand-assets).
 *
 */
export type Shopify_Brand = {
  __typename?: 'shopify_Brand';
  /** The colors of the store's brand. */
  colors: Shopify_BrandColors;
  /** The store's cover image. */
  coverImage: Maybe<Shopify_MediaImage>;
  /** The store's default logo. */
  logo: Maybe<Shopify_MediaImage>;
  /** The store's short description. */
  shortDescription: Maybe<Scalars['String']>;
  /** The store's slogan. */
  slogan: Maybe<Scalars['String']>;
  /** The store's preferred logo for square UI elements. */
  squareLogo: Maybe<Shopify_MediaImage>;
};

/**
 * A group of related colors for the shop's brand.
 *
 */
export type Shopify_BrandColorGroup = {
  __typename?: 'shopify_BrandColorGroup';
  /** The background color. */
  background: Maybe<Scalars['shopify_Color']>;
  /** The foreground color. */
  foreground: Maybe<Scalars['shopify_Color']>;
};

/**
 * The colors of the shop's brand.
 *
 */
export type Shopify_BrandColors = {
  __typename?: 'shopify_BrandColors';
  /** The shop's primary brand colors. */
  primary: Array<Shopify_BrandColorGroup>;
  /** The shop's secondary brand colors. */
  secondary: Array<Shopify_BrandColorGroup>;
};

/** Card brand, such as Visa or Mastercard, which can be used for payments. */
export enum Shopify_CardBrand {
  /** American Express. */
  AmericanExpress = 'AMERICAN_EXPRESS',
  /** Diners Club. */
  DinersClub = 'DINERS_CLUB',
  /** Discover. */
  Discover = 'DISCOVER',
  /** JCB. */
  Jcb = 'JCB',
  /** Mastercard. */
  Mastercard = 'MASTERCARD',
  /** Visa. */
  Visa = 'VISA',
}

/**
 * A cart represents the merchandise that a buyer intends to purchase,
 * and the estimated cost associated with the cart. Learn how to
 * [interact with a cart](https://shopify.dev/custom-storefronts/internationalization/international-pricing)
 * during a customer's session.
 *
 */
export type Shopify_Cart = Shopify_HasMetafields &
  Shopify_Node & {
    __typename?: 'shopify_Cart';
    /** An attribute associated with the cart. */
    attribute: Maybe<Shopify_Attribute>;
    /** The attributes associated with the cart. Attributes are represented as key-value pairs. */
    attributes: Array<Shopify_Attribute>;
    /** Information about the buyer that's interacting with the cart. */
    buyerIdentity: Shopify_CartBuyerIdentity;
    /** The URL of the checkout for the cart. */
    checkoutUrl: Scalars['shopify_URL'];
    /** The estimated costs that the buyer will pay at checkout. The costs are subject to change and changes will be reflected at checkout. The `cost` field uses the `buyerIdentity` field to determine [international pricing](https://shopify.dev/custom-storefronts/internationalization/international-pricing). */
    cost: Shopify_CartCost;
    /** The date and time when the cart was created. */
    createdAt: Scalars['shopify_DateTime'];
    /**
     * The delivery groups available for the cart, based on the buyer identity default
     * delivery address preference or the default address of the logged-in customer.
     *
     */
    deliveryGroups: Shopify_CartDeliveryGroupConnection;
    /** The discounts that have been applied to the entire cart. */
    discountAllocations: Array<Shopify_CartDiscountAllocation>;
    /** The case-insensitive discount codes that the customer added at checkout. */
    discountCodes: Array<Shopify_CartDiscountCode>;
    /** The estimated costs that the buyer will pay at checkout. The estimated costs are subject to change and changes will be reflected at checkout. The `estimatedCost` field uses the `buyerIdentity` field to determine [international pricing](https://shopify.dev/custom-storefronts/internationalization/international-pricing). */
    estimatedCost: Shopify_CartEstimatedCost;
    /** A globally-unique ID. */
    id: Scalars['ID'];
    /** A list of lines containing information about the items the customer intends to purchase. */
    lines: Shopify_BaseCartLineConnection;
    /** Returns a metafield found by namespace and key. */
    metafield: Maybe<Shopify_Metafield>;
    /** The metafields associated with the resource matching the supplied list of namespaces and keys. */
    metafields: Array<Maybe<Shopify_Metafield>>;
    /** A note that's associated with the cart. For example, the note can be a personalized message to the buyer. */
    note: Maybe<Scalars['String']>;
    /** The total number of items in the cart. */
    totalQuantity: Scalars['Int'];
    /** The date and time when the cart was updated. */
    updatedAt: Scalars['shopify_DateTime'];
  };

/**
 * A cart represents the merchandise that a buyer intends to purchase,
 * and the estimated cost associated with the cart. Learn how to
 * [interact with a cart](https://shopify.dev/custom-storefronts/internationalization/international-pricing)
 * during a customer's session.
 *
 */
export type Shopify_CartAttributeArgs = {
  key: Scalars['String'];
};

/**
 * A cart represents the merchandise that a buyer intends to purchase,
 * and the estimated cost associated with the cart. Learn how to
 * [interact with a cart](https://shopify.dev/custom-storefronts/internationalization/international-pricing)
 * during a customer's session.
 *
 */
export type Shopify_CartDeliveryGroupsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  reverse?: InputMaybe<Scalars['Boolean']>;
};

/**
 * A cart represents the merchandise that a buyer intends to purchase,
 * and the estimated cost associated with the cart. Learn how to
 * [interact with a cart](https://shopify.dev/custom-storefronts/internationalization/international-pricing)
 * during a customer's session.
 *
 */
export type Shopify_CartLinesArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  reverse?: InputMaybe<Scalars['Boolean']>;
};

/**
 * A cart represents the merchandise that a buyer intends to purchase,
 * and the estimated cost associated with the cart. Learn how to
 * [interact with a cart](https://shopify.dev/custom-storefronts/internationalization/international-pricing)
 * during a customer's session.
 *
 */
export type Shopify_CartMetafieldArgs = {
  key: Scalars['String'];
  namespace: Scalars['String'];
};

/**
 * A cart represents the merchandise that a buyer intends to purchase,
 * and the estimated cost associated with the cart. Learn how to
 * [interact with a cart](https://shopify.dev/custom-storefronts/internationalization/international-pricing)
 * during a customer's session.
 *
 */
export type Shopify_CartMetafieldsArgs = {
  identifiers: Array<Shopify_HasMetafieldsIdentifier>;
};

/** Return type for `cartAttributesUpdate` mutation. */
export type Shopify_CartAttributesUpdatePayload = {
  __typename?: 'shopify_CartAttributesUpdatePayload';
  /** The updated cart. */
  cart: Maybe<Shopify_Cart>;
  /** The list of errors that occurred from executing the mutation. */
  userErrors: Array<Shopify_CartUserError>;
};

/** The discounts automatically applied to the cart line based on prerequisites that have been met. */
export type Shopify_CartAutomaticDiscountAllocation =
  Shopify_CartDiscountAllocation & {
    __typename?: 'shopify_CartAutomaticDiscountAllocation';
    /** The discounted amount that has been applied to the cart line. */
    discountedAmount: Shopify_MoneyV2;
    /** The title of the allocated discount. */
    title: Scalars['String'];
  };

/** Represents information about the buyer that is interacting with the cart. */
export type Shopify_CartBuyerIdentity = {
  __typename?: 'shopify_CartBuyerIdentity';
  /** The country where the buyer is located. */
  countryCode: Maybe<Shopify_CountryCode>;
  /** The customer account associated with the cart. */
  customer: Maybe<Shopify_Customer>;
  /**
   * An ordered set of delivery addresses tied to the buyer that is interacting with the cart.
   * The rank of the preferences is determined by the order of the addresses in the array. Preferences
   * can be used to populate relevant fields in the checkout flow.
   *
   */
  deliveryAddressPreferences: Array<Shopify_DeliveryAddress>;
  /** The email address of the buyer that's interacting with the cart. */
  email: Maybe<Scalars['String']>;
  /** The phone number of the buyer that's interacting with the cart. */
  phone: Maybe<Scalars['String']>;
  /**
   * A set of wallet preferences tied to the buyer that is interacting with the cart.
   * Preferences can be used to populate relevant payment fields in the checkout flow.
   *
   */
  walletPreferences: Array<Scalars['String']>;
};

/**
 * Specifies the input fields to update the buyer information associated with a cart.
 * Buyer identity is used to determine
 * [international pricing](https://shopify.dev/custom-storefronts/internationalization/international-pricing)
 * and should match the customer's shipping address.
 *
 */
export type Shopify_CartBuyerIdentityInput = {
  /** The country where the buyer is located. */
  countryCode: InputMaybe<Shopify_CountryCode>;
  /** The access token used to identify the customer associated with the cart. */
  customerAccessToken: InputMaybe<Scalars['String']>;
  /**
   * An ordered set of delivery addresses tied to the buyer that is interacting with the cart.
   * The rank of the preferences is determined by the order of the addresses in the array. Preferences
   * can be used to populate relevant fields in the checkout flow.
   *
   * The input must not contain more than `250` values.
   */
  deliveryAddressPreferences: InputMaybe<Array<Shopify_DeliveryAddressInput>>;
  /** The email address of the buyer that is interacting with the cart. */
  email: InputMaybe<Scalars['String']>;
  /** The phone number of the buyer that is interacting with the cart. */
  phone: InputMaybe<Scalars['String']>;
  /**
   * A set of wallet preferences tied to the buyer that is interacting with the cart.
   * Preferences can be used to populate relevant payment fields in the checkout flow.
   *   Accepted value: `["shop_pay"]`.
   *
   * The input must not contain more than `250` values.
   */
  walletPreferences: InputMaybe<Array<Scalars['String']>>;
};

/** Return type for `cartBuyerIdentityUpdate` mutation. */
export type Shopify_CartBuyerIdentityUpdatePayload = {
  __typename?: 'shopify_CartBuyerIdentityUpdatePayload';
  /** The updated cart. */
  cart: Maybe<Shopify_Cart>;
  /** The list of errors that occurred from executing the mutation. */
  userErrors: Array<Shopify_CartUserError>;
};

/**
 * Represents how credit card details are provided for a direct payment.
 *
 */
export enum Shopify_CartCardSource {
  /**
   * The credit card was provided by a third party and vaulted on their system.
   * Using this value requires a separate permission from Shopify.
   *
   */
  SavedCreditCard = 'SAVED_CREDIT_CARD',
}

/** The discount that has been applied to the cart line using a discount code. */
export type Shopify_CartCodeDiscountAllocation =
  Shopify_CartDiscountAllocation & {
    __typename?: 'shopify_CartCodeDiscountAllocation';
    /** The code used to apply the discount. */
    code: Scalars['String'];
    /** The discounted amount that has been applied to the cart line. */
    discountedAmount: Shopify_MoneyV2;
  };

/** The completion action to checkout a cart. */
export type Shopify_CartCompletionAction = Shopify_CompletePaymentChallenge;

/** The required completion action to checkout a cart. */
export type Shopify_CartCompletionActionRequired = {
  __typename?: 'shopify_CartCompletionActionRequired';
  /** The action required to complete the cart completion attempt. */
  action: Maybe<Shopify_CartCompletionAction>;
  /** The ID of the cart completion attempt. */
  id: Scalars['String'];
};

/** The result of a cart completion attempt. */
export type Shopify_CartCompletionAttemptResult =
  | Shopify_CartCompletionActionRequired
  | Shopify_CartCompletionFailed
  | Shopify_CartCompletionProcessing
  | Shopify_CartCompletionSuccess;

/** A failed completion to checkout a cart. */
export type Shopify_CartCompletionFailed = {
  __typename?: 'shopify_CartCompletionFailed';
  /** The errors that caused the checkout to fail. */
  errors: Array<Shopify_CompletionError>;
  /** The ID of the cart completion attempt. */
  id: Scalars['String'];
};

/** A cart checkout completion that's still processing. */
export type Shopify_CartCompletionProcessing = {
  __typename?: 'shopify_CartCompletionProcessing';
  /** The ID of the cart completion attempt. */
  id: Scalars['String'];
  /** The number of milliseconds to wait before polling again. */
  pollDelay: Scalars['Int'];
};

/** A successful completion to checkout a cart and a created order. */
export type Shopify_CartCompletionSuccess = {
  __typename?: 'shopify_CartCompletionSuccess';
  /** The date and time when the job completed. */
  completedAt: Maybe<Scalars['shopify_DateTime']>;
  /** The ID of the cart completion attempt. */
  id: Scalars['String'];
  /** The ID of the order that's created in Shopify. */
  orderId: Scalars['ID'];
  /** The URL of the order confirmation in Shopify. */
  orderUrl: Scalars['shopify_URL'];
};

/**
 * The costs that the buyer will pay at checkout.
 * The cart cost uses [`CartBuyerIdentity`](https://shopify.dev/api/storefront/reference/cart/cartbuyeridentity) to determine
 * [international pricing](https://shopify.dev/custom-storefronts/internationalization/international-pricing).
 *
 */
export type Shopify_CartCost = {
  __typename?: 'shopify_CartCost';
  /** The estimated amount, before taxes and discounts, for the customer to pay at checkout. The checkout charge amount doesn't include any deferred payments that'll be paid at a later date. If the cart has no deferred payments, then the checkout charge amount is equivalent to `subtotalAmount`. */
  checkoutChargeAmount: Shopify_MoneyV2;
  /** The amount, before taxes and cart-level discounts, for the customer to pay. */
  subtotalAmount: Shopify_MoneyV2;
  /** Whether the subtotal amount is estimated. */
  subtotalAmountEstimated: Scalars['Boolean'];
  /** The total amount for the customer to pay. */
  totalAmount: Shopify_MoneyV2;
  /** Whether the total amount is estimated. */
  totalAmountEstimated: Scalars['Boolean'];
  /** The duty amount for the customer to pay at checkout. */
  totalDutyAmount: Maybe<Shopify_MoneyV2>;
  /** Whether the total duty amount is estimated. */
  totalDutyAmountEstimated: Scalars['Boolean'];
  /** The tax amount for the customer to pay at checkout. */
  totalTaxAmount: Maybe<Shopify_MoneyV2>;
  /** Whether the total tax amount is estimated. */
  totalTaxAmountEstimated: Scalars['Boolean'];
};

/** Return type for `cartCreate` mutation. */
export type Shopify_CartCreatePayload = {
  __typename?: 'shopify_CartCreatePayload';
  /** The new cart. */
  cart: Maybe<Shopify_Cart>;
  /** The list of errors that occurred from executing the mutation. */
  userErrors: Array<Shopify_CartUserError>;
};

/** The discounts automatically applied to the cart line based on prerequisites that have been met. */
export type Shopify_CartCustomDiscountAllocation =
  Shopify_CartDiscountAllocation & {
    __typename?: 'shopify_CartCustomDiscountAllocation';
    /** The discounted amount that has been applied to the cart line. */
    discountedAmount: Shopify_MoneyV2;
    /** The title of the allocated discount. */
    title: Scalars['String'];
  };

/** Information about the options available for one or more line items to be delivered to a specific address. */
export type Shopify_CartDeliveryGroup = {
  __typename?: 'shopify_CartDeliveryGroup';
  /** A list of cart lines for the delivery group. */
  cartLines: Shopify_BaseCartLineConnection;
  /** The destination address for the delivery group. */
  deliveryAddress: Shopify_MailingAddress;
  /** The delivery options available for the delivery group. */
  deliveryOptions: Array<Shopify_CartDeliveryOption>;
  /** The ID for the delivery group. */
  id: Scalars['ID'];
  /** The selected delivery option for the delivery group. */
  selectedDeliveryOption: Maybe<Shopify_CartDeliveryOption>;
};

/** Information about the options available for one or more line items to be delivered to a specific address. */
export type Shopify_CartDeliveryGroupCartLinesArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  reverse?: InputMaybe<Scalars['Boolean']>;
};

/**
 * An auto-generated type for paginating through multiple CartDeliveryGroups.
 *
 */
export type Shopify_CartDeliveryGroupConnection = {
  __typename?: 'shopify_CartDeliveryGroupConnection';
  /** A list of edges. */
  edges: Array<Shopify_CartDeliveryGroupEdge>;
  /** A list of the nodes contained in CartDeliveryGroupEdge. */
  nodes: Array<Shopify_CartDeliveryGroup>;
  /** Information to aid in pagination. */
  pageInfo: Shopify_PageInfo;
};

/**
 * An auto-generated type which holds one CartDeliveryGroup and a cursor during pagination.
 *
 */
export type Shopify_CartDeliveryGroupEdge = {
  __typename?: 'shopify_CartDeliveryGroupEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of CartDeliveryGroupEdge. */
  node: Shopify_CartDeliveryGroup;
};

/** Information about a delivery option. */
export type Shopify_CartDeliveryOption = {
  __typename?: 'shopify_CartDeliveryOption';
  /** The code of the delivery option. */
  code: Maybe<Scalars['String']>;
  /** The method for the delivery option. */
  deliveryMethodType: Shopify_DeliveryMethodType;
  /** The description of the delivery option. */
  description: Maybe<Scalars['String']>;
  /** The estimated cost for the delivery option. */
  estimatedCost: Shopify_MoneyV2;
  /** The unique identifier of the delivery option. */
  handle: Scalars['String'];
  /** The title of the delivery option. */
  title: Maybe<Scalars['String']>;
};

/**
 * The input fields for submitting direct payment method information for checkout.
 *
 */
export type Shopify_CartDirectPaymentMethodInput = {
  /** The customer's billing address. */
  billingAddress: Shopify_MailingAddressInput;
  /** The source of the credit card payment. */
  cardSource: InputMaybe<Shopify_CartCardSource>;
  /** The session ID for the direct payment method used to create the payment. */
  sessionId: Scalars['String'];
};

/** The discounts that have been applied to the cart line. */
export type Shopify_CartDiscountAllocation = {
  /** The discounted amount that has been applied to the cart line. */
  discountedAmount: Shopify_MoneyV2;
};

/** The discount codes applied to the cart. */
export type Shopify_CartDiscountCode = {
  __typename?: 'shopify_CartDiscountCode';
  /** Whether the discount code is applicable to the cart's current contents. */
  applicable: Scalars['Boolean'];
  /** The code for the discount. */
  code: Scalars['String'];
};

/** Return type for `cartDiscountCodesUpdate` mutation. */
export type Shopify_CartDiscountCodesUpdatePayload = {
  __typename?: 'shopify_CartDiscountCodesUpdatePayload';
  /** The updated cart. */
  cart: Maybe<Shopify_Cart>;
  /** The list of errors that occurred from executing the mutation. */
  userErrors: Array<Shopify_CartUserError>;
};

/** Possible error codes that can be returned by `CartUserError`. */
export enum Shopify_CartErrorCode {
  /** The input value is invalid. */
  Invalid = 'INVALID',
  /** Delivery group was not found in cart. */
  InvalidDeliveryGroup = 'INVALID_DELIVERY_GROUP',
  /** Delivery option was not valid. */
  InvalidDeliveryOption = 'INVALID_DELIVERY_OPTION',
  /** Merchandise line was not found in cart. */
  InvalidMerchandiseLine = 'INVALID_MERCHANDISE_LINE',
  /** The metafields were not valid. */
  InvalidMetafields = 'INVALID_METAFIELDS',
  /** The payment wasn't valid. */
  InvalidPayment = 'INVALID_PAYMENT',
  /** Cannot update payment on an empty cart */
  InvalidPaymentEmptyCart = 'INVALID_PAYMENT_EMPTY_CART',
  /** The input value should be less than the maximum value allowed. */
  LessThan = 'LESS_THAN',
  /** Missing discount code. */
  MissingDiscountCode = 'MISSING_DISCOUNT_CODE',
  /** Missing note. */
  MissingNote = 'MISSING_NOTE',
  /** The payment method is not supported. */
  PaymentMethodNotSupported = 'PAYMENT_METHOD_NOT_SUPPORTED',
}

/** The estimated costs that the buyer will pay at checkout. The estimated cost uses [`CartBuyerIdentity`](https://shopify.dev/api/storefront/reference/cart/cartbuyeridentity) to determine [international pricing](https://shopify.dev/custom-storefronts/internationalization/international-pricing). */
export type Shopify_CartEstimatedCost = {
  __typename?: 'shopify_CartEstimatedCost';
  /** The estimated amount, before taxes and discounts, for the customer to pay at checkout. The checkout charge amount doesn't include any deferred payments that'll be paid at a later date. If the cart has no deferred payments, then the checkout charge amount is equivalent to`subtotal_amount`. */
  checkoutChargeAmount: Shopify_MoneyV2;
  /** The estimated amount, before taxes and discounts, for the customer to pay. */
  subtotalAmount: Shopify_MoneyV2;
  /** The estimated total amount for the customer to pay. */
  totalAmount: Shopify_MoneyV2;
  /** The estimated duty amount for the customer to pay at checkout. */
  totalDutyAmount: Maybe<Shopify_MoneyV2>;
  /** The estimated tax amount for the customer to pay at checkout. */
  totalTaxAmount: Maybe<Shopify_MoneyV2>;
};

/**
 * The input fields for submitting a billing address without a selected payment method.
 *
 */
export type Shopify_CartFreePaymentMethodInput = {
  /** The customer's billing address. */
  billingAddress: Shopify_MailingAddressInput;
};

/** The input fields to create a cart. */
export type Shopify_CartInput = {
  /**
   * An array of key-value pairs that contains additional information about the cart.
   *
   * The input must not contain more than `250` values.
   */
  attributes: InputMaybe<Array<Shopify_AttributeInput>>;
  /**
   * The customer associated with the cart. Used to determine [international pricing]
   * (https://shopify.dev/custom-storefronts/internationalization/international-pricing).
   * Buyer identity should match the customer's shipping address.
   *
   */
  buyerIdentity: InputMaybe<Shopify_CartBuyerIdentityInput>;
  /**
   * The case-insensitive discount codes that the customer added at checkout.
   *
   * The input must not contain more than `250` values.
   */
  discountCodes: InputMaybe<Array<Scalars['String']>>;
  /**
   * A list of merchandise lines to add to the cart.
   *
   * The input must not contain more than `250` values.
   */
  lines: InputMaybe<Array<Shopify_CartLineInput>>;
  /**
   * The metafields to associate with this cart.
   *
   * The input must not contain more than `250` values.
   */
  metafields: InputMaybe<Array<Shopify_CartInputMetafieldInput>>;
  /**
   * A note that's associated with the cart. For example, the note can be a personalized message to the buyer.
   *
   */
  note: InputMaybe<Scalars['String']>;
};

/** The input fields for a cart metafield value to set. */
export type Shopify_CartInputMetafieldInput = {
  /** The key name of the metafield. */
  key: Scalars['String'];
  /**
   * The type of data that the cart metafield stores.
   * The type of data must be a [supported type](https://shopify.dev/apps/metafields/types).
   *
   */
  type: Scalars['String'];
  /**
   * The data to store in the cart metafield. The data is always stored as a string, regardless of the metafield's type.
   *
   */
  value: Scalars['String'];
};

/** Represents information about the merchandise in the cart. */
export type Shopify_CartLine = Shopify_BaseCartLine &
  Shopify_Node & {
    __typename?: 'shopify_CartLine';
    /** An attribute associated with the cart line. */
    attribute: Maybe<Shopify_Attribute>;
    /** The attributes associated with the cart line. Attributes are represented as key-value pairs. */
    attributes: Array<Shopify_Attribute>;
    /** The cost of the merchandise that the buyer will pay for at checkout. The costs are subject to change and changes will be reflected at checkout. */
    cost: Shopify_CartLineCost;
    /** The discounts that have been applied to the cart line. */
    discountAllocations: Array<Shopify_CartDiscountAllocation>;
    /** The estimated cost of the merchandise that the buyer will pay for at checkout. The estimated costs are subject to change and changes will be reflected at checkout. */
    estimatedCost: Shopify_CartLineEstimatedCost;
    /** A globally-unique ID. */
    id: Scalars['ID'];
    /** The merchandise that the buyer intends to purchase. */
    merchandise: Shopify_Merchandise;
    /** The quantity of the merchandise that the customer intends to purchase. */
    quantity: Scalars['Int'];
    /** The selling plan associated with the cart line and the effect that each selling plan has on variants when they're purchased. */
    sellingPlanAllocation: Maybe<Shopify_SellingPlanAllocation>;
  };

/** Represents information about the merchandise in the cart. */
export type Shopify_CartLineAttributeArgs = {
  key: Scalars['String'];
};

/** The cost of the merchandise line that the buyer will pay at checkout. */
export type Shopify_CartLineCost = {
  __typename?: 'shopify_CartLineCost';
  /** The amount of the merchandise line. */
  amountPerQuantity: Shopify_MoneyV2;
  /** The compare at amount of the merchandise line. */
  compareAtAmountPerQuantity: Maybe<Shopify_MoneyV2>;
  /** The cost of the merchandise line before line-level discounts. */
  subtotalAmount: Shopify_MoneyV2;
  /** The total cost of the merchandise line. */
  totalAmount: Shopify_MoneyV2;
};

/**
 * The estimated cost of the merchandise line that the buyer will pay at checkout.
 *
 */
export type Shopify_CartLineEstimatedCost = {
  __typename?: 'shopify_CartLineEstimatedCost';
  /** The amount of the merchandise line. */
  amount: Shopify_MoneyV2;
  /** The compare at amount of the merchandise line. */
  compareAtAmount: Maybe<Shopify_MoneyV2>;
  /** The estimated cost of the merchandise line before discounts. */
  subtotalAmount: Shopify_MoneyV2;
  /** The estimated total cost of the merchandise line. */
  totalAmount: Shopify_MoneyV2;
};

/** The input fields to create a merchandise line on a cart. */
export type Shopify_CartLineInput = {
  /**
   * An array of key-value pairs that contains additional information about the merchandise line.
   *
   * The input must not contain more than `250` values.
   */
  attributes: InputMaybe<Array<Shopify_AttributeInput>>;
  /** The ID of the merchandise that the buyer intends to purchase. */
  merchandiseId: Scalars['ID'];
  /** The quantity of the merchandise. */
  quantity: InputMaybe<Scalars['Int']>;
  /** The ID of the selling plan that the merchandise is being purchased with. */
  sellingPlanId: InputMaybe<Scalars['ID']>;
};

/** The input fields to update a line item on a cart. */
export type Shopify_CartLineUpdateInput = {
  /**
   * An array of key-value pairs that contains additional information about the merchandise line.
   *
   * The input must not contain more than `250` values.
   */
  attributes: InputMaybe<Array<Shopify_AttributeInput>>;
  /** The ID of the merchandise line. */
  id: Scalars['ID'];
  /** The ID of the merchandise for the line item. */
  merchandiseId: InputMaybe<Scalars['ID']>;
  /** The quantity of the line item. */
  quantity: InputMaybe<Scalars['Int']>;
  /** The ID of the selling plan that the merchandise is being purchased with. */
  sellingPlanId: InputMaybe<Scalars['ID']>;
};

/** Return type for `cartLinesAdd` mutation. */
export type Shopify_CartLinesAddPayload = {
  __typename?: 'shopify_CartLinesAddPayload';
  /** The updated cart. */
  cart: Maybe<Shopify_Cart>;
  /** The list of errors that occurred from executing the mutation. */
  userErrors: Array<Shopify_CartUserError>;
};

/** Return type for `cartLinesRemove` mutation. */
export type Shopify_CartLinesRemovePayload = {
  __typename?: 'shopify_CartLinesRemovePayload';
  /** The updated cart. */
  cart: Maybe<Shopify_Cart>;
  /** The list of errors that occurred from executing the mutation. */
  userErrors: Array<Shopify_CartUserError>;
};

/** Return type for `cartLinesUpdate` mutation. */
export type Shopify_CartLinesUpdatePayload = {
  __typename?: 'shopify_CartLinesUpdatePayload';
  /** The updated cart. */
  cart: Maybe<Shopify_Cart>;
  /** The list of errors that occurred from executing the mutation. */
  userErrors: Array<Shopify_CartUserError>;
};

/** The input fields to delete a cart metafield. */
export type Shopify_CartMetafieldDeleteInput = {
  /**
   * The key name of the cart metafield. Can either be a composite key (`namespace.key`) or a simple key
   *  that relies on the default app-reserved namespace.
   *
   */
  key: Scalars['String'];
  /** The ID of the cart resource. */
  ownerId: Scalars['ID'];
};

/** Return type for `cartMetafieldDelete` mutation. */
export type Shopify_CartMetafieldDeletePayload = {
  __typename?: 'shopify_CartMetafieldDeletePayload';
  /** The ID of the deleted cart metafield. */
  deletedId: Maybe<Scalars['ID']>;
  /** The list of errors that occurred from executing the mutation. */
  userErrors: Array<Shopify_MetafieldDeleteUserError>;
};

/** The input fields for a cart metafield value to set. */
export type Shopify_CartMetafieldsSetInput = {
  /** The key name of the cart metafield. */
  key: Scalars['String'];
  /** The ID of the cart resource. */
  ownerId: Scalars['ID'];
  /**
   * The type of data that the cart metafield stores.
   * The type of data must be a [supported type](https://shopify.dev/apps/metafields/types).
   *
   */
  type: Scalars['String'];
  /**
   * The data to store in the cart metafield. The data is always stored as a string, regardless of the metafield's type.
   *
   */
  value: Scalars['String'];
};

/** Return type for `cartMetafieldsSet` mutation. */
export type Shopify_CartMetafieldsSetPayload = {
  __typename?: 'shopify_CartMetafieldsSetPayload';
  /** The list of cart metafields that were set. */
  metafields: Maybe<Array<Shopify_Metafield>>;
  /** The list of errors that occurred from executing the mutation. */
  userErrors: Array<Shopify_MetafieldsSetUserError>;
};

/** Return type for `cartNoteUpdate` mutation. */
export type Shopify_CartNoteUpdatePayload = {
  __typename?: 'shopify_CartNoteUpdatePayload';
  /** The updated cart. */
  cart: Maybe<Shopify_Cart>;
  /** The list of errors that occurred from executing the mutation. */
  userErrors: Array<Shopify_CartUserError>;
};

/**
 * The input fields for updating the payment method that will be used to checkout.
 *
 */
export type Shopify_CartPaymentInput = {
  /** The amount that the customer will be charged at checkout. */
  amount: Shopify_MoneyInput;
  /**
   * The input fields to use when checking out a cart with a direct payment method (like a credit card).
   *
   */
  directPaymentMethod: InputMaybe<Shopify_CartDirectPaymentMethodInput>;
  /**
   * The input fields to use to checkout a cart without providing a payment method.
   * Use this payment method input if the total cost of the cart is 0.
   *
   */
  freePaymentMethod: InputMaybe<Shopify_CartFreePaymentMethodInput>;
  /**
   * An ID of the order placed on the originating platform.
   * Note that this value doesn't correspond to the Shopify Order ID.
   *
   */
  sourceIdentifier: InputMaybe<Scalars['String']>;
  /**
   * The input fields to use when checking out a cart with a wallet payment method (like Shop Pay or Apple Pay).
   *
   */
  walletPaymentMethod: InputMaybe<Shopify_CartWalletPaymentMethodInput>;
};

/** Return type for `cartPaymentUpdate` mutation. */
export type Shopify_CartPaymentUpdatePayload = {
  __typename?: 'shopify_CartPaymentUpdatePayload';
  /** The updated cart. */
  cart: Maybe<Shopify_Cart>;
  /** The list of errors that occurred from executing the mutation. */
  userErrors: Array<Shopify_CartUserError>;
};

/**
 * The input fields for updating the selected delivery options for a delivery group.
 *
 */
export type Shopify_CartSelectedDeliveryOptionInput = {
  /** The ID of the cart delivery group. */
  deliveryGroupId: Scalars['ID'];
  /** The handle of the selected delivery option. */
  deliveryOptionHandle: Scalars['String'];
};

/** Return type for `cartSelectedDeliveryOptionsUpdate` mutation. */
export type Shopify_CartSelectedDeliveryOptionsUpdatePayload = {
  __typename?: 'shopify_CartSelectedDeliveryOptionsUpdatePayload';
  /** The updated cart. */
  cart: Maybe<Shopify_Cart>;
  /** The list of errors that occurred from executing the mutation. */
  userErrors: Array<Shopify_CartUserError>;
};

/** Return type for `cartSubmitForCompletion` mutation. */
export type Shopify_CartSubmitForCompletionPayload = {
  __typename?: 'shopify_CartSubmitForCompletionPayload';
  /** The result of cart submission for completion. */
  result: Maybe<Shopify_CartSubmitForCompletionResult>;
  /** The list of errors that occurred from executing the mutation. */
  userErrors: Array<Shopify_CartUserError>;
};

/** The result of cart submit completion. */
export type Shopify_CartSubmitForCompletionResult =
  | Shopify_SubmitAlreadyAccepted
  | Shopify_SubmitFailed
  | Shopify_SubmitSuccess
  | Shopify_SubmitThrottled;

/** Represents an error that happens during execution of a cart mutation. */
export type Shopify_CartUserError = Shopify_DisplayableError & {
  __typename?: 'shopify_CartUserError';
  /** The error code. */
  code: Maybe<Shopify_CartErrorCode>;
  /** The path to the input field that caused the error. */
  field: Maybe<Array<Scalars['String']>>;
  /** The error message. */
  message: Scalars['String'];
};

/**
 * The input fields for submitting wallet payment method information for checkout.
 *
 */
export type Shopify_CartWalletPaymentMethodInput = {
  /** The payment method information for the Apple Pay wallet. */
  applePayWalletContent: InputMaybe<Shopify_ApplePayWalletContentInput>;
  /** The payment method information for the Shop Pay wallet. */
  shopPayWalletContent: InputMaybe<Shopify_ShopPayWalletContentInput>;
};

/** A container for all the information required to checkout items and pay. */
export type Shopify_Checkout = Shopify_Node & {
  __typename?: 'shopify_Checkout';
  /** The gift cards used on the checkout. */
  appliedGiftCards: Array<Shopify_AppliedGiftCard>;
  /**
   * The available shipping rates for this Checkout.
   * Should only be used when checkout `requiresShipping` is `true` and
   * the shipping address is valid.
   *
   */
  availableShippingRates: Maybe<Shopify_AvailableShippingRates>;
  /** The identity of the customer associated with the checkout. */
  buyerIdentity: Shopify_CheckoutBuyerIdentity;
  /** The date and time when the checkout was completed. */
  completedAt: Maybe<Scalars['shopify_DateTime']>;
  /** The date and time when the checkout was created. */
  createdAt: Scalars['shopify_DateTime'];
  /** The currency code for the checkout. */
  currencyCode: Shopify_CurrencyCode;
  /** A list of extra information that's added to the checkout. */
  customAttributes: Array<Shopify_Attribute>;
  /** Discounts that have been applied on the checkout. */
  discountApplications: Shopify_DiscountApplicationConnection;
  /** The email attached to this checkout. */
  email: Maybe<Scalars['String']>;
  /** A globally-unique ID. */
  id: Scalars['ID'];
  /** A list of line item objects, each one containing information about an item in the checkout. */
  lineItems: Shopify_CheckoutLineItemConnection;
  /** The sum of all the prices of all the items in the checkout. Duties, taxes, shipping and discounts excluded. */
  lineItemsSubtotalPrice: Shopify_MoneyV2;
  /** The note associated with the checkout. */
  note: Maybe<Scalars['String']>;
  /** The resulting order from a paid checkout. */
  order: Maybe<Shopify_Order>;
  /** The <b>Order status</b> page for this Checkout, null when checkout isn't completed. */
  orderStatusUrl: Maybe<Scalars['shopify_URL']>;
  /** The amount left to be paid. This is equal to the cost of the line items, taxes, and shipping, minus discounts and gift cards. */
  paymentDue: Shopify_MoneyV2;
  /** The amount left to be paid. This is equal to the cost of the line items, duties, taxes, and shipping, minus discounts and gift cards. */
  paymentDueV2: Shopify_MoneyV2;
  /**
   * Whether or not the Checkout is ready and can be completed. Checkouts may
   * have asynchronous operations that can take time to finish. If you want
   * to complete a checkout or ensure all the fields are populated and up to
   * date, polling is required until the value is true.
   *
   */
  ready: Scalars['Boolean'];
  /** States whether or not the fulfillment requires shipping. */
  requiresShipping: Scalars['Boolean'];
  /** The shipping address to where the line items will be shipped. */
  shippingAddress: Maybe<Shopify_MailingAddress>;
  /**
   * The discounts that have been allocated onto the shipping line by discount applications.
   *
   */
  shippingDiscountAllocations: Array<Shopify_DiscountAllocation>;
  /** Once a shipping rate is selected by the customer it's transitioned to a `shipping_line` object. */
  shippingLine: Maybe<Shopify_ShippingRate>;
  /** The price at checkout before shipping and taxes. */
  subtotalPrice: Shopify_MoneyV2;
  /** The price at checkout before duties, shipping, and taxes. */
  subtotalPriceV2: Shopify_MoneyV2;
  /** Whether the checkout is tax exempt. */
  taxExempt: Scalars['Boolean'];
  /** Whether taxes are included in the line item and shipping line prices. */
  taxesIncluded: Scalars['Boolean'];
  /** The sum of all the duties applied to the line items in the checkout. */
  totalDuties: Maybe<Shopify_MoneyV2>;
  /** The sum of all the prices of all the items in the checkout, including taxes and duties. */
  totalPrice: Shopify_MoneyV2;
  /** The sum of all the prices of all the items in the checkout, including taxes and duties. */
  totalPriceV2: Shopify_MoneyV2;
  /** The sum of all the taxes applied to the line items and shipping lines in the checkout. */
  totalTax: Shopify_MoneyV2;
  /** The sum of all the taxes applied to the line items and shipping lines in the checkout. */
  totalTaxV2: Shopify_MoneyV2;
  /** The date and time when the checkout was last updated. */
  updatedAt: Scalars['shopify_DateTime'];
  /** The url pointing to the checkout accessible from the web. */
  webUrl: Scalars['shopify_URL'];
};

/** A container for all the information required to checkout items and pay. */
export type Shopify_CheckoutDiscountApplicationsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  reverse?: InputMaybe<Scalars['Boolean']>;
};

/** A container for all the information required to checkout items and pay. */
export type Shopify_CheckoutLineItemsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  reverse?: InputMaybe<Scalars['Boolean']>;
};

/** The input fields required to update a checkout's attributes. */
export type Shopify_CheckoutAttributesUpdateV2Input = {
  /**
   * Allows setting partial addresses on a Checkout, skipping the full validation of attributes.
   * The required attributes are city, province, and country.
   * Full validation of the addresses is still done at completion time. Defaults to `false` with
   * each operation.
   *
   */
  allowPartialAddresses: InputMaybe<Scalars['Boolean']>;
  /**
   * A list of extra information that's added to the checkout.
   *
   * The input must not contain more than `250` values.
   */
  customAttributes: InputMaybe<Array<Shopify_AttributeInput>>;
  /** The text of an optional note that a shop owner can attach to the checkout. */
  note: InputMaybe<Scalars['String']>;
};

/** Return type for `checkoutAttributesUpdateV2` mutation. */
export type Shopify_CheckoutAttributesUpdateV2Payload = {
  __typename?: 'shopify_CheckoutAttributesUpdateV2Payload';
  /** The updated checkout object. */
  checkout: Maybe<Shopify_Checkout>;
  /** The list of errors that occurred from executing the mutation. */
  checkoutUserErrors: Array<Shopify_CheckoutUserError>;
  /** The list of errors that occurred from executing the mutation. */
  userErrors: Array<Shopify_UserError>;
};

/** The identity of the customer associated with the checkout. */
export type Shopify_CheckoutBuyerIdentity = {
  __typename?: 'shopify_CheckoutBuyerIdentity';
  /** The country code for the checkout. For example, `CA`. */
  countryCode: Maybe<Shopify_CountryCode>;
};

/** The input fields for the identity of the customer associated with the checkout. */
export type Shopify_CheckoutBuyerIdentityInput = {
  /**
   * The country code of one of the shop's
   * [enabled countries](https://help.shopify.com/en/manual/payments/shopify-payments/multi-currency/setup).
   * For example, `CA`. Including this field creates a checkout in the specified country's currency.
   *
   */
  countryCode: Shopify_CountryCode;
};

/** Return type for `checkoutCompleteFree` mutation. */
export type Shopify_CheckoutCompleteFreePayload = {
  __typename?: 'shopify_CheckoutCompleteFreePayload';
  /** The updated checkout object. */
  checkout: Maybe<Shopify_Checkout>;
  /** The list of errors that occurred from executing the mutation. */
  checkoutUserErrors: Array<Shopify_CheckoutUserError>;
  /** The list of errors that occurred from executing the mutation. */
  userErrors: Array<Shopify_UserError>;
};

/** Return type for `checkoutCompleteWithCreditCardV2` mutation. */
export type Shopify_CheckoutCompleteWithCreditCardV2Payload = {
  __typename?: 'shopify_CheckoutCompleteWithCreditCardV2Payload';
  /** The checkout on which the payment was applied. */
  checkout: Maybe<Shopify_Checkout>;
  /** The list of errors that occurred from executing the mutation. */
  checkoutUserErrors: Array<Shopify_CheckoutUserError>;
  /** A representation of the attempted payment. */
  payment: Maybe<Shopify_Payment>;
  /** The list of errors that occurred from executing the mutation. */
  userErrors: Array<Shopify_UserError>;
};

/** Return type for `checkoutCompleteWithTokenizedPaymentV3` mutation. */
export type Shopify_CheckoutCompleteWithTokenizedPaymentV3Payload = {
  __typename?: 'shopify_CheckoutCompleteWithTokenizedPaymentV3Payload';
  /** The checkout on which the payment was applied. */
  checkout: Maybe<Shopify_Checkout>;
  /** The list of errors that occurred from executing the mutation. */
  checkoutUserErrors: Array<Shopify_CheckoutUserError>;
  /** A representation of the attempted payment. */
  payment: Maybe<Shopify_Payment>;
  /** The list of errors that occurred from executing the mutation. */
  userErrors: Array<Shopify_UserError>;
};

/** The input fields required to create a checkout. */
export type Shopify_CheckoutCreateInput = {
  /**
   * Allows setting partial addresses on a Checkout, skipping the full validation of attributes.
   * The required attributes are city, province, and country.
   * Full validation of addresses is still done at completion time. Defaults to `null`.
   *
   */
  allowPartialAddresses: InputMaybe<Scalars['Boolean']>;
  /** The identity of the customer associated with the checkout. */
  buyerIdentity: InputMaybe<Shopify_CheckoutBuyerIdentityInput>;
  /**
   * A list of extra information that's added to the checkout.
   *
   * The input must not contain more than `250` values.
   */
  customAttributes: InputMaybe<Array<Shopify_AttributeInput>>;
  /** The email with which the customer wants to checkout. */
  email: InputMaybe<Scalars['String']>;
  /**
   * A list of line item objects, each one containing information about an item in the checkout.
   *
   * The input must not contain more than `250` values.
   */
  lineItems: InputMaybe<Array<Shopify_CheckoutLineItemInput>>;
  /** The text of an optional note that a shop owner can attach to the checkout. */
  note: InputMaybe<Scalars['String']>;
  /** The shipping address to where the line items will be shipped. */
  shippingAddress: InputMaybe<Shopify_MailingAddressInput>;
};

/** Return type for `checkoutCreate` mutation. */
export type Shopify_CheckoutCreatePayload = {
  __typename?: 'shopify_CheckoutCreatePayload';
  /** The new checkout object. */
  checkout: Maybe<Shopify_Checkout>;
  /** The list of errors that occurred from executing the mutation. */
  checkoutUserErrors: Array<Shopify_CheckoutUserError>;
  /** The checkout queue token. Available only to selected stores. */
  queueToken: Maybe<Scalars['String']>;
  /** The list of errors that occurred from executing the mutation. */
  userErrors: Array<Shopify_UserError>;
};

/** Return type for `checkoutCustomerAssociateV2` mutation. */
export type Shopify_CheckoutCustomerAssociateV2Payload = {
  __typename?: 'shopify_CheckoutCustomerAssociateV2Payload';
  /** The updated checkout object. */
  checkout: Maybe<Shopify_Checkout>;
  /** The list of errors that occurred from executing the mutation. */
  checkoutUserErrors: Array<Shopify_CheckoutUserError>;
  /** The associated customer object. */
  customer: Maybe<Shopify_Customer>;
  /** The list of errors that occurred from executing the mutation. */
  userErrors: Array<Shopify_UserError>;
};

/** Return type for `checkoutCustomerDisassociateV2` mutation. */
export type Shopify_CheckoutCustomerDisassociateV2Payload = {
  __typename?: 'shopify_CheckoutCustomerDisassociateV2Payload';
  /** The updated checkout object. */
  checkout: Maybe<Shopify_Checkout>;
  /** The list of errors that occurred from executing the mutation. */
  checkoutUserErrors: Array<Shopify_CheckoutUserError>;
  /** The list of errors that occurred from executing the mutation. */
  userErrors: Array<Shopify_UserError>;
};

/** Return type for `checkoutDiscountCodeApplyV2` mutation. */
export type Shopify_CheckoutDiscountCodeApplyV2Payload = {
  __typename?: 'shopify_CheckoutDiscountCodeApplyV2Payload';
  /** The updated checkout object. */
  checkout: Maybe<Shopify_Checkout>;
  /** The list of errors that occurred from executing the mutation. */
  checkoutUserErrors: Array<Shopify_CheckoutUserError>;
  /** The list of errors that occurred from executing the mutation. */
  userErrors: Array<Shopify_UserError>;
};

/** Return type for `checkoutDiscountCodeRemove` mutation. */
export type Shopify_CheckoutDiscountCodeRemovePayload = {
  __typename?: 'shopify_CheckoutDiscountCodeRemovePayload';
  /** The updated checkout object. */
  checkout: Maybe<Shopify_Checkout>;
  /** The list of errors that occurred from executing the mutation. */
  checkoutUserErrors: Array<Shopify_CheckoutUserError>;
  /** The list of errors that occurred from executing the mutation. */
  userErrors: Array<Shopify_UserError>;
};

/** Return type for `checkoutEmailUpdateV2` mutation. */
export type Shopify_CheckoutEmailUpdateV2Payload = {
  __typename?: 'shopify_CheckoutEmailUpdateV2Payload';
  /** The checkout object with the updated email. */
  checkout: Maybe<Shopify_Checkout>;
  /** The list of errors that occurred from executing the mutation. */
  checkoutUserErrors: Array<Shopify_CheckoutUserError>;
  /** The list of errors that occurred from executing the mutation. */
  userErrors: Array<Shopify_UserError>;
};

/** Possible error codes that can be returned by `CheckoutUserError`. */
export enum Shopify_CheckoutErrorCode {
  /** Checkout is already completed. */
  AlreadyCompleted = 'ALREADY_COMPLETED',
  /** Input email contains an invalid domain name. */
  BadDomain = 'BAD_DOMAIN',
  /** The input value is blank. */
  Blank = 'BLANK',
  /** Cart does not meet discount requirements notice. */
  CartDoesNotMeetDiscountRequirementsNotice = 'CART_DOES_NOT_MEET_DISCOUNT_REQUIREMENTS_NOTICE',
  /** Customer already used once per customer discount notice. */
  CustomerAlreadyUsedOncePerCustomerDiscountNotice = 'CUSTOMER_ALREADY_USED_ONCE_PER_CUSTOMER_DISCOUNT_NOTICE',
  /** Discount already applied. */
  DiscountAlreadyApplied = 'DISCOUNT_ALREADY_APPLIED',
  /** Discount code isn't working right now. Please contact us for help. */
  DiscountCodeApplicationFailed = 'DISCOUNT_CODE_APPLICATION_FAILED',
  /** Discount disabled. */
  DiscountDisabled = 'DISCOUNT_DISABLED',
  /** Discount expired. */
  DiscountExpired = 'DISCOUNT_EXPIRED',
  /** Discount limit reached. */
  DiscountLimitReached = 'DISCOUNT_LIMIT_REACHED',
  /** Discount not found. */
  DiscountNotFound = 'DISCOUNT_NOT_FOUND',
  /** Checkout is already completed. */
  Empty = 'EMPTY',
  /** Queue token has expired. */
  ExpiredQueueToken = 'EXPIRED_QUEUE_TOKEN',
  /** Gift card has already been applied. */
  GiftCardAlreadyApplied = 'GIFT_CARD_ALREADY_APPLIED',
  /** Gift card code is invalid. */
  GiftCardCodeInvalid = 'GIFT_CARD_CODE_INVALID',
  /** Gift card currency does not match checkout currency. */
  GiftCardCurrencyMismatch = 'GIFT_CARD_CURRENCY_MISMATCH',
  /** Gift card has no funds left. */
  GiftCardDepleted = 'GIFT_CARD_DEPLETED',
  /** Gift card is disabled. */
  GiftCardDisabled = 'GIFT_CARD_DISABLED',
  /** Gift card is expired. */
  GiftCardExpired = 'GIFT_CARD_EXPIRED',
  /** Gift card was not found. */
  GiftCardNotFound = 'GIFT_CARD_NOT_FOUND',
  /** Gift card cannot be applied to a checkout that contains a gift card. */
  GiftCardUnusable = 'GIFT_CARD_UNUSABLE',
  /** The input value should be greater than or equal to the minimum value allowed. */
  GreaterThanOrEqualTo = 'GREATER_THAN_OR_EQUAL_TO',
  /** Higher value discount applied. */
  HigherValueDiscountApplied = 'HIGHER_VALUE_DISCOUNT_APPLIED',
  /** The input value is invalid. */
  Invalid = 'INVALID',
  /** Cannot specify country and presentment currency code. */
  InvalidCountryAndCurrency = 'INVALID_COUNTRY_AND_CURRENCY',
  /** Input Zip is invalid for country provided. */
  InvalidForCountry = 'INVALID_FOR_COUNTRY',
  /** Input Zip is invalid for country and province provided. */
  InvalidForCountryAndProvince = 'INVALID_FOR_COUNTRY_AND_PROVINCE',
  /** Invalid province in country. */
  InvalidProvinceInCountry = 'INVALID_PROVINCE_IN_COUNTRY',
  /** Queue token is invalid. */
  InvalidQueueToken = 'INVALID_QUEUE_TOKEN',
  /** Invalid region in country. */
  InvalidRegionInCountry = 'INVALID_REGION_IN_COUNTRY',
  /** Invalid state in country. */
  InvalidStateInCountry = 'INVALID_STATE_IN_COUNTRY',
  /** The input value should be less than the maximum value allowed. */
  LessThan = 'LESS_THAN',
  /** The input value should be less than or equal to the maximum value allowed. */
  LessThanOrEqualTo = 'LESS_THAN_OR_EQUAL_TO',
  /** Line item was not found in checkout. */
  LineItemNotFound = 'LINE_ITEM_NOT_FOUND',
  /** Checkout is locked. */
  Locked = 'LOCKED',
  /** Maximum number of discount codes limit reached. */
  MaximumDiscountCodeLimitReached = 'MAXIMUM_DISCOUNT_CODE_LIMIT_REACHED',
  /** Missing payment input. */
  MissingPaymentInput = 'MISSING_PAYMENT_INPUT',
  /** Not enough in stock. */
  NotEnoughInStock = 'NOT_ENOUGH_IN_STOCK',
  /** Input value is not supported. */
  NotSupported = 'NOT_SUPPORTED',
  /** The input value needs to be blank. */
  Present = 'PRESENT',
  /** Product is not published for this customer. */
  ProductNotAvailable = 'PRODUCT_NOT_AVAILABLE',
  /** Shipping rate expired. */
  ShippingRateExpired = 'SHIPPING_RATE_EXPIRED',
  /** Throttled during checkout. */
  ThrottledDuringCheckout = 'THROTTLED_DURING_CHECKOUT',
  /** The input value is too long. */
  TooLong = 'TOO_LONG',
  /** The amount of the payment does not match the value to be paid. */
  TotalPriceMismatch = 'TOTAL_PRICE_MISMATCH',
  /** Unable to apply discount. */
  UnableToApply = 'UNABLE_TO_APPLY',
}

/** Return type for `checkoutGiftCardRemoveV2` mutation. */
export type Shopify_CheckoutGiftCardRemoveV2Payload = {
  __typename?: 'shopify_CheckoutGiftCardRemoveV2Payload';
  /** The updated checkout object. */
  checkout: Maybe<Shopify_Checkout>;
  /** The list of errors that occurred from executing the mutation. */
  checkoutUserErrors: Array<Shopify_CheckoutUserError>;
  /** The list of errors that occurred from executing the mutation. */
  userErrors: Array<Shopify_UserError>;
};

/** Return type for `checkoutGiftCardsAppend` mutation. */
export type Shopify_CheckoutGiftCardsAppendPayload = {
  __typename?: 'shopify_CheckoutGiftCardsAppendPayload';
  /** The updated checkout object. */
  checkout: Maybe<Shopify_Checkout>;
  /** The list of errors that occurred from executing the mutation. */
  checkoutUserErrors: Array<Shopify_CheckoutUserError>;
  /** The list of errors that occurred from executing the mutation. */
  userErrors: Array<Shopify_UserError>;
};

/** A single line item in the checkout, grouped by variant and attributes. */
export type Shopify_CheckoutLineItem = Shopify_Node & {
  __typename?: 'shopify_CheckoutLineItem';
  /** Extra information in the form of an array of Key-Value pairs about the line item. */
  customAttributes: Array<Shopify_Attribute>;
  /** The discounts that have been allocated onto the checkout line item by discount applications. */
  discountAllocations: Array<Shopify_DiscountAllocation>;
  /** A globally-unique ID. */
  id: Scalars['ID'];
  /** The quantity of the line item. */
  quantity: Scalars['Int'];
  /** Title of the line item. Defaults to the product's title. */
  title: Scalars['String'];
  /** Unit price of the line item. */
  unitPrice: Maybe<Shopify_MoneyV2>;
  /** Product variant of the line item. */
  variant: Maybe<Shopify_ProductVariant>;
};

/**
 * An auto-generated type for paginating through multiple CheckoutLineItems.
 *
 */
export type Shopify_CheckoutLineItemConnection = {
  __typename?: 'shopify_CheckoutLineItemConnection';
  /** A list of edges. */
  edges: Array<Shopify_CheckoutLineItemEdge>;
  /** A list of the nodes contained in CheckoutLineItemEdge. */
  nodes: Array<Shopify_CheckoutLineItem>;
  /** Information to aid in pagination. */
  pageInfo: Shopify_PageInfo;
};

/**
 * An auto-generated type which holds one CheckoutLineItem and a cursor during pagination.
 *
 */
export type Shopify_CheckoutLineItemEdge = {
  __typename?: 'shopify_CheckoutLineItemEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of CheckoutLineItemEdge. */
  node: Shopify_CheckoutLineItem;
};

/** The input fields to create a line item on a checkout. */
export type Shopify_CheckoutLineItemInput = {
  /**
   * Extra information in the form of an array of Key-Value pairs about the line item.
   *
   * The input must not contain more than `250` values.
   */
  customAttributes: InputMaybe<Array<Shopify_AttributeInput>>;
  /** The quantity of the line item. */
  quantity: Scalars['Int'];
  /** The ID of the product variant for the line item. */
  variantId: Scalars['ID'];
};

/** The input fields to update a line item on the checkout. */
export type Shopify_CheckoutLineItemUpdateInput = {
  /**
   * Extra information in the form of an array of Key-Value pairs about the line item.
   *
   * The input must not contain more than `250` values.
   */
  customAttributes: InputMaybe<Array<Shopify_AttributeInput>>;
  /** The ID of the line item. */
  id: InputMaybe<Scalars['ID']>;
  /** The quantity of the line item. */
  quantity: InputMaybe<Scalars['Int']>;
  /** The variant ID of the line item. */
  variantId: InputMaybe<Scalars['ID']>;
};

/** Return type for `checkoutLineItemsAdd` mutation. */
export type Shopify_CheckoutLineItemsAddPayload = {
  __typename?: 'shopify_CheckoutLineItemsAddPayload';
  /** The updated checkout object. */
  checkout: Maybe<Shopify_Checkout>;
  /** The list of errors that occurred from executing the mutation. */
  checkoutUserErrors: Array<Shopify_CheckoutUserError>;
  /** The list of errors that occurred from executing the mutation. */
  userErrors: Array<Shopify_UserError>;
};

/** Return type for `checkoutLineItemsRemove` mutation. */
export type Shopify_CheckoutLineItemsRemovePayload = {
  __typename?: 'shopify_CheckoutLineItemsRemovePayload';
  /** The updated checkout object. */
  checkout: Maybe<Shopify_Checkout>;
  /** The list of errors that occurred from executing the mutation. */
  checkoutUserErrors: Array<Shopify_CheckoutUserError>;
  /** The list of errors that occurred from executing the mutation. */
  userErrors: Array<Shopify_UserError>;
};

/** Return type for `checkoutLineItemsReplace` mutation. */
export type Shopify_CheckoutLineItemsReplacePayload = {
  __typename?: 'shopify_CheckoutLineItemsReplacePayload';
  /** The updated checkout object. */
  checkout: Maybe<Shopify_Checkout>;
  /** The list of errors that occurred from executing the mutation. */
  userErrors: Array<Shopify_CheckoutUserError>;
};

/** Return type for `checkoutLineItemsUpdate` mutation. */
export type Shopify_CheckoutLineItemsUpdatePayload = {
  __typename?: 'shopify_CheckoutLineItemsUpdatePayload';
  /** The updated checkout object. */
  checkout: Maybe<Shopify_Checkout>;
  /** The list of errors that occurred from executing the mutation. */
  checkoutUserErrors: Array<Shopify_CheckoutUserError>;
  /** The list of errors that occurred from executing the mutation. */
  userErrors: Array<Shopify_UserError>;
};

/** Return type for `checkoutShippingAddressUpdateV2` mutation. */
export type Shopify_CheckoutShippingAddressUpdateV2Payload = {
  __typename?: 'shopify_CheckoutShippingAddressUpdateV2Payload';
  /** The updated checkout object. */
  checkout: Maybe<Shopify_Checkout>;
  /** The list of errors that occurred from executing the mutation. */
  checkoutUserErrors: Array<Shopify_CheckoutUserError>;
  /** The list of errors that occurred from executing the mutation. */
  userErrors: Array<Shopify_UserError>;
};

/** Return type for `checkoutShippingLineUpdate` mutation. */
export type Shopify_CheckoutShippingLineUpdatePayload = {
  __typename?: 'shopify_CheckoutShippingLineUpdatePayload';
  /** The updated checkout object. */
  checkout: Maybe<Shopify_Checkout>;
  /** The list of errors that occurred from executing the mutation. */
  checkoutUserErrors: Array<Shopify_CheckoutUserError>;
  /** The list of errors that occurred from executing the mutation. */
  userErrors: Array<Shopify_UserError>;
};

/** Represents an error that happens during execution of a checkout mutation. */
export type Shopify_CheckoutUserError = Shopify_DisplayableError & {
  __typename?: 'shopify_CheckoutUserError';
  /** The error code. */
  code: Maybe<Shopify_CheckoutErrorCode>;
  /** The path to the input field that caused the error. */
  field: Maybe<Array<Scalars['String']>>;
  /** The error message. */
  message: Scalars['String'];
};

/**
 * A collection represents a grouping of products that a shop owner can create to
 * organize them or make their shops easier to browse.
 *
 */
export type Shopify_Collection = Shopify_HasMetafields &
  Shopify_Node &
  Shopify_OnlineStorePublishable & {
    __typename?: 'shopify_Collection';
    /** Stripped description of the collection, single line with HTML tags removed. */
    description: Scalars['String'];
    /** The description of the collection, complete with HTML formatting. */
    descriptionHtml: Scalars['shopify_HTML'];
    /**
     * A human-friendly unique string for the collection automatically generated from its title.
     * Limit of 255 characters.
     *
     */
    handle: Scalars['String'];
    /** A globally-unique ID. */
    id: Scalars['ID'];
    /** Image associated with the collection. */
    image: Maybe<Shopify_Image>;
    /** Returns a metafield found by namespace and key. */
    metafield: Maybe<Shopify_Metafield>;
    /** The metafields associated with the resource matching the supplied list of namespaces and keys. */
    metafields: Array<Maybe<Shopify_Metafield>>;
    /** The URL used for viewing the resource on the shop's Online Store. Returns `null` if the resource is currently not published to the Online Store sales channel. */
    onlineStoreUrl: Maybe<Scalars['shopify_URL']>;
    /** List of products in the collection. */
    products: Shopify_ProductConnection;
    /** The collection's SEO information. */
    seo: Shopify_Seo;
    /** The collections name. Limit of 255 characters. */
    title: Scalars['String'];
    /** The date and time when the collection was last modified. */
    updatedAt: Scalars['shopify_DateTime'];
  };

/**
 * A collection represents a grouping of products that a shop owner can create to
 * organize them or make their shops easier to browse.
 *
 */
export type Shopify_CollectionDescriptionArgs = {
  truncateAt: InputMaybe<Scalars['Int']>;
};

/**
 * A collection represents a grouping of products that a shop owner can create to
 * organize them or make their shops easier to browse.
 *
 */
export type Shopify_CollectionMetafieldArgs = {
  key: Scalars['String'];
  namespace: Scalars['String'];
};

/**
 * A collection represents a grouping of products that a shop owner can create to
 * organize them or make their shops easier to browse.
 *
 */
export type Shopify_CollectionMetafieldsArgs = {
  identifiers: Array<Shopify_HasMetafieldsIdentifier>;
};

/**
 * A collection represents a grouping of products that a shop owner can create to
 * organize them or make their shops easier to browse.
 *
 */
export type Shopify_CollectionProductsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  filters: InputMaybe<Array<Shopify_ProductFilter>>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  reverse?: InputMaybe<Scalars['Boolean']>;
  sortKey?: InputMaybe<Shopify_ProductCollectionSortKeys>;
};

/**
 * An auto-generated type for paginating through multiple Collections.
 *
 */
export type Shopify_CollectionConnection = {
  __typename?: 'shopify_CollectionConnection';
  /** A list of edges. */
  edges: Array<Shopify_CollectionEdge>;
  /** A list of the nodes contained in CollectionEdge. */
  nodes: Array<Shopify_Collection>;
  /** Information to aid in pagination. */
  pageInfo: Shopify_PageInfo;
};

/**
 * An auto-generated type which holds one Collection and a cursor during pagination.
 *
 */
export type Shopify_CollectionEdge = {
  __typename?: 'shopify_CollectionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of CollectionEdge. */
  node: Shopify_Collection;
};

/** The set of valid sort keys for the Collection query. */
export enum Shopify_CollectionSortKeys {
  /** Sort by the `id` value. */
  Id = 'ID',
  /**
   * Sort by relevance to the search terms when the `query` parameter is specified on the connection.
   * Don't use this sort key when no search query is specified.
   *
   */
  Relevance = 'RELEVANCE',
  /** Sort by the `title` value. */
  Title = 'TITLE',
  /** Sort by the `updated_at` value. */
  UpdatedAt = 'UPDATED_AT',
}

/** A comment on an article. */
export type Shopify_Comment = Shopify_Node & {
  __typename?: 'shopify_Comment';
  /** The comments author. */
  author: Shopify_CommentAuthor;
  /** Stripped content of the comment, single line with HTML tags removed. */
  content: Scalars['String'];
  /** The content of the comment, complete with HTML formatting. */
  contentHtml: Scalars['shopify_HTML'];
  /** A globally-unique ID. */
  id: Scalars['ID'];
};

/** A comment on an article. */
export type Shopify_CommentContentArgs = {
  truncateAt: InputMaybe<Scalars['Int']>;
};

/** The author of a comment. */
export type Shopify_CommentAuthor = {
  __typename?: 'shopify_CommentAuthor';
  /** The author's email. */
  email: Scalars['String'];
  /** The authors name. */
  name: Scalars['String'];
};

/**
 * An auto-generated type for paginating through multiple Comments.
 *
 */
export type Shopify_CommentConnection = {
  __typename?: 'shopify_CommentConnection';
  /** A list of edges. */
  edges: Array<Shopify_CommentEdge>;
  /** A list of the nodes contained in CommentEdge. */
  nodes: Array<Shopify_Comment>;
  /** Information to aid in pagination. */
  pageInfo: Shopify_PageInfo;
};

/**
 * An auto-generated type which holds one Comment and a cursor during pagination.
 *
 */
export type Shopify_CommentEdge = {
  __typename?: 'shopify_CommentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of CommentEdge. */
  node: Shopify_Comment;
};

/** The action for the 3DS payment redirect. */
export type Shopify_CompletePaymentChallenge = {
  __typename?: 'shopify_CompletePaymentChallenge';
  /** The URL for the 3DS payment redirect. */
  redirectUrl: Maybe<Scalars['shopify_URL']>;
};

/** An error that occurred during a cart completion attempt. */
export type Shopify_CompletionError = {
  __typename?: 'shopify_CompletionError';
  /** The error code. */
  code: Shopify_CompletionErrorCode;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

/** The code of the error that occurred during a cart completion attempt. */
export enum Shopify_CompletionErrorCode {
  Error = 'ERROR',
  InventoryReservationError = 'INVENTORY_RESERVATION_ERROR',
  PaymentAmountTooSmall = 'PAYMENT_AMOUNT_TOO_SMALL',
  PaymentCallIssuer = 'PAYMENT_CALL_ISSUER',
  PaymentCardDeclined = 'PAYMENT_CARD_DECLINED',
  PaymentError = 'PAYMENT_ERROR',
  PaymentGatewayNotEnabledError = 'PAYMENT_GATEWAY_NOT_ENABLED_ERROR',
  PaymentInsufficientFunds = 'PAYMENT_INSUFFICIENT_FUNDS',
  PaymentInvalidBillingAddress = 'PAYMENT_INVALID_BILLING_ADDRESS',
  PaymentInvalidCreditCard = 'PAYMENT_INVALID_CREDIT_CARD',
  PaymentInvalidCurrency = 'PAYMENT_INVALID_CURRENCY',
  PaymentInvalidPaymentMethod = 'PAYMENT_INVALID_PAYMENT_METHOD',
  PaymentTransientError = 'PAYMENT_TRANSIENT_ERROR',
}

/** A country. */
export type Shopify_Country = {
  __typename?: 'shopify_Country';
  /** The languages available for the country. */
  availableLanguages: Array<Shopify_Language>;
  /** The currency of the country. */
  currency: Shopify_Currency;
  /** The ISO code of the country. */
  isoCode: Shopify_CountryCode;
  /** The market that includes this country. */
  market: Maybe<Shopify_Market>;
  /** The name of the country. */
  name: Scalars['String'];
  /** The unit system used in the country. */
  unitSystem: Shopify_UnitSystem;
};

/**
 * The code designating a country/region, which generally follows ISO 3166-1 alpha-2 guidelines.
 * If a territory doesn't have a country code value in the `CountryCode` enum, then it might be considered a subdivision
 * of another country. For example, the territories associated with Spain are represented by the country code `ES`,
 * and the territories associated with the United States of America are represented by the country code `US`.
 *
 */
export enum Shopify_CountryCode {
  /** Ascension Island. */
  Ac = 'AC',
  /** Andorra. */
  Ad = 'AD',
  /** United Arab Emirates. */
  Ae = 'AE',
  /** Afghanistan. */
  Af = 'AF',
  /** Antigua & Barbuda. */
  Ag = 'AG',
  /** Anguilla. */
  Ai = 'AI',
  /** Albania. */
  Al = 'AL',
  /** Armenia. */
  Am = 'AM',
  /** Netherlands Antilles. */
  An = 'AN',
  /** Angola. */
  Ao = 'AO',
  /** Argentina. */
  Ar = 'AR',
  /** Austria. */
  At = 'AT',
  /** Australia. */
  Au = 'AU',
  /** Aruba. */
  Aw = 'AW',
  /** land Islands. */
  Ax = 'AX',
  /** Azerbaijan. */
  Az = 'AZ',
  /** Bosnia & Herzegovina. */
  Ba = 'BA',
  /** Barbados. */
  Bb = 'BB',
  /** Bangladesh. */
  Bd = 'BD',
  /** Belgium. */
  Be = 'BE',
  /** Burkina Faso. */
  Bf = 'BF',
  /** Bulgaria. */
  Bg = 'BG',
  /** Bahrain. */
  Bh = 'BH',
  /** Burundi. */
  Bi = 'BI',
  /** Benin. */
  Bj = 'BJ',
  /** St. Barthlemy. */
  Bl = 'BL',
  /** Bermuda. */
  Bm = 'BM',
  /** Brunei. */
  Bn = 'BN',
  /** Bolivia. */
  Bo = 'BO',
  /** Caribbean Netherlands. */
  Bq = 'BQ',
  /** Brazil. */
  Br = 'BR',
  /** Bahamas. */
  Bs = 'BS',
  /** Bhutan. */
  Bt = 'BT',
  /** Bouvet Island. */
  Bv = 'BV',
  /** Botswana. */
  Bw = 'BW',
  /** Belarus. */
  By = 'BY',
  /** Belize. */
  Bz = 'BZ',
  /** Canada. */
  Ca = 'CA',
  /** Cocos (Keeling) Islands. */
  Cc = 'CC',
  /** Congo - Kinshasa. */
  Cd = 'CD',
  /** Central African Republic. */
  Cf = 'CF',
  /** Congo - Brazzaville. */
  Cg = 'CG',
  /** Switzerland. */
  Ch = 'CH',
  /** Cte dIvoire. */
  Ci = 'CI',
  /** Cook Islands. */
  Ck = 'CK',
  /** Chile. */
  Cl = 'CL',
  /** Cameroon. */
  Cm = 'CM',
  /** China. */
  Cn = 'CN',
  /** Colombia. */
  Co = 'CO',
  /** Costa Rica. */
  Cr = 'CR',
  /** Cuba. */
  Cu = 'CU',
  /** Cape Verde. */
  Cv = 'CV',
  /** Curaao. */
  Cw = 'CW',
  /** Christmas Island. */
  Cx = 'CX',
  /** Cyprus. */
  Cy = 'CY',
  /** Czechia. */
  Cz = 'CZ',
  /** Germany. */
  De = 'DE',
  /** Djibouti. */
  Dj = 'DJ',
  /** Denmark. */
  Dk = 'DK',
  /** Dominica. */
  Dm = 'DM',
  /** Dominican Republic. */
  Do = 'DO',
  /** Algeria. */
  Dz = 'DZ',
  /** Ecuador. */
  Ec = 'EC',
  /** Estonia. */
  Ee = 'EE',
  /** Egypt. */
  Eg = 'EG',
  /** Western Sahara. */
  Eh = 'EH',
  /** Eritrea. */
  Er = 'ER',
  /** Spain. */
  Es = 'ES',
  /** Ethiopia. */
  Et = 'ET',
  /** Finland. */
  Fi = 'FI',
  /** Fiji. */
  Fj = 'FJ',
  /** Falkland Islands. */
  Fk = 'FK',
  /** Faroe Islands. */
  Fo = 'FO',
  /** France. */
  Fr = 'FR',
  /** Gabon. */
  Ga = 'GA',
  /** United Kingdom. */
  Gb = 'GB',
  /** Grenada. */
  Gd = 'GD',
  /** Georgia. */
  Ge = 'GE',
  /** French Guiana. */
  Gf = 'GF',
  /** Guernsey. */
  Gg = 'GG',
  /** Ghana. */
  Gh = 'GH',
  /** Gibraltar. */
  Gi = 'GI',
  /** Greenland. */
  Gl = 'GL',
  /** Gambia. */
  Gm = 'GM',
  /** Guinea. */
  Gn = 'GN',
  /** Guadeloupe. */
  Gp = 'GP',
  /** Equatorial Guinea. */
  Gq = 'GQ',
  /** Greece. */
  Gr = 'GR',
  /** South Georgia & South Sandwich Islands. */
  Gs = 'GS',
  /** Guatemala. */
  Gt = 'GT',
  /** Guinea-Bissau. */
  Gw = 'GW',
  /** Guyana. */
  Gy = 'GY',
  /** Hong Kong SAR. */
  Hk = 'HK',
  /** Heard & McDonald Islands. */
  Hm = 'HM',
  /** Honduras. */
  Hn = 'HN',
  /** Croatia. */
  Hr = 'HR',
  /** Haiti. */
  Ht = 'HT',
  /** Hungary. */
  Hu = 'HU',
  /** Indonesia. */
  Id = 'ID',
  /** Ireland. */
  Ie = 'IE',
  /** Israel. */
  Il = 'IL',
  /** Isle of Man. */
  Im = 'IM',
  /** India. */
  In = 'IN',
  /** British Indian Ocean Territory. */
  Io = 'IO',
  /** Iraq. */
  Iq = 'IQ',
  /** Iran. */
  Ir = 'IR',
  /** Iceland. */
  Is = 'IS',
  /** Italy. */
  It = 'IT',
  /** Jersey. */
  Je = 'JE',
  /** Jamaica. */
  Jm = 'JM',
  /** Jordan. */
  Jo = 'JO',
  /** Japan. */
  Jp = 'JP',
  /** Kenya. */
  Ke = 'KE',
  /** Kyrgyzstan. */
  Kg = 'KG',
  /** Cambodia. */
  Kh = 'KH',
  /** Kiribati. */
  Ki = 'KI',
  /** Comoros. */
  Km = 'KM',
  /** St. Kitts & Nevis. */
  Kn = 'KN',
  /** North Korea. */
  Kp = 'KP',
  /** South Korea. */
  Kr = 'KR',
  /** Kuwait. */
  Kw = 'KW',
  /** Cayman Islands. */
  Ky = 'KY',
  /** Kazakhstan. */
  Kz = 'KZ',
  /** Laos. */
  La = 'LA',
  /** Lebanon. */
  Lb = 'LB',
  /** St. Lucia. */
  Lc = 'LC',
  /** Liechtenstein. */
  Li = 'LI',
  /** Sri Lanka. */
  Lk = 'LK',
  /** Liberia. */
  Lr = 'LR',
  /** Lesotho. */
  Ls = 'LS',
  /** Lithuania. */
  Lt = 'LT',
  /** Luxembourg. */
  Lu = 'LU',
  /** Latvia. */
  Lv = 'LV',
  /** Libya. */
  Ly = 'LY',
  /** Morocco. */
  Ma = 'MA',
  /** Monaco. */
  Mc = 'MC',
  /** Moldova. */
  Md = 'MD',
  /** Montenegro. */
  Me = 'ME',
  /** St. Martin. */
  Mf = 'MF',
  /** Madagascar. */
  Mg = 'MG',
  /** North Macedonia. */
  Mk = 'MK',
  /** Mali. */
  Ml = 'ML',
  /** Myanmar (Burma). */
  Mm = 'MM',
  /** Mongolia. */
  Mn = 'MN',
  /** Macao SAR. */
  Mo = 'MO',
  /** Martinique. */
  Mq = 'MQ',
  /** Mauritania. */
  Mr = 'MR',
  /** Montserrat. */
  Ms = 'MS',
  /** Malta. */
  Mt = 'MT',
  /** Mauritius. */
  Mu = 'MU',
  /** Maldives. */
  Mv = 'MV',
  /** Malawi. */
  Mw = 'MW',
  /** Mexico. */
  Mx = 'MX',
  /** Malaysia. */
  My = 'MY',
  /** Mozambique. */
  Mz = 'MZ',
  /** Namibia. */
  Na = 'NA',
  /** New Caledonia. */
  Nc = 'NC',
  /** Niger. */
  Ne = 'NE',
  /** Norfolk Island. */
  Nf = 'NF',
  /** Nigeria. */
  Ng = 'NG',
  /** Nicaragua. */
  Ni = 'NI',
  /** Netherlands. */
  Nl = 'NL',
  /** Norway. */
  No = 'NO',
  /** Nepal. */
  Np = 'NP',
  /** Nauru. */
  Nr = 'NR',
  /** Niue. */
  Nu = 'NU',
  /** New Zealand. */
  Nz = 'NZ',
  /** Oman. */
  Om = 'OM',
  /** Panama. */
  Pa = 'PA',
  /** Peru. */
  Pe = 'PE',
  /** French Polynesia. */
  Pf = 'PF',
  /** Papua New Guinea. */
  Pg = 'PG',
  /** Philippines. */
  Ph = 'PH',
  /** Pakistan. */
  Pk = 'PK',
  /** Poland. */
  Pl = 'PL',
  /** St. Pierre & Miquelon. */
  Pm = 'PM',
  /** Pitcairn Islands. */
  Pn = 'PN',
  /** Palestinian Territories. */
  Ps = 'PS',
  /** Portugal. */
  Pt = 'PT',
  /** Paraguay. */
  Py = 'PY',
  /** Qatar. */
  Qa = 'QA',
  /** Runion. */
  Re = 'RE',
  /** Romania. */
  Ro = 'RO',
  /** Serbia. */
  Rs = 'RS',
  /** Russia. */
  Ru = 'RU',
  /** Rwanda. */
  Rw = 'RW',
  /** Saudi Arabia. */
  Sa = 'SA',
  /** Solomon Islands. */
  Sb = 'SB',
  /** Seychelles. */
  Sc = 'SC',
  /** Sudan. */
  Sd = 'SD',
  /** Sweden. */
  Se = 'SE',
  /** Singapore. */
  Sg = 'SG',
  /** St. Helena. */
  Sh = 'SH',
  /** Slovenia. */
  Si = 'SI',
  /** Svalbard & Jan Mayen. */
  Sj = 'SJ',
  /** Slovakia. */
  Sk = 'SK',
  /** Sierra Leone. */
  Sl = 'SL',
  /** San Marino. */
  Sm = 'SM',
  /** Senegal. */
  Sn = 'SN',
  /** Somalia. */
  So = 'SO',
  /** Suriname. */
  Sr = 'SR',
  /** South Sudan. */
  Ss = 'SS',
  /** So Tom & Prncipe. */
  St = 'ST',
  /** El Salvador. */
  Sv = 'SV',
  /** Sint Maarten. */
  Sx = 'SX',
  /** Syria. */
  Sy = 'SY',
  /** Eswatini. */
  Sz = 'SZ',
  /** Tristan da Cunha. */
  Ta = 'TA',
  /** Turks & Caicos Islands. */
  Tc = 'TC',
  /** Chad. */
  Td = 'TD',
  /** French Southern Territories. */
  Tf = 'TF',
  /** Togo. */
  Tg = 'TG',
  /** Thailand. */
  Th = 'TH',
  /** Tajikistan. */
  Tj = 'TJ',
  /** Tokelau. */
  Tk = 'TK',
  /** Timor-Leste. */
  Tl = 'TL',
  /** Turkmenistan. */
  Tm = 'TM',
  /** Tunisia. */
  Tn = 'TN',
  /** Tonga. */
  To = 'TO',
  /** Trkiye. */
  Tr = 'TR',
  /** Trinidad & Tobago. */
  Tt = 'TT',
  /** Tuvalu. */
  Tv = 'TV',
  /** Taiwan. */
  Tw = 'TW',
  /** Tanzania. */
  Tz = 'TZ',
  /** Ukraine. */
  Ua = 'UA',
  /** Uganda. */
  Ug = 'UG',
  /** U.S. Outlying Islands. */
  Um = 'UM',
  /** United States. */
  Us = 'US',
  /** Uruguay. */
  Uy = 'UY',
  /** Uzbekistan. */
  Uz = 'UZ',
  /** Vatican City. */
  Va = 'VA',
  /** St. Vincent & Grenadines. */
  Vc = 'VC',
  /** Venezuela. */
  Ve = 'VE',
  /** British Virgin Islands. */
  Vg = 'VG',
  /** Vietnam. */
  Vn = 'VN',
  /** Vanuatu. */
  Vu = 'VU',
  /** Wallis & Futuna. */
  Wf = 'WF',
  /** Samoa. */
  Ws = 'WS',
  /** Kosovo. */
  Xk = 'XK',
  /** Yemen. */
  Ye = 'YE',
  /** Mayotte. */
  Yt = 'YT',
  /** South Africa. */
  Za = 'ZA',
  /** Zambia. */
  Zm = 'ZM',
  /** Zimbabwe. */
  Zw = 'ZW',
  /** Unknown Region. */
  Zz = 'ZZ',
}

/** Credit card information used for a payment. */
export type Shopify_CreditCard = {
  __typename?: 'shopify_CreditCard';
  /** The brand of the credit card. */
  brand: Maybe<Scalars['String']>;
  /** The expiry month of the credit card. */
  expiryMonth: Maybe<Scalars['Int']>;
  /** The expiry year of the credit card. */
  expiryYear: Maybe<Scalars['Int']>;
  /** The credit card's BIN number. */
  firstDigits: Maybe<Scalars['String']>;
  /** The first name of the card holder. */
  firstName: Maybe<Scalars['String']>;
  /** The last 4 digits of the credit card. */
  lastDigits: Maybe<Scalars['String']>;
  /** The last name of the card holder. */
  lastName: Maybe<Scalars['String']>;
  /** The masked credit card number with only the last 4 digits displayed. */
  maskedNumber: Maybe<Scalars['String']>;
};

/**
 * Specifies the fields required to complete a checkout with
 * a Shopify vaulted credit card payment.
 *
 */
export type Shopify_CreditCardPaymentInputV2 = {
  /** The billing address for the payment. */
  billingAddress: Shopify_MailingAddressInput;
  /** A unique client generated key used to avoid duplicate charges. When a duplicate payment is found, the original is returned instead of creating a new one. For more information, refer to [Idempotent requests](https://shopify.dev/api/usage/idempotent-requests). */
  idempotencyKey: Scalars['String'];
  /** The amount and currency of the payment. */
  paymentAmount: Shopify_MoneyInput;
  /** Executes the payment in test mode if possible. Defaults to `false`. */
  test: InputMaybe<Scalars['Boolean']>;
  /** The ID returned by Shopify's Card Vault. */
  vaultId: Scalars['String'];
};

/** The part of the image that should remain after cropping. */
export enum Shopify_CropRegion {
  /** Keep the bottom of the image. */
  Bottom = 'BOTTOM',
  /** Keep the center of the image. */
  Center = 'CENTER',
  /** Keep the left of the image. */
  Left = 'LEFT',
  /** Keep the right of the image. */
  Right = 'RIGHT',
  /** Keep the top of the image. */
  Top = 'TOP',
}

/** A currency. */
export type Shopify_Currency = {
  __typename?: 'shopify_Currency';
  /** The ISO code of the currency. */
  isoCode: Shopify_CurrencyCode;
  /** The name of the currency. */
  name: Scalars['String'];
  /** The symbol of the currency. */
  symbol: Scalars['String'];
};

/**
 * The three-letter currency codes that represent the world currencies used in
 * stores. These include standard ISO 4217 codes, legacy codes,
 * and non-standard codes.
 *
 */
export enum Shopify_CurrencyCode {
  /** United Arab Emirates Dirham (AED). */
  Aed = 'AED',
  /** Afghan Afghani (AFN). */
  Afn = 'AFN',
  /** Albanian Lek (ALL). */
  All = 'ALL',
  /** Armenian Dram (AMD). */
  Amd = 'AMD',
  /** Netherlands Antillean Guilder. */
  Ang = 'ANG',
  /** Angolan Kwanza (AOA). */
  Aoa = 'AOA',
  /** Argentine Pesos (ARS). */
  Ars = 'ARS',
  /** Australian Dollars (AUD). */
  Aud = 'AUD',
  /** Aruban Florin (AWG). */
  Awg = 'AWG',
  /** Azerbaijani Manat (AZN). */
  Azn = 'AZN',
  /** Bosnia and Herzegovina Convertible Mark (BAM). */
  Bam = 'BAM',
  /** Barbadian Dollar (BBD). */
  Bbd = 'BBD',
  /** Bangladesh Taka (BDT). */
  Bdt = 'BDT',
  /** Bulgarian Lev (BGN). */
  Bgn = 'BGN',
  /** Bahraini Dinar (BHD). */
  Bhd = 'BHD',
  /** Burundian Franc (BIF). */
  Bif = 'BIF',
  /** Bermudian Dollar (BMD). */
  Bmd = 'BMD',
  /** Brunei Dollar (BND). */
  Bnd = 'BND',
  /** Bolivian Boliviano (BOB). */
  Bob = 'BOB',
  /** Brazilian Real (BRL). */
  Brl = 'BRL',
  /** Bahamian Dollar (BSD). */
  Bsd = 'BSD',
  /** Bhutanese Ngultrum (BTN). */
  Btn = 'BTN',
  /** Botswana Pula (BWP). */
  Bwp = 'BWP',
  /** Belarusian Ruble (BYN). */
  Byn = 'BYN',
  /** Belarusian Ruble (BYR). */
  Byr = 'BYR',
  /** Belize Dollar (BZD). */
  Bzd = 'BZD',
  /** Canadian Dollars (CAD). */
  Cad = 'CAD',
  /** Congolese franc (CDF). */
  Cdf = 'CDF',
  /** Swiss Francs (CHF). */
  Chf = 'CHF',
  /** Chilean Peso (CLP). */
  Clp = 'CLP',
  /** Chinese Yuan Renminbi (CNY). */
  Cny = 'CNY',
  /** Colombian Peso (COP). */
  Cop = 'COP',
  /** Costa Rican Colones (CRC). */
  Crc = 'CRC',
  /** Cape Verdean escudo (CVE). */
  Cve = 'CVE',
  /** Czech Koruny (CZK). */
  Czk = 'CZK',
  /** Djiboutian Franc (DJF). */
  Djf = 'DJF',
  /** Danish Kroner (DKK). */
  Dkk = 'DKK',
  /** Dominican Peso (DOP). */
  Dop = 'DOP',
  /** Algerian Dinar (DZD). */
  Dzd = 'DZD',
  /** Egyptian Pound (EGP). */
  Egp = 'EGP',
  /** Eritrean Nakfa (ERN). */
  Ern = 'ERN',
  /** Ethiopian Birr (ETB). */
  Etb = 'ETB',
  /** Euro (EUR). */
  Eur = 'EUR',
  /** Fijian Dollars (FJD). */
  Fjd = 'FJD',
  /** Falkland Islands Pounds (FKP). */
  Fkp = 'FKP',
  /** United Kingdom Pounds (GBP). */
  Gbp = 'GBP',
  /** Georgian Lari (GEL). */
  Gel = 'GEL',
  /** Ghanaian Cedi (GHS). */
  Ghs = 'GHS',
  /** Gibraltar Pounds (GIP). */
  Gip = 'GIP',
  /** Gambian Dalasi (GMD). */
  Gmd = 'GMD',
  /** Guinean Franc (GNF). */
  Gnf = 'GNF',
  /** Guatemalan Quetzal (GTQ). */
  Gtq = 'GTQ',
  /** Guyanese Dollar (GYD). */
  Gyd = 'GYD',
  /** Hong Kong Dollars (HKD). */
  Hkd = 'HKD',
  /** Honduran Lempira (HNL). */
  Hnl = 'HNL',
  /** Croatian Kuna (HRK). */
  Hrk = 'HRK',
  /** Haitian Gourde (HTG). */
  Htg = 'HTG',
  /** Hungarian Forint (HUF). */
  Huf = 'HUF',
  /** Indonesian Rupiah (IDR). */
  Idr = 'IDR',
  /** Israeli New Shekel (NIS). */
  Ils = 'ILS',
  /** Indian Rupees (INR). */
  Inr = 'INR',
  /** Iraqi Dinar (IQD). */
  Iqd = 'IQD',
  /** Iranian Rial (IRR). */
  Irr = 'IRR',
  /** Icelandic Kronur (ISK). */
  Isk = 'ISK',
  /** Jersey Pound. */
  Jep = 'JEP',
  /** Jamaican Dollars (JMD). */
  Jmd = 'JMD',
  /** Jordanian Dinar (JOD). */
  Jod = 'JOD',
  /** Japanese Yen (JPY). */
  Jpy = 'JPY',
  /** Kenyan Shilling (KES). */
  Kes = 'KES',
  /** Kyrgyzstani Som (KGS). */
  Kgs = 'KGS',
  /** Cambodian Riel. */
  Khr = 'KHR',
  /** Kiribati Dollar (KID). */
  Kid = 'KID',
  /** Comorian Franc (KMF). */
  Kmf = 'KMF',
  /** South Korean Won (KRW). */
  Krw = 'KRW',
  /** Kuwaiti Dinar (KWD). */
  Kwd = 'KWD',
  /** Cayman Dollars (KYD). */
  Kyd = 'KYD',
  /** Kazakhstani Tenge (KZT). */
  Kzt = 'KZT',
  /** Laotian Kip (LAK). */
  Lak = 'LAK',
  /** Lebanese Pounds (LBP). */
  Lbp = 'LBP',
  /** Sri Lankan Rupees (LKR). */
  Lkr = 'LKR',
  /** Liberian Dollar (LRD). */
  Lrd = 'LRD',
  /** Lesotho Loti (LSL). */
  Lsl = 'LSL',
  /** Lithuanian Litai (LTL). */
  Ltl = 'LTL',
  /** Latvian Lati (LVL). */
  Lvl = 'LVL',
  /** Libyan Dinar (LYD). */
  Lyd = 'LYD',
  /** Moroccan Dirham. */
  Mad = 'MAD',
  /** Moldovan Leu (MDL). */
  Mdl = 'MDL',
  /** Malagasy Ariary (MGA). */
  Mga = 'MGA',
  /** Macedonia Denar (MKD). */
  Mkd = 'MKD',
  /** Burmese Kyat (MMK). */
  Mmk = 'MMK',
  /** Mongolian Tugrik. */
  Mnt = 'MNT',
  /** Macanese Pataca (MOP). */
  Mop = 'MOP',
  /** Mauritanian Ouguiya (MRU). */
  Mru = 'MRU',
  /** Mauritian Rupee (MUR). */
  Mur = 'MUR',
  /** Maldivian Rufiyaa (MVR). */
  Mvr = 'MVR',
  /** Malawian Kwacha (MWK). */
  Mwk = 'MWK',
  /** Mexican Pesos (MXN). */
  Mxn = 'MXN',
  /** Malaysian Ringgits (MYR). */
  Myr = 'MYR',
  /** Mozambican Metical. */
  Mzn = 'MZN',
  /** Namibian Dollar. */
  Nad = 'NAD',
  /** Nigerian Naira (NGN). */
  Ngn = 'NGN',
  /** Nicaraguan Crdoba (NIO). */
  Nio = 'NIO',
  /** Norwegian Kroner (NOK). */
  Nok = 'NOK',
  /** Nepalese Rupee (NPR). */
  Npr = 'NPR',
  /** New Zealand Dollars (NZD). */
  Nzd = 'NZD',
  /** Omani Rial (OMR). */
  Omr = 'OMR',
  /** Panamian Balboa (PAB). */
  Pab = 'PAB',
  /** Peruvian Nuevo Sol (PEN). */
  Pen = 'PEN',
  /** Papua New Guinean Kina (PGK). */
  Pgk = 'PGK',
  /** Philippine Peso (PHP). */
  Php = 'PHP',
  /** Pakistani Rupee (PKR). */
  Pkr = 'PKR',
  /** Polish Zlotych (PLN). */
  Pln = 'PLN',
  /** Paraguayan Guarani (PYG). */
  Pyg = 'PYG',
  /** Qatari Rial (QAR). */
  Qar = 'QAR',
  /** Romanian Lei (RON). */
  Ron = 'RON',
  /** Serbian dinar (RSD). */
  Rsd = 'RSD',
  /** Russian Rubles (RUB). */
  Rub = 'RUB',
  /** Rwandan Franc (RWF). */
  Rwf = 'RWF',
  /** Saudi Riyal (SAR). */
  Sar = 'SAR',
  /** Solomon Islands Dollar (SBD). */
  Sbd = 'SBD',
  /** Seychellois Rupee (SCR). */
  Scr = 'SCR',
  /** Sudanese Pound (SDG). */
  Sdg = 'SDG',
  /** Swedish Kronor (SEK). */
  Sek = 'SEK',
  /** Singapore Dollars (SGD). */
  Sgd = 'SGD',
  /** Saint Helena Pounds (SHP). */
  Shp = 'SHP',
  /** Sierra Leonean Leone (SLL). */
  Sll = 'SLL',
  /** Somali Shilling (SOS). */
  Sos = 'SOS',
  /** Surinamese Dollar (SRD). */
  Srd = 'SRD',
  /** South Sudanese Pound (SSP). */
  Ssp = 'SSP',
  /** Sao Tome And Principe Dobra (STD). */
  Std = 'STD',
  /** Sao Tome And Principe Dobra (STN). */
  Stn = 'STN',
  /** Syrian Pound (SYP). */
  Syp = 'SYP',
  /** Swazi Lilangeni (SZL). */
  Szl = 'SZL',
  /** Thai baht (THB). */
  Thb = 'THB',
  /** Tajikistani Somoni (TJS). */
  Tjs = 'TJS',
  /** Turkmenistani Manat (TMT). */
  Tmt = 'TMT',
  /** Tunisian Dinar (TND). */
  Tnd = 'TND',
  /** Tongan Pa'anga (TOP). */
  Top = 'TOP',
  /** Turkish Lira (TRY). */
  Try = 'TRY',
  /** Trinidad and Tobago Dollars (TTD). */
  Ttd = 'TTD',
  /** Taiwan Dollars (TWD). */
  Twd = 'TWD',
  /** Tanzanian Shilling (TZS). */
  Tzs = 'TZS',
  /** Ukrainian Hryvnia (UAH). */
  Uah = 'UAH',
  /** Ugandan Shilling (UGX). */
  Ugx = 'UGX',
  /** United States Dollars (USD). */
  Usd = 'USD',
  /** Uruguayan Pesos (UYU). */
  Uyu = 'UYU',
  /** Uzbekistan som (UZS). */
  Uzs = 'UZS',
  /** Venezuelan Bolivares (VED). */
  Ved = 'VED',
  /** Venezuelan Bolivares (VEF). */
  Vef = 'VEF',
  /** Venezuelan Bolivares Soberanos (VES). */
  Ves = 'VES',
  /** Vietnamese ng (VND). */
  Vnd = 'VND',
  /** Vanuatu Vatu (VUV). */
  Vuv = 'VUV',
  /** Samoan Tala (WST). */
  Wst = 'WST',
  /** Central African CFA Franc (XAF). */
  Xaf = 'XAF',
  /** East Caribbean Dollar (XCD). */
  Xcd = 'XCD',
  /** West African CFA franc (XOF). */
  Xof = 'XOF',
  /** CFP Franc (XPF). */
  Xpf = 'XPF',
  /** Unrecognized currency. */
  Xxx = 'XXX',
  /** Yemeni Rial (YER). */
  Yer = 'YER',
  /** South African Rand (ZAR). */
  Zar = 'ZAR',
  /** Zambian Kwacha (ZMW). */
  Zmw = 'ZMW',
}

/** A customer represents a customer account with the shop. Customer accounts store contact information for the customer, saving logged-in customers the trouble of having to provide it at every checkout. */
export type Shopify_Customer = Shopify_HasMetafields & {
  __typename?: 'shopify_Customer';
  /** Indicates whether the customer has consented to be sent marketing material via email. */
  acceptsMarketing: Scalars['Boolean'];
  /** A list of addresses for the customer. */
  addresses: Shopify_MailingAddressConnection;
  /** The date and time when the customer was created. */
  createdAt: Scalars['shopify_DateTime'];
  /** The customers default address. */
  defaultAddress: Maybe<Shopify_MailingAddress>;
  /** The customers name, email or phone number. */
  displayName: Scalars['String'];
  /** The customers email address. */
  email: Maybe<Scalars['String']>;
  /** The customers first name. */
  firstName: Maybe<Scalars['String']>;
  /** A unique ID for the customer. */
  id: Scalars['ID'];
  /** The customer's most recently updated, incomplete checkout. */
  lastIncompleteCheckout: Maybe<Shopify_Checkout>;
  /** The customers last name. */
  lastName: Maybe<Scalars['String']>;
  /** Returns a metafield found by namespace and key. */
  metafield: Maybe<Shopify_Metafield>;
  /** The metafields associated with the resource matching the supplied list of namespaces and keys. */
  metafields: Array<Maybe<Shopify_Metafield>>;
  /** The number of orders that the customer has made at the store in their lifetime. */
  numberOfOrders: Scalars['shopify_UnsignedInt64'];
  /** The orders associated with the customer. */
  orders: Shopify_OrderConnection;
  /** The customers phone number. */
  phone: Maybe<Scalars['String']>;
  /**
   * A comma separated list of tags that have been added to the customer.
   * Additional access scope required: unauthenticated_read_customer_tags.
   *
   */
  tags: Array<Scalars['String']>;
  /** The date and time when the customer information was updated. */
  updatedAt: Scalars['shopify_DateTime'];
};

/** A customer represents a customer account with the shop. Customer accounts store contact information for the customer, saving logged-in customers the trouble of having to provide it at every checkout. */
export type Shopify_CustomerAddressesArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  reverse?: InputMaybe<Scalars['Boolean']>;
};

/** A customer represents a customer account with the shop. Customer accounts store contact information for the customer, saving logged-in customers the trouble of having to provide it at every checkout. */
export type Shopify_CustomerMetafieldArgs = {
  key: Scalars['String'];
  namespace: Scalars['String'];
};

/** A customer represents a customer account with the shop. Customer accounts store contact information for the customer, saving logged-in customers the trouble of having to provide it at every checkout. */
export type Shopify_CustomerMetafieldsArgs = {
  identifiers: Array<Shopify_HasMetafieldsIdentifier>;
};

/** A customer represents a customer account with the shop. Customer accounts store contact information for the customer, saving logged-in customers the trouble of having to provide it at every checkout. */
export type Shopify_CustomerOrdersArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  query: InputMaybe<Scalars['String']>;
  reverse?: InputMaybe<Scalars['Boolean']>;
  sortKey?: InputMaybe<Shopify_OrderSortKeys>;
};

/** A CustomerAccessToken represents the unique token required to make modifications to the customer object. */
export type Shopify_CustomerAccessToken = {
  __typename?: 'shopify_CustomerAccessToken';
  /** The customers access token. */
  accessToken: Scalars['String'];
  /** The date and time when the customer access token expires. */
  expiresAt: Scalars['shopify_DateTime'];
};

/** The input fields required to create a customer access token. */
export type Shopify_CustomerAccessTokenCreateInput = {
  /** The email associated to the customer. */
  email: Scalars['String'];
  /** The login password to be used by the customer. */
  password: Scalars['String'];
};

/** Return type for `customerAccessTokenCreate` mutation. */
export type Shopify_CustomerAccessTokenCreatePayload = {
  __typename?: 'shopify_CustomerAccessTokenCreatePayload';
  /** The newly created customer access token object. */
  customerAccessToken: Maybe<Shopify_CustomerAccessToken>;
  /** The list of errors that occurred from executing the mutation. */
  customerUserErrors: Array<Shopify_CustomerUserError>;
  /** The list of errors that occurred from executing the mutation. */
  userErrors: Array<Shopify_UserError>;
};

/** Return type for `customerAccessTokenCreateWithMultipass` mutation. */
export type Shopify_CustomerAccessTokenCreateWithMultipassPayload = {
  __typename?: 'shopify_CustomerAccessTokenCreateWithMultipassPayload';
  /** An access token object associated with the customer. */
  customerAccessToken: Maybe<Shopify_CustomerAccessToken>;
  /** The list of errors that occurred from executing the mutation. */
  customerUserErrors: Array<Shopify_CustomerUserError>;
};

/** Return type for `customerAccessTokenDelete` mutation. */
export type Shopify_CustomerAccessTokenDeletePayload = {
  __typename?: 'shopify_CustomerAccessTokenDeletePayload';
  /** The destroyed access token. */
  deletedAccessToken: Maybe<Scalars['String']>;
  /** ID of the destroyed customer access token. */
  deletedCustomerAccessTokenId: Maybe<Scalars['String']>;
  /** The list of errors that occurred from executing the mutation. */
  userErrors: Array<Shopify_UserError>;
};

/** Return type for `customerAccessTokenRenew` mutation. */
export type Shopify_CustomerAccessTokenRenewPayload = {
  __typename?: 'shopify_CustomerAccessTokenRenewPayload';
  /** The renewed customer access token object. */
  customerAccessToken: Maybe<Shopify_CustomerAccessToken>;
  /** The list of errors that occurred from executing the mutation. */
  userErrors: Array<Shopify_UserError>;
};

/** Return type for `customerActivateByUrl` mutation. */
export type Shopify_CustomerActivateByUrlPayload = {
  __typename?: 'shopify_CustomerActivateByUrlPayload';
  /** The customer that was activated. */
  customer: Maybe<Shopify_Customer>;
  /** A new customer access token for the customer. */
  customerAccessToken: Maybe<Shopify_CustomerAccessToken>;
  /** The list of errors that occurred from executing the mutation. */
  customerUserErrors: Array<Shopify_CustomerUserError>;
};

/** The input fields to activate a customer. */
export type Shopify_CustomerActivateInput = {
  /** The activation token required to activate the customer. */
  activationToken: Scalars['String'];
  /** New password that will be set during activation. */
  password: Scalars['String'];
};

/** Return type for `customerActivate` mutation. */
export type Shopify_CustomerActivatePayload = {
  __typename?: 'shopify_CustomerActivatePayload';
  /** The customer object. */
  customer: Maybe<Shopify_Customer>;
  /** A newly created customer access token object for the customer. */
  customerAccessToken: Maybe<Shopify_CustomerAccessToken>;
  /** The list of errors that occurred from executing the mutation. */
  customerUserErrors: Array<Shopify_CustomerUserError>;
  /** The list of errors that occurred from executing the mutation. */
  userErrors: Array<Shopify_UserError>;
};

/** Return type for `customerAddressCreate` mutation. */
export type Shopify_CustomerAddressCreatePayload = {
  __typename?: 'shopify_CustomerAddressCreatePayload';
  /** The new customer address object. */
  customerAddress: Maybe<Shopify_MailingAddress>;
  /** The list of errors that occurred from executing the mutation. */
  customerUserErrors: Array<Shopify_CustomerUserError>;
  /** The list of errors that occurred from executing the mutation. */
  userErrors: Array<Shopify_UserError>;
};

/** Return type for `customerAddressDelete` mutation. */
export type Shopify_CustomerAddressDeletePayload = {
  __typename?: 'shopify_CustomerAddressDeletePayload';
  /** The list of errors that occurred from executing the mutation. */
  customerUserErrors: Array<Shopify_CustomerUserError>;
  /** ID of the deleted customer address. */
  deletedCustomerAddressId: Maybe<Scalars['String']>;
  /** The list of errors that occurred from executing the mutation. */
  userErrors: Array<Shopify_UserError>;
};

/** Return type for `customerAddressUpdate` mutation. */
export type Shopify_CustomerAddressUpdatePayload = {
  __typename?: 'shopify_CustomerAddressUpdatePayload';
  /** The customers updated mailing address. */
  customerAddress: Maybe<Shopify_MailingAddress>;
  /** The list of errors that occurred from executing the mutation. */
  customerUserErrors: Array<Shopify_CustomerUserError>;
  /** The list of errors that occurred from executing the mutation. */
  userErrors: Array<Shopify_UserError>;
};

/** The input fields to create a new customer. */
export type Shopify_CustomerCreateInput = {
  /** Indicates whether the customer has consented to be sent marketing material via email. */
  acceptsMarketing: InputMaybe<Scalars['Boolean']>;
  /** The customers email. */
  email: Scalars['String'];
  /** The customers first name. */
  firstName: InputMaybe<Scalars['String']>;
  /** The customers last name. */
  lastName: InputMaybe<Scalars['String']>;
  /** The login password used by the customer. */
  password: Scalars['String'];
  /**
   * A unique phone number for the customer.
   *
   * Formatted using E.164 standard. For example, _+16135551111_.
   *
   */
  phone: InputMaybe<Scalars['String']>;
};

/** Return type for `customerCreate` mutation. */
export type Shopify_CustomerCreatePayload = {
  __typename?: 'shopify_CustomerCreatePayload';
  /** The created customer object. */
  customer: Maybe<Shopify_Customer>;
  /** The list of errors that occurred from executing the mutation. */
  customerUserErrors: Array<Shopify_CustomerUserError>;
  /** The list of errors that occurred from executing the mutation. */
  userErrors: Array<Shopify_UserError>;
};

/** Return type for `customerDefaultAddressUpdate` mutation. */
export type Shopify_CustomerDefaultAddressUpdatePayload = {
  __typename?: 'shopify_CustomerDefaultAddressUpdatePayload';
  /** The updated customer object. */
  customer: Maybe<Shopify_Customer>;
  /** The list of errors that occurred from executing the mutation. */
  customerUserErrors: Array<Shopify_CustomerUserError>;
  /** The list of errors that occurred from executing the mutation. */
  userErrors: Array<Shopify_UserError>;
};

/** Possible error codes that can be returned by `CustomerUserError`. */
export enum Shopify_CustomerErrorCode {
  /** Customer already enabled. */
  AlreadyEnabled = 'ALREADY_ENABLED',
  /** Input email contains an invalid domain name. */
  BadDomain = 'BAD_DOMAIN',
  /** The input value is blank. */
  Blank = 'BLANK',
  /** Input contains HTML tags. */
  ContainsHtmlTags = 'CONTAINS_HTML_TAGS',
  /** Input contains URL. */
  ContainsUrl = 'CONTAINS_URL',
  /** Customer is disabled. */
  CustomerDisabled = 'CUSTOMER_DISABLED',
  /** The input value is invalid. */
  Invalid = 'INVALID',
  /** Multipass token is not valid. */
  InvalidMultipassRequest = 'INVALID_MULTIPASS_REQUEST',
  /** Address does not exist. */
  NotFound = 'NOT_FOUND',
  /** Input password starts or ends with whitespace. */
  PasswordStartsOrEndsWithWhitespace = 'PASSWORD_STARTS_OR_ENDS_WITH_WHITESPACE',
  /** The input value is already taken. */
  Taken = 'TAKEN',
  /** Invalid activation token. */
  TokenInvalid = 'TOKEN_INVALID',
  /** The input value is too long. */
  TooLong = 'TOO_LONG',
  /** The input value is too short. */
  TooShort = 'TOO_SHORT',
  /** Unidentified customer. */
  UnidentifiedCustomer = 'UNIDENTIFIED_CUSTOMER',
}

/** Return type for `customerRecover` mutation. */
export type Shopify_CustomerRecoverPayload = {
  __typename?: 'shopify_CustomerRecoverPayload';
  /** The list of errors that occurred from executing the mutation. */
  customerUserErrors: Array<Shopify_CustomerUserError>;
  /** The list of errors that occurred from executing the mutation. */
  userErrors: Array<Shopify_UserError>;
};

/** Return type for `customerResetByUrl` mutation. */
export type Shopify_CustomerResetByUrlPayload = {
  __typename?: 'shopify_CustomerResetByUrlPayload';
  /** The customer object which was reset. */
  customer: Maybe<Shopify_Customer>;
  /** A newly created customer access token object for the customer. */
  customerAccessToken: Maybe<Shopify_CustomerAccessToken>;
  /** The list of errors that occurred from executing the mutation. */
  customerUserErrors: Array<Shopify_CustomerUserError>;
  /** The list of errors that occurred from executing the mutation. */
  userErrors: Array<Shopify_UserError>;
};

/** The input fields to reset a customer's password. */
export type Shopify_CustomerResetInput = {
  /** New password that will be set as part of the reset password process. */
  password: Scalars['String'];
  /** The reset token required to reset the customers password. */
  resetToken: Scalars['String'];
};

/** Return type for `customerReset` mutation. */
export type Shopify_CustomerResetPayload = {
  __typename?: 'shopify_CustomerResetPayload';
  /** The customer object which was reset. */
  customer: Maybe<Shopify_Customer>;
  /** A newly created customer access token object for the customer. */
  customerAccessToken: Maybe<Shopify_CustomerAccessToken>;
  /** The list of errors that occurred from executing the mutation. */
  customerUserErrors: Array<Shopify_CustomerUserError>;
  /** The list of errors that occurred from executing the mutation. */
  userErrors: Array<Shopify_UserError>;
};

/** The input fields to update the Customer information. */
export type Shopify_CustomerUpdateInput = {
  /** Indicates whether the customer has consented to be sent marketing material via email. */
  acceptsMarketing: InputMaybe<Scalars['Boolean']>;
  /** The customers email. */
  email: InputMaybe<Scalars['String']>;
  /** The customers first name. */
  firstName: InputMaybe<Scalars['String']>;
  /** The customers last name. */
  lastName: InputMaybe<Scalars['String']>;
  /** The login password used by the customer. */
  password: InputMaybe<Scalars['String']>;
  /**
   * A unique phone number for the customer.
   *
   * Formatted using E.164 standard. For example, _+16135551111_. To remove the phone number, specify `null`.
   *
   */
  phone: InputMaybe<Scalars['String']>;
};

/** Return type for `customerUpdate` mutation. */
export type Shopify_CustomerUpdatePayload = {
  __typename?: 'shopify_CustomerUpdatePayload';
  /** The updated customer object. */
  customer: Maybe<Shopify_Customer>;
  /**
   * The newly created customer access token. If the customer's password is updated, all previous access tokens
   * (including the one used to perform this mutation) become invalid, and a new token is generated.
   *
   */
  customerAccessToken: Maybe<Shopify_CustomerAccessToken>;
  /** The list of errors that occurred from executing the mutation. */
  customerUserErrors: Array<Shopify_CustomerUserError>;
  /** The list of errors that occurred from executing the mutation. */
  userErrors: Array<Shopify_UserError>;
};

/** Represents an error that happens during execution of a customer mutation. */
export type Shopify_CustomerUserError = Shopify_DisplayableError & {
  __typename?: 'shopify_CustomerUserError';
  /** The error code. */
  code: Maybe<Shopify_CustomerErrorCode>;
  /** The path to the input field that caused the error. */
  field: Maybe<Array<Scalars['String']>>;
  /** The error message. */
  message: Scalars['String'];
};

/** A delivery address of the buyer that is interacting with the cart. */
export type Shopify_DeliveryAddress = Shopify_MailingAddress;

/**
 * The input fields for delivery address preferences.
 *
 */
export type Shopify_DeliveryAddressInput = {
  /**
   * The ID of a customer address that is associated with the buyer that is interacting with the cart.
   *
   */
  customerAddressId: InputMaybe<Scalars['ID']>;
  /** A delivery address preference of a buyer that is interacting with the cart. */
  deliveryAddress: InputMaybe<Shopify_MailingAddressInput>;
};

/** List of different delivery method types. */
export enum Shopify_DeliveryMethodType {
  /** Local Delivery. */
  Local = 'LOCAL',
  /** None. */
  None = 'NONE',
  /** Shipping to a Pickup Point. */
  PickupPoint = 'PICKUP_POINT',
  /** Local Pickup. */
  PickUp = 'PICK_UP',
  /** Retail. */
  Retail = 'RETAIL',
  /** Shipping. */
  Shipping = 'SHIPPING',
}

/** Digital wallet, such as Apple Pay, which can be used for accelerated checkouts. */
export enum Shopify_DigitalWallet {
  /** Android Pay. */
  AndroidPay = 'ANDROID_PAY',
  /** Apple Pay. */
  ApplePay = 'APPLE_PAY',
  /** Google Pay. */
  GooglePay = 'GOOGLE_PAY',
  /** Shopify Pay. */
  ShopifyPay = 'SHOPIFY_PAY',
}

/**
 * An amount discounting the line that has been allocated by a discount.
 *
 */
export type Shopify_DiscountAllocation = {
  __typename?: 'shopify_DiscountAllocation';
  /** Amount of discount allocated. */
  allocatedAmount: Shopify_MoneyV2;
  /** The discount this allocated amount originated from. */
  discountApplication: Shopify_DiscountApplication;
};

/**
 * Discount applications capture the intentions of a discount source at
 * the time of application.
 *
 */
export type Shopify_DiscountApplication = {
  /** The method by which the discount's value is allocated to its entitled items. */
  allocationMethod: Shopify_DiscountApplicationAllocationMethod;
  /** Which lines of targetType that the discount is allocated over. */
  targetSelection: Shopify_DiscountApplicationTargetSelection;
  /** The type of line that the discount is applicable towards. */
  targetType: Shopify_DiscountApplicationTargetType;
  /** The value of the discount application. */
  value: Shopify_PricingValue;
};

/** The method by which the discount's value is allocated onto its entitled lines. */
export enum Shopify_DiscountApplicationAllocationMethod {
  /** The value is spread across all entitled lines. */
  Across = 'ACROSS',
  /** The value is applied onto every entitled line. */
  Each = 'EACH',
  /** The value is specifically applied onto a particular line. */
  One = 'ONE',
}

/**
 * An auto-generated type for paginating through multiple DiscountApplications.
 *
 */
export type Shopify_DiscountApplicationConnection = {
  __typename?: 'shopify_DiscountApplicationConnection';
  /** A list of edges. */
  edges: Array<Shopify_DiscountApplicationEdge>;
  /** A list of the nodes contained in DiscountApplicationEdge. */
  nodes: Array<Shopify_DiscountApplication>;
  /** Information to aid in pagination. */
  pageInfo: Shopify_PageInfo;
};

/**
 * An auto-generated type which holds one DiscountApplication and a cursor during pagination.
 *
 */
export type Shopify_DiscountApplicationEdge = {
  __typename?: 'shopify_DiscountApplicationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of DiscountApplicationEdge. */
  node: Shopify_DiscountApplication;
};

/**
 * The lines on the order to which the discount is applied, of the type defined by
 * the discount application's `targetType`. For example, the value `ENTITLED`, combined with a `targetType` of
 * `LINE_ITEM`, applies the discount on all line items that are entitled to the discount.
 * The value `ALL`, combined with a `targetType` of `SHIPPING_LINE`, applies the discount on all shipping lines.
 *
 */
export enum Shopify_DiscountApplicationTargetSelection {
  /** The discount is allocated onto all the lines. */
  All = 'ALL',
  /** The discount is allocated onto only the lines that it's entitled for. */
  Entitled = 'ENTITLED',
  /** The discount is allocated onto explicitly chosen lines. */
  Explicit = 'EXPLICIT',
}

/**
 * The type of line (i.e. line item or shipping line) on an order that the discount is applicable towards.
 *
 */
export enum Shopify_DiscountApplicationTargetType {
  /** The discount applies onto line items. */
  LineItem = 'LINE_ITEM',
  /** The discount applies onto shipping lines. */
  ShippingLine = 'SHIPPING_LINE',
}

/**
 * Discount code applications capture the intentions of a discount code at
 * the time that it is applied.
 *
 */
export type Shopify_DiscountCodeApplication = Shopify_DiscountApplication & {
  __typename?: 'shopify_DiscountCodeApplication';
  /** The method by which the discount's value is allocated to its entitled items. */
  allocationMethod: Shopify_DiscountApplicationAllocationMethod;
  /** Specifies whether the discount code was applied successfully. */
  applicable: Scalars['Boolean'];
  /** The string identifying the discount code that was used at the time of application. */
  code: Scalars['String'];
  /** Which lines of targetType that the discount is allocated over. */
  targetSelection: Shopify_DiscountApplicationTargetSelection;
  /** The type of line that the discount is applicable towards. */
  targetType: Shopify_DiscountApplicationTargetType;
  /** The value of the discount application. */
  value: Shopify_PricingValue;
};

/** Represents an error in the input of a mutation. */
export type Shopify_DisplayableError = {
  /** The path to the input field that caused the error. */
  field: Maybe<Array<Scalars['String']>>;
  /** The error message. */
  message: Scalars['String'];
};

/** Represents a web address. */
export type Shopify_Domain = {
  __typename?: 'shopify_Domain';
  /** The host name of the domain (eg: `example.com`). */
  host: Scalars['String'];
  /** Whether SSL is enabled or not. */
  sslEnabled: Scalars['Boolean'];
  /** The URL of the domain (eg: `https://example.com`). */
  url: Scalars['shopify_URL'];
};

/** Represents a video hosted outside of Shopify. */
export type Shopify_ExternalVideo = Shopify_Media &
  Shopify_Node & {
    __typename?: 'shopify_ExternalVideo';
    /** A word or phrase to share the nature or contents of a media. */
    alt: Maybe<Scalars['String']>;
    /** The embed URL of the video for the respective host. */
    embedUrl: Scalars['shopify_URL'];
    /** The URL. */
    embeddedUrl: Scalars['shopify_URL'];
    /** The host of the external video. */
    host: Shopify_MediaHost;
    /** A globally-unique ID. */
    id: Scalars['ID'];
    /** The media content type. */
    mediaContentType: Shopify_MediaContentType;
    /** The origin URL of the video on the respective host. */
    originUrl: Scalars['shopify_URL'];
    /** The presentation for a media. */
    presentation: Maybe<Shopify_MediaPresentation>;
    /** The preview image for the media. */
    previewImage: Maybe<Shopify_Image>;
  };

/** A filter that is supported on the parent field. */
export type Shopify_Filter = {
  __typename?: 'shopify_Filter';
  /** A unique identifier. */
  id: Scalars['String'];
  /** A human-friendly string for this filter. */
  label: Scalars['String'];
  /** An enumeration that denotes the type of data this filter represents. */
  type: Shopify_FilterType;
  /** The list of values for this filter. */
  values: Array<Shopify_FilterValue>;
};

/**
 * The type of data that the filter group represents.
 *
 * For more information, refer to [Filter products in a collection with the Storefront API]
 * (https://shopify.dev/custom-storefronts/products-collections/filter-products).
 *
 */
export enum Shopify_FilterType {
  /** A boolean value. */
  Boolean = 'BOOLEAN',
  /** A list of selectable values. */
  List = 'LIST',
  /** A range of prices. */
  PriceRange = 'PRICE_RANGE',
}

/** A selectable value within a filter. */
export type Shopify_FilterValue = {
  __typename?: 'shopify_FilterValue';
  /** The number of results that match this filter value. */
  count: Scalars['Int'];
  /** A unique identifier. */
  id: Scalars['String'];
  /**
   * An input object that can be used to filter by this value on the parent field.
   *
   * The value is provided as a helper for building dynamic filtering UI. For
   * example, if you have a list of selected `FilterValue` objects, you can combine
   * their respective `input` values to use in a subsequent query.
   *
   */
  input: Scalars['shopify_JSON'];
  /** A human-friendly string for this filter value. */
  label: Scalars['String'];
};

/** Represents a single fulfillment in an order. */
export type Shopify_Fulfillment = {
  __typename?: 'shopify_Fulfillment';
  /** List of the fulfillment's line items. */
  fulfillmentLineItems: Shopify_FulfillmentLineItemConnection;
  /** The name of the tracking company. */
  trackingCompany: Maybe<Scalars['String']>;
  /**
   * Tracking information associated with the fulfillment,
   * such as the tracking number and tracking URL.
   *
   */
  trackingInfo: Array<Shopify_FulfillmentTrackingInfo>;
};

/** Represents a single fulfillment in an order. */
export type Shopify_FulfillmentFulfillmentLineItemsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  reverse?: InputMaybe<Scalars['Boolean']>;
};

/** Represents a single fulfillment in an order. */
export type Shopify_FulfillmentTrackingInfoArgs = {
  first: InputMaybe<Scalars['Int']>;
};

/** Represents a single line item in a fulfillment. There is at most one fulfillment line item for each order line item. */
export type Shopify_FulfillmentLineItem = {
  __typename?: 'shopify_FulfillmentLineItem';
  /** The associated order's line item. */
  lineItem: Shopify_OrderLineItem;
  /** The amount fulfilled in this fulfillment. */
  quantity: Scalars['Int'];
};

/**
 * An auto-generated type for paginating through multiple FulfillmentLineItems.
 *
 */
export type Shopify_FulfillmentLineItemConnection = {
  __typename?: 'shopify_FulfillmentLineItemConnection';
  /** A list of edges. */
  edges: Array<Shopify_FulfillmentLineItemEdge>;
  /** A list of the nodes contained in FulfillmentLineItemEdge. */
  nodes: Array<Shopify_FulfillmentLineItem>;
  /** Information to aid in pagination. */
  pageInfo: Shopify_PageInfo;
};

/**
 * An auto-generated type which holds one FulfillmentLineItem and a cursor during pagination.
 *
 */
export type Shopify_FulfillmentLineItemEdge = {
  __typename?: 'shopify_FulfillmentLineItemEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of FulfillmentLineItemEdge. */
  node: Shopify_FulfillmentLineItem;
};

/** Tracking information associated with the fulfillment. */
export type Shopify_FulfillmentTrackingInfo = {
  __typename?: 'shopify_FulfillmentTrackingInfo';
  /** The tracking number of the fulfillment. */
  number: Maybe<Scalars['String']>;
  /** The URL to track the fulfillment. */
  url: Maybe<Scalars['shopify_URL']>;
};

/** The generic file resource lets you manage files in a merchants store. Generic files include any file that doesnt fit into a designated type such as image or video. Example: PDF, JSON. */
export type Shopify_GenericFile = Shopify_Node & {
  __typename?: 'shopify_GenericFile';
  /** A word or phrase to indicate the contents of a file. */
  alt: Maybe<Scalars['String']>;
  /** A globally-unique ID. */
  id: Scalars['ID'];
  /** The MIME type of the file. */
  mimeType: Maybe<Scalars['String']>;
  /** The size of the original file in bytes. */
  originalFileSize: Maybe<Scalars['Int']>;
  /** The preview image for the file. */
  previewImage: Maybe<Shopify_Image>;
  /** The URL of the file. */
  url: Maybe<Scalars['shopify_URL']>;
};

/** The input fields used to specify a geographical location. */
export type Shopify_GeoCoordinateInput = {
  /** The coordinate's latitude value. */
  latitude: Scalars['Float'];
  /** The coordinate's longitude value. */
  longitude: Scalars['Float'];
};

/** Represents information about the metafields associated to the specified resource. */
export type Shopify_HasMetafields = {
  /** Returns a metafield found by namespace and key. */
  metafield: Maybe<Shopify_Metafield>;
  /** The metafields associated with the resource matching the supplied list of namespaces and keys. */
  metafields: Array<Maybe<Shopify_Metafield>>;
};

/** Represents information about the metafields associated to the specified resource. */
export type Shopify_HasMetafieldsMetafieldArgs = {
  key: Scalars['String'];
  namespace: Scalars['String'];
};

/** Represents information about the metafields associated to the specified resource. */
export type Shopify_HasMetafieldsMetafieldsArgs = {
  identifiers: Array<Shopify_HasMetafieldsIdentifier>;
};

/** The input fields to identify a metafield on an owner resource by namespace and key. */
export type Shopify_HasMetafieldsIdentifier = {
  /** The identifier for the metafield. */
  key: Scalars['String'];
  /** The container the metafield belongs to. */
  namespace: Scalars['String'];
};

/** Represents an image resource. */
export type Shopify_Image = {
  __typename?: 'shopify_Image';
  /** A word or phrase to share the nature or contents of an image. */
  altText: Maybe<Scalars['String']>;
  /** The original height of the image in pixels. Returns `null` if the image isn't hosted by Shopify. */
  height: Maybe<Scalars['Int']>;
  /** A unique ID for the image. */
  id: Maybe<Scalars['ID']>;
  /**
   * The location of the original image as a URL.
   *
   * If there are any existing transformations in the original source URL, they will remain and not be stripped.
   *
   */
  originalSrc: Scalars['shopify_URL'];
  /** The location of the image as a URL. */
  src: Scalars['shopify_URL'];
  /**
   * The location of the transformed image as a URL.
   *
   * All transformation arguments are considered "best-effort". If they can be applied to an image, they will be.
   * Otherwise any transformations which an image type doesn't support will be ignored.
   *
   */
  transformedSrc: Scalars['shopify_URL'];
  /**
   * The location of the image as a URL.
   *
   * If no transform options are specified, then the original image will be preserved including any pre-applied transforms.
   *
   * All transformation options are considered "best-effort". Any transformation that the original image type doesn't support will be ignored.
   *
   * If you need multiple variations of the same image, then you can use [GraphQL aliases](https://graphql.org/learn/queries/#aliases).
   *
   */
  url: Scalars['shopify_URL'];
  /** The original width of the image in pixels. Returns `null` if the image isn't hosted by Shopify. */
  width: Maybe<Scalars['Int']>;
};

/** Represents an image resource. */
export type Shopify_ImageTransformedSrcArgs = {
  crop: InputMaybe<Shopify_CropRegion>;
  maxHeight: InputMaybe<Scalars['Int']>;
  maxWidth: InputMaybe<Scalars['Int']>;
  preferredContentType: InputMaybe<Shopify_ImageContentType>;
  scale?: InputMaybe<Scalars['Int']>;
};

/** Represents an image resource. */
export type Shopify_ImageUrlArgs = {
  transform: InputMaybe<Shopify_ImageTransformInput>;
};

/**
 * An auto-generated type for paginating through multiple Images.
 *
 */
export type Shopify_ImageConnection = {
  __typename?: 'shopify_ImageConnection';
  /** A list of edges. */
  edges: Array<Shopify_ImageEdge>;
  /** A list of the nodes contained in ImageEdge. */
  nodes: Array<Shopify_Image>;
  /** Information to aid in pagination. */
  pageInfo: Shopify_PageInfo;
};

/** List of supported image content types. */
export enum Shopify_ImageContentType {
  /** A JPG image. */
  Jpg = 'JPG',
  /** A PNG image. */
  Png = 'PNG',
  /** A WEBP image. */
  Webp = 'WEBP',
}

/**
 * An auto-generated type which holds one Image and a cursor during pagination.
 *
 */
export type Shopify_ImageEdge = {
  __typename?: 'shopify_ImageEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of ImageEdge. */
  node: Shopify_Image;
};

/**
 * The available options for transforming an image.
 *
 * All transformation options are considered best effort. Any transformation that
 * the original image type doesn't support will be ignored.
 *
 */
export type Shopify_ImageTransformInput = {
  /**
   * The region of the image to remain after cropping.
   * Must be used in conjunction with the `maxWidth` and/or `maxHeight` fields,
   * where the `maxWidth` and `maxHeight` aren't equal.
   * The `crop` argument should coincide with the smaller value. A smaller `maxWidth` indicates a `LEFT` or `RIGHT` crop, while
   * a smaller `maxHeight` indicates a `TOP` or `BOTTOM` crop. For example, `{
   * maxWidth: 5, maxHeight: 10, crop: LEFT }` will result
   * in an image with a width of 5 and height of 10, where the right side of the image is removed.
   *
   */
  crop: InputMaybe<Shopify_CropRegion>;
  /**
   * Image height in pixels between 1 and 5760.
   *
   */
  maxHeight: InputMaybe<Scalars['Int']>;
  /**
   * Image width in pixels between 1 and 5760.
   *
   */
  maxWidth: InputMaybe<Scalars['Int']>;
  /**
   * Convert the source image into the preferred content type.
   * Supported conversions: `.svg` to `.png`, any file type to `.jpg`, and any file type to `.webp`.
   *
   */
  preferredContentType: InputMaybe<Shopify_ImageContentType>;
  /**
   * Image size multiplier for high-resolution retina displays. Must be within 1..3.
   *
   */
  scale: InputMaybe<Scalars['Int']>;
};

/** A language. */
export type Shopify_Language = {
  __typename?: 'shopify_Language';
  /** The name of the language in the language itself. If the language uses capitalization, it is capitalized for a mid-sentence position. */
  endonymName: Scalars['String'];
  /** The ISO code. */
  isoCode: Shopify_LanguageCode;
  /** The name of the language in the current language. */
  name: Scalars['String'];
};

/** ISO 639-1 language codes supported by Shopify. */
export enum Shopify_LanguageCode {
  /** Afrikaans. */
  Af = 'AF',
  /** Akan. */
  Ak = 'AK',
  /** Amharic. */
  Am = 'AM',
  /** Arabic. */
  Ar = 'AR',
  /** Assamese. */
  As = 'AS',
  /** Azerbaijani. */
  Az = 'AZ',
  /** Belarusian. */
  Be = 'BE',
  /** Bulgarian. */
  Bg = 'BG',
  /** Bambara. */
  Bm = 'BM',
  /** Bangla. */
  Bn = 'BN',
  /** Tibetan. */
  Bo = 'BO',
  /** Breton. */
  Br = 'BR',
  /** Bosnian. */
  Bs = 'BS',
  /** Catalan. */
  Ca = 'CA',
  /** Chechen. */
  Ce = 'CE',
  /** Central Kurdish. */
  Ckb = 'CKB',
  /** Czech. */
  Cs = 'CS',
  /** Church Slavic. */
  Cu = 'CU',
  /** Welsh. */
  Cy = 'CY',
  /** Danish. */
  Da = 'DA',
  /** German. */
  De = 'DE',
  /** Dzongkha. */
  Dz = 'DZ',
  /** Ewe. */
  Ee = 'EE',
  /** Greek. */
  El = 'EL',
  /** English. */
  En = 'EN',
  /** Esperanto. */
  Eo = 'EO',
  /** Spanish. */
  Es = 'ES',
  /** Estonian. */
  Et = 'ET',
  /** Basque. */
  Eu = 'EU',
  /** Persian. */
  Fa = 'FA',
  /** Fulah. */
  Ff = 'FF',
  /** Finnish. */
  Fi = 'FI',
  /** Filipino. */
  Fil = 'FIL',
  /** Faroese. */
  Fo = 'FO',
  /** French. */
  Fr = 'FR',
  /** Western Frisian. */
  Fy = 'FY',
  /** Irish. */
  Ga = 'GA',
  /** Scottish Gaelic. */
  Gd = 'GD',
  /** Galician. */
  Gl = 'GL',
  /** Gujarati. */
  Gu = 'GU',
  /** Manx. */
  Gv = 'GV',
  /** Hausa. */
  Ha = 'HA',
  /** Hebrew. */
  He = 'HE',
  /** Hindi. */
  Hi = 'HI',
  /** Croatian. */
  Hr = 'HR',
  /** Hungarian. */
  Hu = 'HU',
  /** Armenian. */
  Hy = 'HY',
  /** Interlingua. */
  Ia = 'IA',
  /** Indonesian. */
  Id = 'ID',
  /** Igbo. */
  Ig = 'IG',
  /** Sichuan Yi. */
  Ii = 'II',
  /** Icelandic. */
  Is = 'IS',
  /** Italian. */
  It = 'IT',
  /** Japanese. */
  Ja = 'JA',
  /** Javanese. */
  Jv = 'JV',
  /** Georgian. */
  Ka = 'KA',
  /** Kikuyu. */
  Ki = 'KI',
  /** Kazakh. */
  Kk = 'KK',
  /** Kalaallisut. */
  Kl = 'KL',
  /** Khmer. */
  Km = 'KM',
  /** Kannada. */
  Kn = 'KN',
  /** Korean. */
  Ko = 'KO',
  /** Kashmiri. */
  Ks = 'KS',
  /** Kurdish. */
  Ku = 'KU',
  /** Cornish. */
  Kw = 'KW',
  /** Kyrgyz. */
  Ky = 'KY',
  /** Latin. */
  La = 'LA',
  /** Luxembourgish. */
  Lb = 'LB',
  /** Ganda. */
  Lg = 'LG',
  /** Lingala. */
  Ln = 'LN',
  /** Lao. */
  Lo = 'LO',
  /** Lithuanian. */
  Lt = 'LT',
  /** Luba-Katanga. */
  Lu = 'LU',
  /** Latvian. */
  Lv = 'LV',
  /** Malagasy. */
  Mg = 'MG',
  /** Mori. */
  Mi = 'MI',
  /** Macedonian. */
  Mk = 'MK',
  /** Malayalam. */
  Ml = 'ML',
  /** Mongolian. */
  Mn = 'MN',
  /** Moldavian. */
  Mo = 'MO',
  /** Marathi. */
  Mr = 'MR',
  /** Malay. */
  Ms = 'MS',
  /** Maltese. */
  Mt = 'MT',
  /** Burmese. */
  My = 'MY',
  /** Norwegian (Bokml). */
  Nb = 'NB',
  /** North Ndebele. */
  Nd = 'ND',
  /** Nepali. */
  Ne = 'NE',
  /** Dutch. */
  Nl = 'NL',
  /** Norwegian Nynorsk. */
  Nn = 'NN',
  /** Norwegian. */
  No = 'NO',
  /** Oromo. */
  Om = 'OM',
  /** Odia. */
  Or = 'OR',
  /** Ossetic. */
  Os = 'OS',
  /** Punjabi. */
  Pa = 'PA',
  /** Polish. */
  Pl = 'PL',
  /** Pashto. */
  Ps = 'PS',
  /** Portuguese. */
  Pt = 'PT',
  /** Portuguese (Brazil). */
  PtBr = 'PT_BR',
  /** Portuguese (Portugal). */
  PtPt = 'PT_PT',
  /** Quechua. */
  Qu = 'QU',
  /** Romansh. */
  Rm = 'RM',
  /** Rundi. */
  Rn = 'RN',
  /** Romanian. */
  Ro = 'RO',
  /** Russian. */
  Ru = 'RU',
  /** Kinyarwanda. */
  Rw = 'RW',
  /** Sanskrit. */
  Sa = 'SA',
  /** Sardinian. */
  Sc = 'SC',
  /** Sindhi. */
  Sd = 'SD',
  /** Northern Sami. */
  Se = 'SE',
  /** Sango. */
  Sg = 'SG',
  /** Serbo-Croatian. */
  Sh = 'SH',
  /** Sinhala. */
  Si = 'SI',
  /** Slovak. */
  Sk = 'SK',
  /** Slovenian. */
  Sl = 'SL',
  /** Shona. */
  Sn = 'SN',
  /** Somali. */
  So = 'SO',
  /** Albanian. */
  Sq = 'SQ',
  /** Serbian. */
  Sr = 'SR',
  /** Sundanese. */
  Su = 'SU',
  /** Swedish. */
  Sv = 'SV',
  /** Swahili. */
  Sw = 'SW',
  /** Tamil. */
  Ta = 'TA',
  /** Telugu. */
  Te = 'TE',
  /** Tajik. */
  Tg = 'TG',
  /** Thai. */
  Th = 'TH',
  /** Tigrinya. */
  Ti = 'TI',
  /** Turkmen. */
  Tk = 'TK',
  /** Tongan. */
  To = 'TO',
  /** Turkish. */
  Tr = 'TR',
  /** Tatar. */
  Tt = 'TT',
  /** Uyghur. */
  Ug = 'UG',
  /** Ukrainian. */
  Uk = 'UK',
  /** Urdu. */
  Ur = 'UR',
  /** Uzbek. */
  Uz = 'UZ',
  /** Vietnamese. */
  Vi = 'VI',
  /** Volapk. */
  Vo = 'VO',
  /** Wolof. */
  Wo = 'WO',
  /** Xhosa. */
  Xh = 'XH',
  /** Yiddish. */
  Yi = 'YI',
  /** Yoruba. */
  Yo = 'YO',
  /** Chinese. */
  Zh = 'ZH',
  /** Chinese (Simplified). */
  ZhCn = 'ZH_CN',
  /** Chinese (Traditional). */
  ZhTw = 'ZH_TW',
  /** Zulu. */
  Zu = 'ZU',
}

/** Information about the localized experiences configured for the shop. */
export type Shopify_Localization = {
  __typename?: 'shopify_Localization';
  /** The list of countries with enabled localized experiences. */
  availableCountries: Array<Shopify_Country>;
  /** The list of languages available for the active country. */
  availableLanguages: Array<Shopify_Language>;
  /** The country of the active localized experience. Use the `@inContext` directive to change this value. */
  country: Shopify_Country;
  /** The language of the active localized experience. Use the `@inContext` directive to change this value. */
  language: Shopify_Language;
  /** The market including the country of the active localized experience. Use the `@inContext` directive to change this value. */
  market: Shopify_Market;
};

/** Represents a location where product inventory is held. */
export type Shopify_Location = Shopify_HasMetafields &
  Shopify_Node & {
    __typename?: 'shopify_Location';
    /** The address of the location. */
    address: Shopify_LocationAddress;
    /** A globally-unique ID. */
    id: Scalars['ID'];
    /** Returns a metafield found by namespace and key. */
    metafield: Maybe<Shopify_Metafield>;
    /** The metafields associated with the resource matching the supplied list of namespaces and keys. */
    metafields: Array<Maybe<Shopify_Metafield>>;
    /** The name of the location. */
    name: Scalars['String'];
  };

/** Represents a location where product inventory is held. */
export type Shopify_LocationMetafieldArgs = {
  key: Scalars['String'];
  namespace: Scalars['String'];
};

/** Represents a location where product inventory is held. */
export type Shopify_LocationMetafieldsArgs = {
  identifiers: Array<Shopify_HasMetafieldsIdentifier>;
};

/**
 * Represents the address of a location.
 *
 */
export type Shopify_LocationAddress = {
  __typename?: 'shopify_LocationAddress';
  /** The first line of the address for the location. */
  address1: Maybe<Scalars['String']>;
  /** The second line of the address for the location. */
  address2: Maybe<Scalars['String']>;
  /** The city of the location. */
  city: Maybe<Scalars['String']>;
  /** The country of the location. */
  country: Maybe<Scalars['String']>;
  /** The country code of the location. */
  countryCode: Maybe<Scalars['String']>;
  /** A formatted version of the address for the location. */
  formatted: Array<Scalars['String']>;
  /** The latitude coordinates of the location. */
  latitude: Maybe<Scalars['Float']>;
  /** The longitude coordinates of the location. */
  longitude: Maybe<Scalars['Float']>;
  /** The phone number of the location. */
  phone: Maybe<Scalars['String']>;
  /** The province of the location. */
  province: Maybe<Scalars['String']>;
  /**
   * The code for the province, state, or district of the address of the location.
   *
   */
  provinceCode: Maybe<Scalars['String']>;
  /** The ZIP code of the location. */
  zip: Maybe<Scalars['String']>;
};

/**
 * An auto-generated type for paginating through multiple Locations.
 *
 */
export type Shopify_LocationConnection = {
  __typename?: 'shopify_LocationConnection';
  /** A list of edges. */
  edges: Array<Shopify_LocationEdge>;
  /** A list of the nodes contained in LocationEdge. */
  nodes: Array<Shopify_Location>;
  /** Information to aid in pagination. */
  pageInfo: Shopify_PageInfo;
};

/**
 * An auto-generated type which holds one Location and a cursor during pagination.
 *
 */
export type Shopify_LocationEdge = {
  __typename?: 'shopify_LocationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of LocationEdge. */
  node: Shopify_Location;
};

/** The set of valid sort keys for the Location query. */
export enum Shopify_LocationSortKeys {
  /** Sort by the `city` value. */
  City = 'CITY',
  /** Sort by the `distance` value. */
  Distance = 'DISTANCE',
  /** Sort by the `id` value. */
  Id = 'ID',
  /** Sort by the `name` value. */
  Name = 'NAME',
}

/** Represents a mailing address for customers and shipping. */
export type Shopify_MailingAddress = Shopify_Node & {
  __typename?: 'shopify_MailingAddress';
  /** The first line of the address. Typically the street address or PO Box number. */
  address1: Maybe<Scalars['String']>;
  /**
   * The second line of the address. Typically the number of the apartment, suite, or unit.
   *
   */
  address2: Maybe<Scalars['String']>;
  /** The name of the city, district, village, or town. */
  city: Maybe<Scalars['String']>;
  /** The name of the customer's company or organization. */
  company: Maybe<Scalars['String']>;
  /** The name of the country. */
  country: Maybe<Scalars['String']>;
  /**
   * The two-letter code for the country of the address.
   *
   * For example, US.
   *
   */
  countryCode: Maybe<Scalars['String']>;
  /**
   * The two-letter code for the country of the address.
   *
   * For example, US.
   *
   */
  countryCodeV2: Maybe<Shopify_CountryCode>;
  /** The first name of the customer. */
  firstName: Maybe<Scalars['String']>;
  /** A formatted version of the address, customized by the provided arguments. */
  formatted: Array<Scalars['String']>;
  /** A comma-separated list of the values for city, province, and country. */
  formattedArea: Maybe<Scalars['String']>;
  /** A globally-unique ID. */
  id: Scalars['ID'];
  /** The last name of the customer. */
  lastName: Maybe<Scalars['String']>;
  /** The latitude coordinate of the customer address. */
  latitude: Maybe<Scalars['Float']>;
  /** The longitude coordinate of the customer address. */
  longitude: Maybe<Scalars['Float']>;
  /** The full name of the customer, based on firstName and lastName. */
  name: Maybe<Scalars['String']>;
  /**
   * A unique phone number for the customer.
   *
   * Formatted using E.164 standard. For example, _+16135551111_.
   *
   */
  phone: Maybe<Scalars['String']>;
  /** The region of the address, such as the province, state, or district. */
  province: Maybe<Scalars['String']>;
  /**
   * The two-letter code for the region.
   *
   * For example, ON.
   *
   */
  provinceCode: Maybe<Scalars['String']>;
  /** The zip or postal code of the address. */
  zip: Maybe<Scalars['String']>;
};

/** Represents a mailing address for customers and shipping. */
export type Shopify_MailingAddressFormattedArgs = {
  withCompany?: InputMaybe<Scalars['Boolean']>;
  withName?: InputMaybe<Scalars['Boolean']>;
};

/**
 * An auto-generated type for paginating through multiple MailingAddresses.
 *
 */
export type Shopify_MailingAddressConnection = {
  __typename?: 'shopify_MailingAddressConnection';
  /** A list of edges. */
  edges: Array<Shopify_MailingAddressEdge>;
  /** A list of the nodes contained in MailingAddressEdge. */
  nodes: Array<Shopify_MailingAddress>;
  /** Information to aid in pagination. */
  pageInfo: Shopify_PageInfo;
};

/**
 * An auto-generated type which holds one MailingAddress and a cursor during pagination.
 *
 */
export type Shopify_MailingAddressEdge = {
  __typename?: 'shopify_MailingAddressEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of MailingAddressEdge. */
  node: Shopify_MailingAddress;
};

/** The input fields to create or update a mailing address. */
export type Shopify_MailingAddressInput = {
  /**
   * The first line of the address. Typically the street address or PO Box number.
   *
   */
  address1: InputMaybe<Scalars['String']>;
  /**
   * The second line of the address. Typically the number of the apartment, suite, or unit.
   *
   */
  address2: InputMaybe<Scalars['String']>;
  /**
   * The name of the city, district, village, or town.
   *
   */
  city: InputMaybe<Scalars['String']>;
  /**
   * The name of the customer's company or organization.
   *
   */
  company: InputMaybe<Scalars['String']>;
  /** The name of the country. */
  country: InputMaybe<Scalars['String']>;
  /** The first name of the customer. */
  firstName: InputMaybe<Scalars['String']>;
  /** The last name of the customer. */
  lastName: InputMaybe<Scalars['String']>;
  /**
   * A unique phone number for the customer.
   *
   * Formatted using E.164 standard. For example, _+16135551111_.
   *
   */
  phone: InputMaybe<Scalars['String']>;
  /** The region of the address, such as the province, state, or district. */
  province: InputMaybe<Scalars['String']>;
  /** The zip or postal code of the address. */
  zip: InputMaybe<Scalars['String']>;
};

/**
 * Manual discount applications capture the intentions of a discount that was manually created.
 *
 */
export type Shopify_ManualDiscountApplication = Shopify_DiscountApplication & {
  __typename?: 'shopify_ManualDiscountApplication';
  /** The method by which the discount's value is allocated to its entitled items. */
  allocationMethod: Shopify_DiscountApplicationAllocationMethod;
  /** The description of the application. */
  description: Maybe<Scalars['String']>;
  /** Which lines of targetType that the discount is allocated over. */
  targetSelection: Shopify_DiscountApplicationTargetSelection;
  /** The type of line that the discount is applicable towards. */
  targetType: Shopify_DiscountApplicationTargetType;
  /** The title of the application. */
  title: Scalars['String'];
  /** The value of the discount application. */
  value: Shopify_PricingValue;
};

/** A group of one or more regions of the world that a merchant is targeting for sales. To learn more about markets, refer to [the Shopify Markets conceptual overview](/docs/apps/markets). */
export type Shopify_Market = Shopify_HasMetafields &
  Shopify_Node & {
    __typename?: 'shopify_Market';
    /**
     * A human-readable unique string for the market automatically generated from its title.
     *
     */
    handle: Scalars['String'];
    /** A globally-unique ID. */
    id: Scalars['ID'];
    /** Returns a metafield found by namespace and key. */
    metafield: Maybe<Shopify_Metafield>;
    /** The metafields associated with the resource matching the supplied list of namespaces and keys. */
    metafields: Array<Maybe<Shopify_Metafield>>;
  };

/** A group of one or more regions of the world that a merchant is targeting for sales. To learn more about markets, refer to [the Shopify Markets conceptual overview](/docs/apps/markets). */
export type Shopify_MarketMetafieldArgs = {
  key: Scalars['String'];
  namespace: Scalars['String'];
};

/** A group of one or more regions of the world that a merchant is targeting for sales. To learn more about markets, refer to [the Shopify Markets conceptual overview](/docs/apps/markets). */
export type Shopify_MarketMetafieldsArgs = {
  identifiers: Array<Shopify_HasMetafieldsIdentifier>;
};

/** Represents a media interface. */
export type Shopify_Media = {
  /** A word or phrase to share the nature or contents of a media. */
  alt: Maybe<Scalars['String']>;
  /** The media content type. */
  mediaContentType: Shopify_MediaContentType;
  /** The presentation for a media. */
  presentation: Maybe<Shopify_MediaPresentation>;
  /** The preview image for the media. */
  previewImage: Maybe<Shopify_Image>;
};

/**
 * An auto-generated type for paginating through multiple Media.
 *
 */
export type Shopify_MediaConnection = {
  __typename?: 'shopify_MediaConnection';
  /** A list of edges. */
  edges: Array<Shopify_MediaEdge>;
  /** A list of the nodes contained in MediaEdge. */
  nodes: Array<Shopify_Media>;
  /** Information to aid in pagination. */
  pageInfo: Shopify_PageInfo;
};

/** The possible content types for a media object. */
export enum Shopify_MediaContentType {
  /** An externally hosted video. */
  ExternalVideo = 'EXTERNAL_VIDEO',
  /** A Shopify hosted image. */
  Image = 'IMAGE',
  /** A 3d model. */
  Model_3D = 'MODEL_3D',
  /** A Shopify hosted video. */
  Video = 'VIDEO',
}

/**
 * An auto-generated type which holds one Media and a cursor during pagination.
 *
 */
export type Shopify_MediaEdge = {
  __typename?: 'shopify_MediaEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of MediaEdge. */
  node: Shopify_Media;
};

/** Host for a Media Resource. */
export enum Shopify_MediaHost {
  /** Host for Vimeo embedded videos. */
  Vimeo = 'VIMEO',
  /** Host for YouTube embedded videos. */
  Youtube = 'YOUTUBE',
}

/** Represents a Shopify hosted image. */
export type Shopify_MediaImage = Shopify_Media &
  Shopify_Node & {
    __typename?: 'shopify_MediaImage';
    /** A word or phrase to share the nature or contents of a media. */
    alt: Maybe<Scalars['String']>;
    /** A globally-unique ID. */
    id: Scalars['ID'];
    /** The image for the media. */
    image: Maybe<Shopify_Image>;
    /** The media content type. */
    mediaContentType: Shopify_MediaContentType;
    /** The presentation for a media. */
    presentation: Maybe<Shopify_MediaPresentation>;
    /** The preview image for the media. */
    previewImage: Maybe<Shopify_Image>;
  };

/** A media presentation. */
export type Shopify_MediaPresentation = Shopify_Node & {
  __typename?: 'shopify_MediaPresentation';
  /** A JSON object representing a presentation view. */
  asJson: Maybe<Scalars['shopify_JSON']>;
  /** A globally-unique ID. */
  id: Scalars['ID'];
};

/** A media presentation. */
export type Shopify_MediaPresentationAsJsonArgs = {
  format: Shopify_MediaPresentationFormat;
};

/** The possible formats for a media presentation. */
export enum Shopify_MediaPresentationFormat {
  /** A media image presentation. */
  Image = 'IMAGE',
  /** A model viewer presentation. */
  ModelViewer = 'MODEL_VIEWER',
}

/**
 * A [navigation menu](https://help.shopify.com/manual/online-store/menus-and-links) representing a hierarchy
 * of hyperlinks (items).
 *
 */
export type Shopify_Menu = Shopify_Node & {
  __typename?: 'shopify_Menu';
  /** The menu's handle. */
  handle: Scalars['String'];
  /** A globally-unique ID. */
  id: Scalars['ID'];
  /** The menu's child items. */
  items: Array<Shopify_MenuItem>;
  /** The count of items on the menu. */
  itemsCount: Scalars['Int'];
  /** The menu's title. */
  title: Scalars['String'];
};

/** A menu item within a parent menu. */
export type Shopify_MenuItem = Shopify_Node & {
  __typename?: 'shopify_MenuItem';
  /** A globally-unique ID. */
  id: Scalars['ID'];
  /** The menu item's child items. */
  items: Array<Shopify_MenuItem>;
  /** The ID of the linked resource. */
  resourceId: Maybe<Scalars['ID']>;
  /** The menu item's tags to filter a collection. */
  tags: Array<Scalars['String']>;
  /** The menu item's title. */
  title: Scalars['String'];
  /** The menu item's type. */
  type: Shopify_MenuItemType;
  /** The menu item's URL. */
  url: Maybe<Scalars['shopify_URL']>;
};

/** A menu item type. */
export enum Shopify_MenuItemType {
  /** An article link. */
  Article = 'ARTICLE',
  /** A blog link. */
  Blog = 'BLOG',
  /** A catalog link. */
  Catalog = 'CATALOG',
  /** A collection link. */
  Collection = 'COLLECTION',
  /** A collection link. */
  Collections = 'COLLECTIONS',
  /** A frontpage link. */
  Frontpage = 'FRONTPAGE',
  /** An http link. */
  Http = 'HTTP',
  /** A page link. */
  Page = 'PAGE',
  /** A product link. */
  Product = 'PRODUCT',
  /** A search link. */
  Search = 'SEARCH',
  /** A shop policy link. */
  ShopPolicy = 'SHOP_POLICY',
}

/** The merchandise to be purchased at checkout. */
export type Shopify_Merchandise = Shopify_ProductVariant;

/**
 * Metafields represent custom metadata attached to a resource. Metafields can be sorted into namespaces and are
 * comprised of keys, values, and value types.
 *
 */
export type Shopify_Metafield = Shopify_Node & {
  __typename?: 'shopify_Metafield';
  /** The date and time when the storefront metafield was created. */
  createdAt: Scalars['shopify_DateTime'];
  /** The description of a metafield. */
  description: Maybe<Scalars['String']>;
  /** A globally-unique ID. */
  id: Scalars['ID'];
  /** The unique identifier for the metafield within its namespace. */
  key: Scalars['String'];
  /** The container for a group of metafields that the metafield is associated with. */
  namespace: Scalars['String'];
  /** The type of resource that the metafield is attached to. */
  parentResource: Shopify_MetafieldParentResource;
  /** Returns a reference object if the metafield's type is a resource reference. */
  reference: Maybe<Shopify_MetafieldReference>;
  /** A list of reference objects if the metafield's type is a resource reference list. */
  references: Maybe<Shopify_MetafieldReferenceConnection>;
  /**
   * The type name of the metafield.
   * Refer to the list of [supported types](https://shopify.dev/apps/metafields/definitions/types).
   *
   */
  type: Scalars['String'];
  /** The date and time when the metafield was last updated. */
  updatedAt: Scalars['shopify_DateTime'];
  /** The data stored in the metafield. Always stored as a string, regardless of the metafield's type. */
  value: Scalars['String'];
};

/**
 * Metafields represent custom metadata attached to a resource. Metafields can be sorted into namespaces and are
 * comprised of keys, values, and value types.
 *
 */
export type Shopify_MetafieldReferencesArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
};

/** Possible error codes that can be returned by `MetafieldDeleteUserError`. */
export enum Shopify_MetafieldDeleteErrorCode {
  /** The owner ID is invalid. */
  InvalidOwner = 'INVALID_OWNER',
  /** Metafield not found. */
  MetafieldDoesNotExist = 'METAFIELD_DOES_NOT_EXIST',
}

/** An error that occurs during the execution of cart metafield deletion. */
export type Shopify_MetafieldDeleteUserError = Shopify_DisplayableError & {
  __typename?: 'shopify_MetafieldDeleteUserError';
  /** The error code. */
  code: Maybe<Shopify_MetafieldDeleteErrorCode>;
  /** The path to the input field that caused the error. */
  field: Maybe<Array<Scalars['String']>>;
  /** The error message. */
  message: Scalars['String'];
};

/**
 * A filter used to view a subset of products in a collection matching a specific metafield value.
 *
 * Only the following metafield types are currently supported:
 * - `number_integer`
 * - `number_decimal`
 * - `single_line_text_field`
 * - `boolean` as of 2022-04.
 *
 */
export type Shopify_MetafieldFilter = {
  /** The key of the metafield to filter on. */
  key: Scalars['String'];
  /** The namespace of the metafield to filter on. */
  namespace: Scalars['String'];
  /** The value of the metafield. */
  value: Scalars['String'];
};

/** A resource that the metafield belongs to. */
export type Shopify_MetafieldParentResource =
  | Shopify_Article
  | Shopify_Blog
  | Shopify_Cart
  | Shopify_Collection
  | Shopify_Customer
  | Shopify_Location
  | Shopify_Market
  | Shopify_Order
  | Shopify_Page
  | Shopify_Product
  | Shopify_ProductVariant
  | Shopify_Shop;

/**
 * Returns the resource which is being referred to by a metafield.
 *
 */
export type Shopify_MetafieldReference =
  | Shopify_Collection
  | Shopify_GenericFile
  | Shopify_MediaImage
  | Shopify_Metaobject
  | Shopify_Page
  | Shopify_Product
  | Shopify_ProductVariant
  | Shopify_Video;

/**
 * An auto-generated type for paginating through multiple MetafieldReferences.
 *
 */
export type Shopify_MetafieldReferenceConnection = {
  __typename?: 'shopify_MetafieldReferenceConnection';
  /** A list of edges. */
  edges: Array<Shopify_MetafieldReferenceEdge>;
  /** A list of the nodes contained in MetafieldReferenceEdge. */
  nodes: Array<Shopify_MetafieldReference>;
  /** Information to aid in pagination. */
  pageInfo: Shopify_PageInfo;
};

/**
 * An auto-generated type which holds one MetafieldReference and a cursor during pagination.
 *
 */
export type Shopify_MetafieldReferenceEdge = {
  __typename?: 'shopify_MetafieldReferenceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of MetafieldReferenceEdge. */
  node: Shopify_MetafieldReference;
};

/** An error that occurs during the execution of `MetafieldsSet`. */
export type Shopify_MetafieldsSetUserError = Shopify_DisplayableError & {
  __typename?: 'shopify_MetafieldsSetUserError';
  /** The error code. */
  code: Maybe<Shopify_MetafieldsSetUserErrorCode>;
  /** The index of the array element that's causing the error. */
  elementIndex: Maybe<Scalars['Int']>;
  /** The path to the input field that caused the error. */
  field: Maybe<Array<Scalars['String']>>;
  /** The error message. */
  message: Scalars['String'];
};

/** Possible error codes that can be returned by `MetafieldsSetUserError`. */
export enum Shopify_MetafieldsSetUserErrorCode {
  /** The input value is blank. */
  Blank = 'BLANK',
  /** The input value isn't included in the list. */
  Inclusion = 'INCLUSION',
  /** The owner ID is invalid. */
  InvalidOwner = 'INVALID_OWNER',
  /** The type is invalid. */
  InvalidType = 'INVALID_TYPE',
  /** The value is invalid for metafield type or for definition options. */
  InvalidValue = 'INVALID_VALUE',
  /** The input value should be less than or equal to the maximum value allowed. */
  LessThanOrEqualTo = 'LESS_THAN_OR_EQUAL_TO',
  /** The input value needs to be blank. */
  Present = 'PRESENT',
  /** The input value is too long. */
  TooLong = 'TOO_LONG',
  /** The input value is too short. */
  TooShort = 'TOO_SHORT',
}

/** An instance of a user-defined model based on a MetaobjectDefinition. */
export type Shopify_Metaobject = Shopify_Node & {
  __typename?: 'shopify_Metaobject';
  /** Accesses a field of the object by key. */
  field: Maybe<Shopify_MetaobjectField>;
  /**
   * All object fields with defined values.
   * Omitted object keys can be assumed null, and no guarantees are made about field order.
   *
   */
  fields: Array<Shopify_MetaobjectField>;
  /** The unique handle of the metaobject. Useful as a custom ID. */
  handle: Scalars['String'];
  /** A globally-unique ID. */
  id: Scalars['ID'];
  /** The type of the metaobject. Defines the namespace of its associated metafields. */
  type: Scalars['String'];
  /** The date and time when the metaobject was last updated. */
  updatedAt: Scalars['shopify_DateTime'];
};

/** An instance of a user-defined model based on a MetaobjectDefinition. */
export type Shopify_MetaobjectFieldArgs = {
  key: Scalars['String'];
};

/**
 * An auto-generated type for paginating through multiple Metaobjects.
 *
 */
export type Shopify_MetaobjectConnection = {
  __typename?: 'shopify_MetaobjectConnection';
  /** A list of edges. */
  edges: Array<Shopify_MetaobjectEdge>;
  /** A list of the nodes contained in MetaobjectEdge. */
  nodes: Array<Shopify_Metaobject>;
  /** Information to aid in pagination. */
  pageInfo: Shopify_PageInfo;
};

/**
 * An auto-generated type which holds one Metaobject and a cursor during pagination.
 *
 */
export type Shopify_MetaobjectEdge = {
  __typename?: 'shopify_MetaobjectEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of MetaobjectEdge. */
  node: Shopify_Metaobject;
};

/** Provides the value of a Metaobject field. */
export type Shopify_MetaobjectField = {
  __typename?: 'shopify_MetaobjectField';
  /** The field key. */
  key: Scalars['String'];
  /** A referenced object if the field type is a resource reference. */
  reference: Maybe<Shopify_MetafieldReference>;
  /** A list of referenced objects if the field type is a resource reference list. */
  references: Maybe<Shopify_MetafieldReferenceConnection>;
  /**
   * The type name of the field.
   * See the list of [supported types](https://shopify.dev/apps/metafields/definitions/types).
   *
   */
  type: Scalars['String'];
  /** The field value. */
  value: Maybe<Scalars['String']>;
};

/** Provides the value of a Metaobject field. */
export type Shopify_MetaobjectFieldReferencesArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
};

/** The input fields used to retrieve a metaobject by handle. */
export type Shopify_MetaobjectHandleInput = {
  /** The handle of the metaobject. */
  handle: Scalars['String'];
  /** The type of the metaobject. */
  type: Scalars['String'];
};

/** Represents a Shopify hosted 3D model. */
export type Shopify_Model3d = Shopify_Media &
  Shopify_Node & {
    __typename?: 'shopify_Model3d';
    /** A word or phrase to share the nature or contents of a media. */
    alt: Maybe<Scalars['String']>;
    /** A globally-unique ID. */
    id: Scalars['ID'];
    /** The media content type. */
    mediaContentType: Shopify_MediaContentType;
    /** The presentation for a media. */
    presentation: Maybe<Shopify_MediaPresentation>;
    /** The preview image for the media. */
    previewImage: Maybe<Shopify_Image>;
    /** The sources for a 3d model. */
    sources: Array<Shopify_Model3dSource>;
  };

/** Represents a source for a Shopify hosted 3d model. */
export type Shopify_Model3dSource = {
  __typename?: 'shopify_Model3dSource';
  /** The filesize of the 3d model. */
  filesize: Scalars['Int'];
  /** The format of the 3d model. */
  format: Scalars['String'];
  /** The MIME type of the 3d model. */
  mimeType: Scalars['String'];
  /** The URL of the 3d model. */
  url: Scalars['String'];
};

/** The input fields for a monetary value with currency. */
export type Shopify_MoneyInput = {
  /** Decimal money amount. */
  amount: Scalars['shopify_Decimal'];
  /** Currency of the money. */
  currencyCode: Shopify_CurrencyCode;
};

/**
 * A monetary value with currency.
 *
 */
export type Shopify_MoneyV2 = {
  __typename?: 'shopify_MoneyV2';
  /** Decimal money amount. */
  amount: Scalars['shopify_Decimal'];
  /** Currency of the money. */
  currencyCode: Shopify_CurrencyCode;
};

/**
 * An object with an ID field to support global identification, in accordance with the
 * [Relay specification](https://relay.dev/graphql/objectidentification.htm#sec-Node-Interface).
 * This interface is used by the [node](https://shopify.dev/api/admin-graphql/unstable/queries/node)
 * and [nodes](https://shopify.dev/api/admin-graphql/unstable/queries/nodes) queries.
 *
 */
export type Shopify_Node = {
  /** A globally-unique ID. */
  id: Scalars['ID'];
};

/** Represents a resource that can be published to the Online Store sales channel. */
export type Shopify_OnlineStorePublishable = {
  /** The URL used for viewing the resource on the shop's Online Store. Returns `null` if the resource is currently not published to the Online Store sales channel. */
  onlineStoreUrl: Maybe<Scalars['shopify_URL']>;
};

/** An order is a customers completed request to purchase one or more products from a shop. An order is created when a customer completes the checkout process, during which time they provides an email address, billing address and payment information. */
export type Shopify_Order = Shopify_HasMetafields &
  Shopify_Node & {
    __typename?: 'shopify_Order';
    /** The address associated with the payment method. */
    billingAddress: Maybe<Shopify_MailingAddress>;
    /** The reason for the order's cancellation. Returns `null` if the order wasn't canceled. */
    cancelReason: Maybe<Shopify_OrderCancelReason>;
    /** The date and time when the order was canceled. Returns null if the order wasn't canceled. */
    canceledAt: Maybe<Scalars['shopify_DateTime']>;
    /** The code of the currency used for the payment. */
    currencyCode: Shopify_CurrencyCode;
    /** The subtotal of line items and their discounts, excluding line items that have been removed. Does not contain order-level discounts, duties, shipping costs, or shipping discounts. Taxes aren't included unless the order is a taxes-included order. */
    currentSubtotalPrice: Shopify_MoneyV2;
    /** The total cost of duties for the order, including refunds. */
    currentTotalDuties: Maybe<Shopify_MoneyV2>;
    /** The total amount of the order, including duties, taxes and discounts, minus amounts for line items that have been removed. */
    currentTotalPrice: Shopify_MoneyV2;
    /** The total of all taxes applied to the order, excluding taxes for returned line items. */
    currentTotalTax: Shopify_MoneyV2;
    /** A list of the custom attributes added to the order. */
    customAttributes: Array<Shopify_Attribute>;
    /** The locale code in which this specific order happened. */
    customerLocale: Maybe<Scalars['String']>;
    /** The unique URL that the customer can use to access the order. */
    customerUrl: Maybe<Scalars['shopify_URL']>;
    /** Discounts that have been applied on the order. */
    discountApplications: Shopify_DiscountApplicationConnection;
    /** Whether the order has had any edits applied or not. */
    edited: Scalars['Boolean'];
    /** The customer's email address. */
    email: Maybe<Scalars['String']>;
    /** The financial status of the order. */
    financialStatus: Maybe<Shopify_OrderFinancialStatus>;
    /** The fulfillment status for the order. */
    fulfillmentStatus: Shopify_OrderFulfillmentStatus;
    /** A globally-unique ID. */
    id: Scalars['ID'];
    /** List of the orders line items. */
    lineItems: Shopify_OrderLineItemConnection;
    /** Returns a metafield found by namespace and key. */
    metafield: Maybe<Shopify_Metafield>;
    /** The metafields associated with the resource matching the supplied list of namespaces and keys. */
    metafields: Array<Maybe<Shopify_Metafield>>;
    /**
     * Unique identifier for the order that appears on the order.
     * For example, _#1000_ or _Store1001.
     *
     */
    name: Scalars['String'];
    /** A unique numeric identifier for the order for use by shop owner and customer. */
    orderNumber: Scalars['Int'];
    /** The total cost of duties charged at checkout. */
    originalTotalDuties: Maybe<Shopify_MoneyV2>;
    /** The total price of the order before any applied edits. */
    originalTotalPrice: Shopify_MoneyV2;
    /** The customer's phone number for receiving SMS notifications. */
    phone: Maybe<Scalars['String']>;
    /**
     * The date and time when the order was imported.
     * This value can be set to dates in the past when importing from other systems.
     * If no value is provided, it will be auto-generated based on current date and time.
     *
     */
    processedAt: Scalars['shopify_DateTime'];
    /** The address to where the order will be shipped. */
    shippingAddress: Maybe<Shopify_MailingAddress>;
    /**
     * The discounts that have been allocated onto the shipping line by discount applications.
     *
     */
    shippingDiscountAllocations: Array<Shopify_DiscountAllocation>;
    /** The unique URL for the order's status page. */
    statusUrl: Scalars['shopify_URL'];
    /** Price of the order before shipping and taxes. */
    subtotalPrice: Maybe<Shopify_MoneyV2>;
    /** Price of the order before duties, shipping and taxes. */
    subtotalPriceV2: Maybe<Shopify_MoneyV2>;
    /** List of the orders successful fulfillments. */
    successfulFulfillments: Maybe<Array<Shopify_Fulfillment>>;
    /** The sum of all the prices of all the items in the order, duties, taxes and discounts included (must be positive). */
    totalPrice: Shopify_MoneyV2;
    /** The sum of all the prices of all the items in the order, duties, taxes and discounts included (must be positive). */
    totalPriceV2: Shopify_MoneyV2;
    /** The total amount that has been refunded. */
    totalRefunded: Shopify_MoneyV2;
    /** The total amount that has been refunded. */
    totalRefundedV2: Shopify_MoneyV2;
    /** The total cost of shipping. */
    totalShippingPrice: Shopify_MoneyV2;
    /** The total cost of shipping. */
    totalShippingPriceV2: Shopify_MoneyV2;
    /** The total cost of taxes. */
    totalTax: Maybe<Shopify_MoneyV2>;
    /** The total cost of taxes. */
    totalTaxV2: Maybe<Shopify_MoneyV2>;
  };

/** An order is a customers completed request to purchase one or more products from a shop. An order is created when a customer completes the checkout process, during which time they provides an email address, billing address and payment information. */
export type Shopify_OrderDiscountApplicationsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  reverse?: InputMaybe<Scalars['Boolean']>;
};

/** An order is a customers completed request to purchase one or more products from a shop. An order is created when a customer completes the checkout process, during which time they provides an email address, billing address and payment information. */
export type Shopify_OrderLineItemsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  reverse?: InputMaybe<Scalars['Boolean']>;
};

/** An order is a customers completed request to purchase one or more products from a shop. An order is created when a customer completes the checkout process, during which time they provides an email address, billing address and payment information. */
export type Shopify_OrderMetafieldArgs = {
  key: Scalars['String'];
  namespace: Scalars['String'];
};

/** An order is a customers completed request to purchase one or more products from a shop. An order is created when a customer completes the checkout process, during which time they provides an email address, billing address and payment information. */
export type Shopify_OrderMetafieldsArgs = {
  identifiers: Array<Shopify_HasMetafieldsIdentifier>;
};

/** An order is a customers completed request to purchase one or more products from a shop. An order is created when a customer completes the checkout process, during which time they provides an email address, billing address and payment information. */
export type Shopify_OrderSuccessfulFulfillmentsArgs = {
  first: InputMaybe<Scalars['Int']>;
};

/** Represents the reason for the order's cancellation. */
export enum Shopify_OrderCancelReason {
  /** The customer wanted to cancel the order. */
  Customer = 'CUSTOMER',
  /** Payment was declined. */
  Declined = 'DECLINED',
  /** The order was fraudulent. */
  Fraud = 'FRAUD',
  /** There was insufficient inventory. */
  Inventory = 'INVENTORY',
  /** The order was canceled for an unlisted reason. */
  Other = 'OTHER',
}

/**
 * An auto-generated type for paginating through multiple Orders.
 *
 */
export type Shopify_OrderConnection = {
  __typename?: 'shopify_OrderConnection';
  /** A list of edges. */
  edges: Array<Shopify_OrderEdge>;
  /** A list of the nodes contained in OrderEdge. */
  nodes: Array<Shopify_Order>;
  /** Information to aid in pagination. */
  pageInfo: Shopify_PageInfo;
  /** The total count of Orders. */
  totalCount: Scalars['shopify_UnsignedInt64'];
};

/**
 * An auto-generated type which holds one Order and a cursor during pagination.
 *
 */
export type Shopify_OrderEdge = {
  __typename?: 'shopify_OrderEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of OrderEdge. */
  node: Shopify_Order;
};

/** Represents the order's current financial status. */
export enum Shopify_OrderFinancialStatus {
  /** Displayed as **Authorized**. */
  Authorized = 'AUTHORIZED',
  /** Displayed as **Paid**. */
  Paid = 'PAID',
  /** Displayed as **Partially paid**. */
  PartiallyPaid = 'PARTIALLY_PAID',
  /** Displayed as **Partially refunded**. */
  PartiallyRefunded = 'PARTIALLY_REFUNDED',
  /** Displayed as **Pending**. */
  Pending = 'PENDING',
  /** Displayed as **Refunded**. */
  Refunded = 'REFUNDED',
  /** Displayed as **Voided**. */
  Voided = 'VOIDED',
}

/** Represents the order's aggregated fulfillment status for display purposes. */
export enum Shopify_OrderFulfillmentStatus {
  /** Displayed as **Fulfilled**. All of the items in the order have been fulfilled. */
  Fulfilled = 'FULFILLED',
  /** Displayed as **In progress**. Some of the items in the order have been fulfilled, or a request for fulfillment has been sent to the fulfillment service. */
  InProgress = 'IN_PROGRESS',
  /** Displayed as **On hold**. All of the unfulfilled items in this order are on hold. */
  OnHold = 'ON_HOLD',
  /** Displayed as **Open**. None of the items in the order have been fulfilled. Replaced by "UNFULFILLED" status. */
  Open = 'OPEN',
  /** Displayed as **Partially fulfilled**. Some of the items in the order have been fulfilled. */
  PartiallyFulfilled = 'PARTIALLY_FULFILLED',
  /** Displayed as **Pending fulfillment**. A request for fulfillment of some items awaits a response from the fulfillment service. Replaced by "IN_PROGRESS" status. */
  PendingFulfillment = 'PENDING_FULFILLMENT',
  /** Displayed as **Restocked**. All of the items in the order have been restocked. Replaced by "UNFULFILLED" status. */
  Restocked = 'RESTOCKED',
  /** Displayed as **Scheduled**. All of the unfulfilled items in this order are scheduled for fulfillment at later time. */
  Scheduled = 'SCHEDULED',
  /** Displayed as **Unfulfilled**. None of the items in the order have been fulfilled. */
  Unfulfilled = 'UNFULFILLED',
}

/** Represents a single line in an order. There is one line item for each distinct product variant. */
export type Shopify_OrderLineItem = {
  __typename?: 'shopify_OrderLineItem';
  /** The number of entries associated to the line item minus the items that have been removed. */
  currentQuantity: Scalars['Int'];
  /** List of custom attributes associated to the line item. */
  customAttributes: Array<Shopify_Attribute>;
  /** The discounts that have been allocated onto the order line item by discount applications. */
  discountAllocations: Array<Shopify_DiscountAllocation>;
  /** The total price of the line item, including discounts, and displayed in the presentment currency. */
  discountedTotalPrice: Shopify_MoneyV2;
  /** The total price of the line item, not including any discounts. The total price is calculated using the original unit price multiplied by the quantity, and it's displayed in the presentment currency. */
  originalTotalPrice: Shopify_MoneyV2;
  /** The number of products variants associated to the line item. */
  quantity: Scalars['Int'];
  /** The title of the product combined with title of the variant. */
  title: Scalars['String'];
  /** The product variant object associated to the line item. */
  variant: Maybe<Shopify_ProductVariant>;
};

/**
 * An auto-generated type for paginating through multiple OrderLineItems.
 *
 */
export type Shopify_OrderLineItemConnection = {
  __typename?: 'shopify_OrderLineItemConnection';
  /** A list of edges. */
  edges: Array<Shopify_OrderLineItemEdge>;
  /** A list of the nodes contained in OrderLineItemEdge. */
  nodes: Array<Shopify_OrderLineItem>;
  /** Information to aid in pagination. */
  pageInfo: Shopify_PageInfo;
};

/**
 * An auto-generated type which holds one OrderLineItem and a cursor during pagination.
 *
 */
export type Shopify_OrderLineItemEdge = {
  __typename?: 'shopify_OrderLineItemEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of OrderLineItemEdge. */
  node: Shopify_OrderLineItem;
};

/** The set of valid sort keys for the Order query. */
export enum Shopify_OrderSortKeys {
  /** Sort by the `id` value. */
  Id = 'ID',
  /** Sort by the `processed_at` value. */
  ProcessedAt = 'PROCESSED_AT',
  /**
   * Sort by relevance to the search terms when the `query` parameter is specified on the connection.
   * Don't use this sort key when no search query is specified.
   *
   */
  Relevance = 'RELEVANCE',
  /** Sort by the `total_price` value. */
  TotalPrice = 'TOTAL_PRICE',
}

/** Shopify merchants can create pages to hold static HTML content. Each Page object represents a custom page on the online store. */
export type Shopify_Page = Shopify_HasMetafields &
  Shopify_Node &
  Shopify_OnlineStorePublishable & {
    __typename?: 'shopify_Page';
    /** The description of the page, complete with HTML formatting. */
    body: Scalars['shopify_HTML'];
    /** Summary of the page body. */
    bodySummary: Scalars['String'];
    /** The timestamp of the page creation. */
    createdAt: Scalars['shopify_DateTime'];
    /** A human-friendly unique string for the page automatically generated from its title. */
    handle: Scalars['String'];
    /** A globally-unique ID. */
    id: Scalars['ID'];
    /** Returns a metafield found by namespace and key. */
    metafield: Maybe<Shopify_Metafield>;
    /** The metafields associated with the resource matching the supplied list of namespaces and keys. */
    metafields: Array<Maybe<Shopify_Metafield>>;
    /** The URL used for viewing the resource on the shop's Online Store. Returns `null` if the resource is currently not published to the Online Store sales channel. */
    onlineStoreUrl: Maybe<Scalars['shopify_URL']>;
    /** The page's SEO information. */
    seo: Maybe<Shopify_Seo>;
    /** The title of the page. */
    title: Scalars['String'];
    /** The timestamp of the latest page update. */
    updatedAt: Scalars['shopify_DateTime'];
  };

/** Shopify merchants can create pages to hold static HTML content. Each Page object represents a custom page on the online store. */
export type Shopify_PageMetafieldArgs = {
  key: Scalars['String'];
  namespace: Scalars['String'];
};

/** Shopify merchants can create pages to hold static HTML content. Each Page object represents a custom page on the online store. */
export type Shopify_PageMetafieldsArgs = {
  identifiers: Array<Shopify_HasMetafieldsIdentifier>;
};

/**
 * An auto-generated type for paginating through multiple Pages.
 *
 */
export type Shopify_PageConnection = {
  __typename?: 'shopify_PageConnection';
  /** A list of edges. */
  edges: Array<Shopify_PageEdge>;
  /** A list of the nodes contained in PageEdge. */
  nodes: Array<Shopify_Page>;
  /** Information to aid in pagination. */
  pageInfo: Shopify_PageInfo;
};

/**
 * An auto-generated type which holds one Page and a cursor during pagination.
 *
 */
export type Shopify_PageEdge = {
  __typename?: 'shopify_PageEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of PageEdge. */
  node: Shopify_Page;
};

/**
 * Returns information about pagination in a connection, in accordance with the
 * [Relay specification](https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo).
 * For more information, please read our [GraphQL Pagination Usage Guide](https://shopify.dev/api/usage/pagination-graphql).
 *
 */
export type Shopify_PageInfo = {
  __typename?: 'shopify_PageInfo';
  /** The cursor corresponding to the last node in edges. */
  endCursor: Maybe<Scalars['String']>;
  /** Whether there are more pages to fetch following the current page. */
  hasNextPage: Scalars['Boolean'];
  /** Whether there are any pages prior to the current page. */
  hasPreviousPage: Scalars['Boolean'];
  /** The cursor corresponding to the first node in edges. */
  startCursor: Maybe<Scalars['String']>;
};

/** The set of valid sort keys for the Page query. */
export enum Shopify_PageSortKeys {
  /** Sort by the `id` value. */
  Id = 'ID',
  /**
   * Sort by relevance to the search terms when the `query` parameter is specified on the connection.
   * Don't use this sort key when no search query is specified.
   *
   */
  Relevance = 'RELEVANCE',
  /** Sort by the `title` value. */
  Title = 'TITLE',
  /** Sort by the `updated_at` value. */
  UpdatedAt = 'UPDATED_AT',
}

/** A payment applied to a checkout. */
export type Shopify_Payment = Shopify_Node & {
  __typename?: 'shopify_Payment';
  /** The amount of the payment. */
  amount: Shopify_MoneyV2;
  /** The amount of the payment. */
  amountV2: Shopify_MoneyV2;
  /** The billing address for the payment. */
  billingAddress: Maybe<Shopify_MailingAddress>;
  /** The checkout to which the payment belongs. */
  checkout: Shopify_Checkout;
  /** The credit card used for the payment in the case of direct payments. */
  creditCard: Maybe<Shopify_CreditCard>;
  /** A message describing a processing error during asynchronous processing. */
  errorMessage: Maybe<Scalars['String']>;
  /** A globally-unique ID. */
  id: Scalars['ID'];
  /**
   * A client-side generated token to identify a payment and perform idempotent operations.
   * For more information, refer to
   * [Idempotent requests](https://shopify.dev/api/usage/idempotent-requests).
   *
   */
  idempotencyKey: Maybe<Scalars['String']>;
  /** The URL where the customer needs to be redirected so they can complete the 3D Secure payment flow. */
  nextActionUrl: Maybe<Scalars['shopify_URL']>;
  /** Whether the payment is still processing asynchronously. */
  ready: Scalars['Boolean'];
  /** A flag to indicate if the payment is to be done in test mode for gateways that support it. */
  test: Scalars['Boolean'];
  /** The actual transaction recorded by Shopify after having processed the payment with the gateway. */
  transaction: Maybe<Shopify_Transaction>;
};

/** Settings related to payments. */
export type Shopify_PaymentSettings = {
  __typename?: 'shopify_PaymentSettings';
  /** List of the card brands which the shop accepts. */
  acceptedCardBrands: Array<Shopify_CardBrand>;
  /** The url pointing to the endpoint to vault credit cards. */
  cardVaultUrl: Scalars['shopify_URL'];
  /** The country where the shop is located. */
  countryCode: Shopify_CountryCode;
  /** The three-letter code for the shop's primary currency. */
  currencyCode: Shopify_CurrencyCode;
  /**
   * A list of enabled currencies (ISO 4217 format) that the shop accepts.
   * Merchants can enable currencies from their Shopify Payments settings in the Shopify admin.
   *
   */
  enabledPresentmentCurrencies: Array<Shopify_CurrencyCode>;
  /** The shops Shopify Payments account ID. */
  shopifyPaymentsAccountId: Maybe<Scalars['String']>;
  /** List of the digital wallets which the shop supports. */
  supportedDigitalWallets: Array<Shopify_DigitalWallet>;
};

/** The valid values for the types of payment token. */
export enum Shopify_PaymentTokenType {
  /** Apple Pay token type. */
  ApplePay = 'APPLE_PAY',
  /** Google Pay token type. */
  GooglePay = 'GOOGLE_PAY',
  /** Shopify Pay token type. */
  ShopifyPay = 'SHOPIFY_PAY',
  /** Stripe token type. */
  StripeVaultToken = 'STRIPE_VAULT_TOKEN',
  /** Vault payment token type. */
  Vault = 'VAULT',
}

/**
 * The input fields for a filter used to view a subset of products in a collection matching a specific price range.
 *
 */
export type Shopify_PriceRangeFilter = {
  /** The maximum price in the range. Empty indicates no max price. */
  max: InputMaybe<Scalars['Float']>;
  /** The minimum price in the range. Defaults to zero. */
  min: InputMaybe<Scalars['Float']>;
};

/** The value of the percentage pricing object. */
export type Shopify_PricingPercentageValue = {
  __typename?: 'shopify_PricingPercentageValue';
  /** The percentage value of the object. */
  percentage: Scalars['Float'];
};

/** The price value (fixed or percentage) for a discount application. */
export type Shopify_PricingValue =
  | Shopify_MoneyV2
  | Shopify_PricingPercentageValue;

/**
 * A product represents an individual item for sale in a Shopify store. Products are often physical, but they don't have to be.
 * For example, a digital download (such as a movie, music or ebook file) also
 * qualifies as a product, as do services (such as equipment rental, work for hire,
 * customization of another product or an extended warranty).
 *
 */
export type Shopify_Product = Shopify_HasMetafields &
  Shopify_Node &
  Shopify_OnlineStorePublishable & {
    __typename?: 'shopify_Product';
    /** Indicates if at least one product variant is available for sale. */
    availableForSale: Scalars['Boolean'];
    /** List of collections a product belongs to. */
    collections: Shopify_CollectionConnection;
    /** The compare at price of the product across all variants. */
    compareAtPriceRange: Shopify_ProductPriceRange;
    /** The date and time when the product was created. */
    createdAt: Scalars['shopify_DateTime'];
    /** Stripped description of the product, single line with HTML tags removed. */
    description: Scalars['String'];
    /** The description of the product, complete with HTML formatting. */
    descriptionHtml: Scalars['shopify_HTML'];
    /**
     * The featured image for the product.
     *
     * This field is functionally equivalent to `images(first: 1)`.
     *
     */
    featuredImage: Maybe<Shopify_Image>;
    /**
     * A human-friendly unique string for the Product automatically generated from its title.
     * They are used by the Liquid templating language to refer to objects.
     *
     */
    handle: Scalars['String'];
    /** A globally-unique ID. */
    id: Scalars['ID'];
    /** List of images associated with the product. */
    images: Shopify_ImageConnection;
    /** Whether the product is a gift card. */
    isGiftCard: Scalars['Boolean'];
    /** The media associated with the product. */
    media: Shopify_MediaConnection;
    /** Returns a metafield found by namespace and key. */
    metafield: Maybe<Shopify_Metafield>;
    /** The metafields associated with the resource matching the supplied list of namespaces and keys. */
    metafields: Array<Maybe<Shopify_Metafield>>;
    /** The URL used for viewing the resource on the shop's Online Store. Returns `null` if the resource is currently not published to the Online Store sales channel. */
    onlineStoreUrl: Maybe<Scalars['shopify_URL']>;
    /** List of product options. */
    options: Array<Shopify_ProductOption>;
    /** The price range. */
    priceRange: Shopify_ProductPriceRange;
    /** A categorization that a product can be tagged with, commonly used for filtering and searching. */
    productType: Scalars['String'];
    /** The date and time when the product was published to the channel. */
    publishedAt: Scalars['shopify_DateTime'];
    /** Whether the product can only be purchased with a selling plan. */
    requiresSellingPlan: Scalars['Boolean'];
    /** A list of a product's available selling plan groups. A selling plan group represents a selling method. For example, 'Subscribe and save' is a selling method where customers pay for goods or services per delivery. A selling plan group contains individual selling plans. */
    sellingPlanGroups: Shopify_SellingPlanGroupConnection;
    /** The product's SEO information. */
    seo: Shopify_Seo;
    /**
     * A comma separated list of tags that have been added to the product.
     * Additional access scope required for private apps: unauthenticated_read_product_tags.
     *
     */
    tags: Array<Scalars['String']>;
    /** The products title. */
    title: Scalars['String'];
    /** The total quantity of inventory in stock for this Product. */
    totalInventory: Maybe<Scalars['Int']>;
    /**
     * The date and time when the product was last modified.
     * A product's `updatedAt` value can change for different reasons. For example, if an order
     * is placed for a product that has inventory tracking set up, then the inventory adjustment
     * is counted as an update.
     *
     */
    updatedAt: Scalars['shopify_DateTime'];
    /**
     * Find a products variant based on its selected options.
     * This is useful for converting a users selection of product options into a single matching variant.
     * If there is not a variant for the selected options, `null` will be returned.
     *
     */
    variantBySelectedOptions: Maybe<Shopify_ProductVariant>;
    /** List of the products variants. */
    variants: Shopify_ProductVariantConnection;
    /** The products vendor name. */
    vendor: Scalars['String'];
  };

/**
 * A product represents an individual item for sale in a Shopify store. Products are often physical, but they don't have to be.
 * For example, a digital download (such as a movie, music or ebook file) also
 * qualifies as a product, as do services (such as equipment rental, work for hire,
 * customization of another product or an extended warranty).
 *
 */
export type Shopify_ProductCollectionsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  reverse?: InputMaybe<Scalars['Boolean']>;
};

/**
 * A product represents an individual item for sale in a Shopify store. Products are often physical, but they don't have to be.
 * For example, a digital download (such as a movie, music or ebook file) also
 * qualifies as a product, as do services (such as equipment rental, work for hire,
 * customization of another product or an extended warranty).
 *
 */
export type Shopify_ProductDescriptionArgs = {
  truncateAt: InputMaybe<Scalars['Int']>;
};

/**
 * A product represents an individual item for sale in a Shopify store. Products are often physical, but they don't have to be.
 * For example, a digital download (such as a movie, music or ebook file) also
 * qualifies as a product, as do services (such as equipment rental, work for hire,
 * customization of another product or an extended warranty).
 *
 */
export type Shopify_ProductImagesArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  reverse?: InputMaybe<Scalars['Boolean']>;
  sortKey?: InputMaybe<Shopify_ProductImageSortKeys>;
};

/**
 * A product represents an individual item for sale in a Shopify store. Products are often physical, but they don't have to be.
 * For example, a digital download (such as a movie, music or ebook file) also
 * qualifies as a product, as do services (such as equipment rental, work for hire,
 * customization of another product or an extended warranty).
 *
 */
export type Shopify_ProductMediaArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  reverse?: InputMaybe<Scalars['Boolean']>;
  sortKey?: InputMaybe<Shopify_ProductMediaSortKeys>;
};

/**
 * A product represents an individual item for sale in a Shopify store. Products are often physical, but they don't have to be.
 * For example, a digital download (such as a movie, music or ebook file) also
 * qualifies as a product, as do services (such as equipment rental, work for hire,
 * customization of another product or an extended warranty).
 *
 */
export type Shopify_ProductMetafieldArgs = {
  key: Scalars['String'];
  namespace: Scalars['String'];
};

/**
 * A product represents an individual item for sale in a Shopify store. Products are often physical, but they don't have to be.
 * For example, a digital download (such as a movie, music or ebook file) also
 * qualifies as a product, as do services (such as equipment rental, work for hire,
 * customization of another product or an extended warranty).
 *
 */
export type Shopify_ProductMetafieldsArgs = {
  identifiers: Array<Shopify_HasMetafieldsIdentifier>;
};

/**
 * A product represents an individual item for sale in a Shopify store. Products are often physical, but they don't have to be.
 * For example, a digital download (such as a movie, music or ebook file) also
 * qualifies as a product, as do services (such as equipment rental, work for hire,
 * customization of another product or an extended warranty).
 *
 */
export type Shopify_ProductOptionsArgs = {
  first: InputMaybe<Scalars['Int']>;
};

/**
 * A product represents an individual item for sale in a Shopify store. Products are often physical, but they don't have to be.
 * For example, a digital download (such as a movie, music or ebook file) also
 * qualifies as a product, as do services (such as equipment rental, work for hire,
 * customization of another product or an extended warranty).
 *
 */
export type Shopify_ProductSellingPlanGroupsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  reverse?: InputMaybe<Scalars['Boolean']>;
};

/**
 * A product represents an individual item for sale in a Shopify store. Products are often physical, but they don't have to be.
 * For example, a digital download (such as a movie, music or ebook file) also
 * qualifies as a product, as do services (such as equipment rental, work for hire,
 * customization of another product or an extended warranty).
 *
 */
export type Shopify_ProductVariantBySelectedOptionsArgs = {
  selectedOptions: Array<Shopify_SelectedOptionInput>;
};

/**
 * A product represents an individual item for sale in a Shopify store. Products are often physical, but they don't have to be.
 * For example, a digital download (such as a movie, music or ebook file) also
 * qualifies as a product, as do services (such as equipment rental, work for hire,
 * customization of another product or an extended warranty).
 *
 */
export type Shopify_ProductVariantsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  reverse?: InputMaybe<Scalars['Boolean']>;
  sortKey?: InputMaybe<Shopify_ProductVariantSortKeys>;
};

/** The set of valid sort keys for the ProductCollection query. */
export enum Shopify_ProductCollectionSortKeys {
  /** Sort by the `best-selling` value. */
  BestSelling = 'BEST_SELLING',
  /** Sort by the `collection-default` value. */
  CollectionDefault = 'COLLECTION_DEFAULT',
  /** Sort by the `created` value. */
  Created = 'CREATED',
  /** Sort by the `id` value. */
  Id = 'ID',
  /** Sort by the `manual` value. */
  Manual = 'MANUAL',
  /** Sort by the `price` value. */
  Price = 'PRICE',
  /**
   * Sort by relevance to the search terms when the `query` parameter is specified on the connection.
   * Don't use this sort key when no search query is specified.
   *
   */
  Relevance = 'RELEVANCE',
  /** Sort by the `title` value. */
  Title = 'TITLE',
}

/**
 * An auto-generated type for paginating through multiple Products.
 *
 */
export type Shopify_ProductConnection = {
  __typename?: 'shopify_ProductConnection';
  /** A list of edges. */
  edges: Array<Shopify_ProductEdge>;
  /** A list of available filters. */
  filters: Array<Shopify_Filter>;
  /** A list of the nodes contained in ProductEdge. */
  nodes: Array<Shopify_Product>;
  /** Information to aid in pagination. */
  pageInfo: Shopify_PageInfo;
};

/**
 * An auto-generated type which holds one Product and a cursor during pagination.
 *
 */
export type Shopify_ProductEdge = {
  __typename?: 'shopify_ProductEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of ProductEdge. */
  node: Shopify_Product;
};

/**
 * The input fields for a filter used to view a subset of products in a collection.
 * By default, the `available` and `price` filters are enabled. Filters are customized with the Shopify Search & Discovery app.
 * Learn more about [customizing storefront filtering](https://help.shopify.com/manual/online-store/themes/customizing-themes/storefront-filters).
 *
 */
export type Shopify_ProductFilter = {
  /** Filter on if the product is available for sale. */
  available: InputMaybe<Scalars['Boolean']>;
  /** A range of prices to filter with-in. */
  price: InputMaybe<Shopify_PriceRangeFilter>;
  /** A product metafield to filter on. */
  productMetafield: InputMaybe<Shopify_MetafieldFilter>;
  /** The product type to filter on. */
  productType: InputMaybe<Scalars['String']>;
  /** The product vendor to filter on. */
  productVendor: InputMaybe<Scalars['String']>;
  /** A product tag to filter on. */
  tag: InputMaybe<Scalars['String']>;
  /** A variant metafield to filter on. */
  variantMetafield: InputMaybe<Shopify_MetafieldFilter>;
  /** A variant option to filter on. */
  variantOption: InputMaybe<Shopify_VariantOptionFilter>;
};

/** The set of valid sort keys for the ProductImage query. */
export enum Shopify_ProductImageSortKeys {
  /** Sort by the `created_at` value. */
  CreatedAt = 'CREATED_AT',
  /** Sort by the `id` value. */
  Id = 'ID',
  /** Sort by the `position` value. */
  Position = 'POSITION',
  /**
   * Sort by relevance to the search terms when the `query` parameter is specified on the connection.
   * Don't use this sort key when no search query is specified.
   *
   */
  Relevance = 'RELEVANCE',
}

/** The set of valid sort keys for the ProductMedia query. */
export enum Shopify_ProductMediaSortKeys {
  /** Sort by the `id` value. */
  Id = 'ID',
  /** Sort by the `position` value. */
  Position = 'POSITION',
  /**
   * Sort by relevance to the search terms when the `query` parameter is specified on the connection.
   * Don't use this sort key when no search query is specified.
   *
   */
  Relevance = 'RELEVANCE',
}

/**
 * Product property names like "Size", "Color", and "Material" that the customers can select.
 * Variants are selected based on permutations of these options.
 * 255 characters limit each.
 *
 */
export type Shopify_ProductOption = Shopify_Node & {
  __typename?: 'shopify_ProductOption';
  /** A globally-unique ID. */
  id: Scalars['ID'];
  /** The product options name. */
  name: Scalars['String'];
  /** The corresponding value to the product option name. */
  values: Array<Scalars['String']>;
};

/** The price range of the product. */
export type Shopify_ProductPriceRange = {
  __typename?: 'shopify_ProductPriceRange';
  /** The highest variant's price. */
  maxVariantPrice: Shopify_MoneyV2;
  /** The lowest variant's price. */
  minVariantPrice: Shopify_MoneyV2;
};

/**
 * The recommendation intent that is used to generate product recommendations.
 * You can use intent to generate product recommendations according to different strategies.
 *
 */
export enum Shopify_ProductRecommendationIntent {
  /** Offer customers products that are complementary to a product for which recommendations are to be fetched. An example is add-on products that display in a Pair it with section. */
  Complementary = 'COMPLEMENTARY',
  /** Offer customers a mix of products that are similar or complementary to a product for which recommendations are to be fetched. An example is substitutable products that display in a You may also like section. */
  Related = 'RELATED',
}

/** The set of valid sort keys for the Product query. */
export enum Shopify_ProductSortKeys {
  /** Sort by the `best_selling` value. */
  BestSelling = 'BEST_SELLING',
  /** Sort by the `created_at` value. */
  CreatedAt = 'CREATED_AT',
  /** Sort by the `id` value. */
  Id = 'ID',
  /** Sort by the `price` value. */
  Price = 'PRICE',
  /** Sort by the `product_type` value. */
  ProductType = 'PRODUCT_TYPE',
  /**
   * Sort by relevance to the search terms when the `query` parameter is specified on the connection.
   * Don't use this sort key when no search query is specified.
   *
   */
  Relevance = 'RELEVANCE',
  /** Sort by the `title` value. */
  Title = 'TITLE',
  /** Sort by the `updated_at` value. */
  UpdatedAt = 'UPDATED_AT',
  /** Sort by the `vendor` value. */
  Vendor = 'VENDOR',
}

/**
 * A product variant represents a different version of a product, such as differing sizes or differing colors.
 *
 */
export type Shopify_ProductVariant = Shopify_HasMetafields &
  Shopify_Node & {
    __typename?: 'shopify_ProductVariant';
    /** Indicates if the product variant is available for sale. */
    availableForSale: Scalars['Boolean'];
    /** The barcode (for example, ISBN, UPC, or GTIN) associated with the variant. */
    barcode: Maybe<Scalars['String']>;
    /** The compare at price of the variant. This can be used to mark a variant as on sale, when `compareAtPrice` is higher than `price`. */
    compareAtPrice: Maybe<Shopify_MoneyV2>;
    /** The compare at price of the variant. This can be used to mark a variant as on sale, when `compareAtPriceV2` is higher than `priceV2`. */
    compareAtPriceV2: Maybe<Shopify_MoneyV2>;
    /** Whether a product is out of stock but still available for purchase (used for backorders). */
    currentlyNotInStock: Scalars['Boolean'];
    /** A globally-unique ID. */
    id: Scalars['ID'];
    /** Image associated with the product variant. This field falls back to the product image if no image is available. */
    image: Maybe<Shopify_Image>;
    /** Returns a metafield found by namespace and key. */
    metafield: Maybe<Shopify_Metafield>;
    /** The metafields associated with the resource matching the supplied list of namespaces and keys. */
    metafields: Array<Maybe<Shopify_Metafield>>;
    /** The product variants price. */
    price: Shopify_MoneyV2;
    /** The product variants price. */
    priceV2: Shopify_MoneyV2;
    /** The product object that the product variant belongs to. */
    product: Shopify_Product;
    /** The total sellable quantity of the variant for online sales channels. */
    quantityAvailable: Maybe<Scalars['Int']>;
    /** Whether a customer needs to provide a shipping address when placing an order for the product variant. */
    requiresShipping: Scalars['Boolean'];
    /** List of product options applied to the variant. */
    selectedOptions: Array<Shopify_SelectedOption>;
    /** Represents an association between a variant and a selling plan. Selling plan allocations describe which selling plans are available for each variant, and what their impact is on pricing. */
    sellingPlanAllocations: Shopify_SellingPlanAllocationConnection;
    /** The SKU (stock keeping unit) associated with the variant. */
    sku: Maybe<Scalars['String']>;
    /** The in-store pickup availability of this variant by location. */
    storeAvailability: Shopify_StoreAvailabilityConnection;
    /** The product variants title. */
    title: Scalars['String'];
    /** The unit price value for the variant based on the variant's measurement. */
    unitPrice: Maybe<Shopify_MoneyV2>;
    /** The unit price measurement for the variant. */
    unitPriceMeasurement: Maybe<Shopify_UnitPriceMeasurement>;
    /** The weight of the product variant in the unit system specified with `weight_unit`. */
    weight: Maybe<Scalars['Float']>;
    /** Unit of measurement for weight. */
    weightUnit: Shopify_WeightUnit;
  };

/**
 * A product variant represents a different version of a product, such as differing sizes or differing colors.
 *
 */
export type Shopify_ProductVariantMetafieldArgs = {
  key: Scalars['String'];
  namespace: Scalars['String'];
};

/**
 * A product variant represents a different version of a product, such as differing sizes or differing colors.
 *
 */
export type Shopify_ProductVariantMetafieldsArgs = {
  identifiers: Array<Shopify_HasMetafieldsIdentifier>;
};

/**
 * A product variant represents a different version of a product, such as differing sizes or differing colors.
 *
 */
export type Shopify_ProductVariantSellingPlanAllocationsArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  reverse?: InputMaybe<Scalars['Boolean']>;
};

/**
 * A product variant represents a different version of a product, such as differing sizes or differing colors.
 *
 */
export type Shopify_ProductVariantStoreAvailabilityArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  near: InputMaybe<Shopify_GeoCoordinateInput>;
  reverse?: InputMaybe<Scalars['Boolean']>;
};

/**
 * An auto-generated type for paginating through multiple ProductVariants.
 *
 */
export type Shopify_ProductVariantConnection = {
  __typename?: 'shopify_ProductVariantConnection';
  /** A list of edges. */
  edges: Array<Shopify_ProductVariantEdge>;
  /** A list of the nodes contained in ProductVariantEdge. */
  nodes: Array<Shopify_ProductVariant>;
  /** Information to aid in pagination. */
  pageInfo: Shopify_PageInfo;
};

/**
 * An auto-generated type which holds one ProductVariant and a cursor during pagination.
 *
 */
export type Shopify_ProductVariantEdge = {
  __typename?: 'shopify_ProductVariantEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of ProductVariantEdge. */
  node: Shopify_ProductVariant;
};

/** The set of valid sort keys for the ProductVariant query. */
export enum Shopify_ProductVariantSortKeys {
  /** Sort by the `id` value. */
  Id = 'ID',
  /** Sort by the `position` value. */
  Position = 'POSITION',
  /**
   * Sort by relevance to the search terms when the `query` parameter is specified on the connection.
   * Don't use this sort key when no search query is specified.
   *
   */
  Relevance = 'RELEVANCE',
  /** Sort by the `sku` value. */
  Sku = 'SKU',
  /** Sort by the `title` value. */
  Title = 'TITLE',
}

/** SEO information. */
export type Shopify_Seo = {
  __typename?: 'shopify_SEO';
  /** The meta description. */
  description: Maybe<Scalars['String']>;
  /** The SEO title. */
  title: Maybe<Scalars['String']>;
};

/**
 * Script discount applications capture the intentions of a discount that
 * was created by a Shopify Script.
 *
 */
export type Shopify_ScriptDiscountApplication = Shopify_DiscountApplication & {
  __typename?: 'shopify_ScriptDiscountApplication';
  /** The method by which the discount's value is allocated to its entitled items. */
  allocationMethod: Shopify_DiscountApplicationAllocationMethod;
  /** Which lines of targetType that the discount is allocated over. */
  targetSelection: Shopify_DiscountApplicationTargetSelection;
  /** The type of line that the discount is applicable towards. */
  targetType: Shopify_DiscountApplicationTargetType;
  /** The title of the application as defined by the Script. */
  title: Scalars['String'];
  /** The value of the discount application. */
  value: Shopify_PricingValue;
};

/**
 * Properties used by customers to select a product variant.
 * Products can have multiple options, like different sizes or colors.
 *
 */
export type Shopify_SelectedOption = {
  __typename?: 'shopify_SelectedOption';
  /** The product options name. */
  name: Scalars['String'];
  /** The product options value. */
  value: Scalars['String'];
};

/** The input fields required for a selected option. */
export type Shopify_SelectedOptionInput = {
  /** The product options name. */
  name: Scalars['String'];
  /** The product options value. */
  value: Scalars['String'];
};

/** Represents how products and variants can be sold and purchased. */
export type Shopify_SellingPlan = {
  __typename?: 'shopify_SellingPlan';
  /** The initial payment due for the purchase. */
  checkoutCharge: Shopify_SellingPlanCheckoutCharge;
  /** The description of the selling plan. */
  description: Maybe<Scalars['String']>;
  /** A globally-unique ID. */
  id: Scalars['ID'];
  /** The name of the selling plan. For example, '6 weeks of prepaid granola, delivered weekly'. */
  name: Scalars['String'];
  /** The selling plan options available in the drop-down list in the storefront. For example, 'Delivery every week' or 'Delivery every 2 weeks' specifies the delivery frequency options for the product. Individual selling plans contribute their options to the associated selling plan group. For example, a selling plan group might have an option called `option1: Delivery every`. One selling plan in that group could contribute `option1: 2 weeks` with the pricing for that option, and another selling plan could contribute `option1: 4 weeks`, with different pricing. */
  options: Array<Shopify_SellingPlanOption>;
  /** The price adjustments that a selling plan makes when a variant is purchased with a selling plan. */
  priceAdjustments: Array<Shopify_SellingPlanPriceAdjustment>;
  /** Whether purchasing the selling plan will result in multiple deliveries. */
  recurringDeliveries: Scalars['Boolean'];
};

/** Represents an association between a variant and a selling plan. Selling plan allocations describe the options offered for each variant, and the price of the variant when purchased with a selling plan. */
export type Shopify_SellingPlanAllocation = {
  __typename?: 'shopify_SellingPlanAllocation';
  /** The checkout charge amount due for the purchase. */
  checkoutChargeAmount: Shopify_MoneyV2;
  /** A list of price adjustments, with a maximum of two. When there are two, the first price adjustment goes into effect at the time of purchase, while the second one starts after a certain number of orders. A price adjustment represents how a selling plan affects pricing when a variant is purchased with a selling plan. Prices display in the customer's currency if the shop is configured for it. */
  priceAdjustments: Array<Shopify_SellingPlanAllocationPriceAdjustment>;
  /** The remaining balance charge amount due for the purchase. */
  remainingBalanceChargeAmount: Shopify_MoneyV2;
  /** A representation of how products and variants can be sold and purchased. For example, an individual selling plan could be '6 weeks of prepaid granola, delivered weekly'. */
  sellingPlan: Shopify_SellingPlan;
};

/**
 * An auto-generated type for paginating through multiple SellingPlanAllocations.
 *
 */
export type Shopify_SellingPlanAllocationConnection = {
  __typename?: 'shopify_SellingPlanAllocationConnection';
  /** A list of edges. */
  edges: Array<Shopify_SellingPlanAllocationEdge>;
  /** A list of the nodes contained in SellingPlanAllocationEdge. */
  nodes: Array<Shopify_SellingPlanAllocation>;
  /** Information to aid in pagination. */
  pageInfo: Shopify_PageInfo;
};

/**
 * An auto-generated type which holds one SellingPlanAllocation and a cursor during pagination.
 *
 */
export type Shopify_SellingPlanAllocationEdge = {
  __typename?: 'shopify_SellingPlanAllocationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of SellingPlanAllocationEdge. */
  node: Shopify_SellingPlanAllocation;
};

/** The resulting prices for variants when they're purchased with a specific selling plan. */
export type Shopify_SellingPlanAllocationPriceAdjustment = {
  __typename?: 'shopify_SellingPlanAllocationPriceAdjustment';
  /** The price of the variant when it's purchased without a selling plan for the same number of deliveries. For example, if a customer purchases 6 deliveries of $10.00 granola separately, then the price is 6 x $10.00 = $60.00. */
  compareAtPrice: Shopify_MoneyV2;
  /** The effective price for a single delivery. For example, for a prepaid subscription plan that includes 6 deliveries at the price of $48.00, the per delivery price is $8.00. */
  perDeliveryPrice: Shopify_MoneyV2;
  /** The price of the variant when it's purchased with a selling plan For example, for a prepaid subscription plan that includes 6 deliveries of $10.00 granola, where the customer gets 20% off, the price is 6 x $10.00 x 0.80 = $48.00. */
  price: Shopify_MoneyV2;
  /** The resulting price per unit for the variant associated with the selling plan. If the variant isn't sold by quantity or measurement, then this field returns `null`. */
  unitPrice: Maybe<Shopify_MoneyV2>;
};

/** The initial payment due for the purchase. */
export type Shopify_SellingPlanCheckoutCharge = {
  __typename?: 'shopify_SellingPlanCheckoutCharge';
  /** The charge type for the checkout charge. */
  type: Shopify_SellingPlanCheckoutChargeType;
  /** The charge value for the checkout charge. */
  value: Shopify_SellingPlanCheckoutChargeValue;
};

/** The percentage value of the price used for checkout charge. */
export type Shopify_SellingPlanCheckoutChargePercentageValue = {
  __typename?: 'shopify_SellingPlanCheckoutChargePercentageValue';
  /** The percentage value of the price used for checkout charge. */
  percentage: Scalars['Float'];
};

/** The checkout charge when the full amount isn't charged at checkout. */
export enum Shopify_SellingPlanCheckoutChargeType {
  /** The checkout charge is a percentage of the product or variant price. */
  Percentage = 'PERCENTAGE',
  /** The checkout charge is a fixed price amount. */
  Price = 'PRICE',
}

/** The portion of the price to be charged at checkout. */
export type Shopify_SellingPlanCheckoutChargeValue =
  | Shopify_MoneyV2
  | Shopify_SellingPlanCheckoutChargePercentageValue;

/**
 * An auto-generated type for paginating through multiple SellingPlans.
 *
 */
export type Shopify_SellingPlanConnection = {
  __typename?: 'shopify_SellingPlanConnection';
  /** A list of edges. */
  edges: Array<Shopify_SellingPlanEdge>;
  /** A list of the nodes contained in SellingPlanEdge. */
  nodes: Array<Shopify_SellingPlan>;
  /** Information to aid in pagination. */
  pageInfo: Shopify_PageInfo;
};

/**
 * An auto-generated type which holds one SellingPlan and a cursor during pagination.
 *
 */
export type Shopify_SellingPlanEdge = {
  __typename?: 'shopify_SellingPlanEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of SellingPlanEdge. */
  node: Shopify_SellingPlan;
};

/** A fixed amount that's deducted from the original variant price. For example, $10.00 off. */
export type Shopify_SellingPlanFixedAmountPriceAdjustment = {
  __typename?: 'shopify_SellingPlanFixedAmountPriceAdjustment';
  /** The money value of the price adjustment. */
  adjustmentAmount: Shopify_MoneyV2;
};

/** A fixed price adjustment for a variant that's purchased with a selling plan. */
export type Shopify_SellingPlanFixedPriceAdjustment = {
  __typename?: 'shopify_SellingPlanFixedPriceAdjustment';
  /** A new price of the variant when it's purchased with the selling plan. */
  price: Shopify_MoneyV2;
};

/** Represents a selling method. For example, 'Subscribe and save' is a selling method where customers pay for goods or services per delivery. A selling plan group contains individual selling plans. */
export type Shopify_SellingPlanGroup = {
  __typename?: 'shopify_SellingPlanGroup';
  /** A display friendly name for the app that created the selling plan group. */
  appName: Maybe<Scalars['String']>;
  /** The name of the selling plan group. */
  name: Scalars['String'];
  /** Represents the selling plan options available in the drop-down list in the storefront. For example, 'Delivery every week' or 'Delivery every 2 weeks' specifies the delivery frequency options for the product. */
  options: Array<Shopify_SellingPlanGroupOption>;
  /** A list of selling plans in a selling plan group. A selling plan is a representation of how products and variants can be sold and purchased. For example, an individual selling plan could be '6 weeks of prepaid granola, delivered weekly'. */
  sellingPlans: Shopify_SellingPlanConnection;
};

/** Represents a selling method. For example, 'Subscribe and save' is a selling method where customers pay for goods or services per delivery. A selling plan group contains individual selling plans. */
export type Shopify_SellingPlanGroupSellingPlansArgs = {
  after: InputMaybe<Scalars['String']>;
  before: InputMaybe<Scalars['String']>;
  first: InputMaybe<Scalars['Int']>;
  last: InputMaybe<Scalars['Int']>;
  reverse?: InputMaybe<Scalars['Boolean']>;
};

/**
 * An auto-generated type for paginating through multiple SellingPlanGroups.
 *
 */
export type Shopify_SellingPlanGroupConnection = {
  __typename?: 'shopify_SellingPlanGroupConnection';
  /** A list of edges. */
  edges: Array<Shopify_SellingPlanGroupEdge>;
  /** A list of the nodes contained in SellingPlanGroupEdge. */
  nodes: Array<Shopify_SellingPlanGroup>;
  /** Information to aid in pagination. */
  pageInfo: Shopify_PageInfo;
};

/**
 * An auto-generated type which holds one SellingPlanGroup and a cursor during pagination.
 *
 */
export type Shopify_SellingPlanGroupEdge = {
  __typename?: 'shopify_SellingPlanGroupEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of SellingPlanGroupEdge. */
  node: Shopify_SellingPlanGroup;
};

/**
 * Represents an option on a selling plan group that's available in the drop-down list in the storefront.
 *
 * Individual selling plans contribute their options to the associated selling plan group. For example, a selling plan group might have an option called `option1: Delivery every`. One selling plan in that group could contribute `option1: 2 weeks` with the pricing for that option, and another selling plan could contribute `option1: 4 weeks`, with different pricing.
 */
export type Shopify_SellingPlanGroupOption = {
  __typename?: 'shopify_SellingPlanGroupOption';
  /** The name of the option. For example, 'Delivery every'. */
  name: Scalars['String'];
  /** The values for the options specified by the selling plans in the selling plan group. For example, '1 week', '2 weeks', '3 weeks'. */
  values: Array<Scalars['String']>;
};

/** An option provided by a Selling Plan. */
export type Shopify_SellingPlanOption = {
  __typename?: 'shopify_SellingPlanOption';
  /** The name of the option (ie "Delivery every"). */
  name: Maybe<Scalars['String']>;
  /** The value of the option (ie "Month"). */
  value: Maybe<Scalars['String']>;
};

/** A percentage amount that's deducted from the original variant price. For example, 10% off. */
export type Shopify_SellingPlanPercentagePriceAdjustment = {
  __typename?: 'shopify_SellingPlanPercentagePriceAdjustment';
  /** The percentage value of the price adjustment. */
  adjustmentPercentage: Scalars['Int'];
};

/** Represents by how much the price of a variant associated with a selling plan is adjusted. Each variant can have up to two price adjustments. If a variant has multiple price adjustments, then the first price adjustment applies when the variant is initially purchased. The second price adjustment applies after a certain number of orders (specified by the `orderCount` field) are made. If a selling plan doesn't have any price adjustments, then the unadjusted price of the variant is the effective price. */
export type Shopify_SellingPlanPriceAdjustment = {
  __typename?: 'shopify_SellingPlanPriceAdjustment';
  /** The type of price adjustment. An adjustment value can have one of three types: percentage, amount off, or a new price. */
  adjustmentValue: Shopify_SellingPlanPriceAdjustmentValue;
  /** The number of orders that the price adjustment applies to. If the price adjustment always applies, then this field is `null`. */
  orderCount: Maybe<Scalars['Int']>;
};

/** Represents by how much the price of a variant associated with a selling plan is adjusted. Each variant can have up to two price adjustments. */
export type Shopify_SellingPlanPriceAdjustmentValue =
  | Shopify_SellingPlanFixedAmountPriceAdjustment
  | Shopify_SellingPlanFixedPriceAdjustment
  | Shopify_SellingPlanPercentagePriceAdjustment;

/** A shipping rate to be applied to a checkout. */
export type Shopify_ShippingRate = {
  __typename?: 'shopify_ShippingRate';
  /** Human-readable unique identifier for this shipping rate. */
  handle: Scalars['String'];
  /** Price of this shipping rate. */
  price: Shopify_MoneyV2;
  /** Price of this shipping rate. */
  priceV2: Shopify_MoneyV2;
  /** Title of this shipping rate. */
  title: Scalars['String'];
};

/** Shop represents a collection of the general settings and information about the shop. */
export type Shopify_Shop = Shopify_HasMetafields &
  Shopify_Node & {
    __typename?: 'shopify_Shop';
    /** The shop's branding configuration. */
    brand: Maybe<Shopify_Brand>;
    /** A description of the shop. */
    description: Maybe<Scalars['String']>;
    /** A globally-unique ID. */
    id: Scalars['ID'];
    /** Returns a metafield found by namespace and key. */
    metafield: Maybe<Shopify_Metafield>;
    /** The metafields associated with the resource matching the supplied list of namespaces and keys. */
    metafields: Array<Maybe<Shopify_Metafield>>;
    /** A string representing the way currency is formatted when the currency isnt specified. */
    moneyFormat: Scalars['String'];
    /** The shops name. */
    name: Scalars['String'];
    /** Settings related to payments. */
    paymentSettings: Shopify_PaymentSettings;
    /** The primary domain of the shops Online Store. */
    primaryDomain: Shopify_Domain;
    /** The shops privacy policy. */
    privacyPolicy: Maybe<Shopify_ShopPolicy>;
    /** The shops refund policy. */
    refundPolicy: Maybe<Shopify_ShopPolicy>;
    /** The shops shipping policy. */
    shippingPolicy: Maybe<Shopify_ShopPolicy>;
    /** Countries that the shop ships to. */
    shipsToCountries: Array<Shopify_CountryCode>;
    /** The shops subscription policy. */
    subscriptionPolicy: Maybe<Shopify_ShopPolicyWithDefault>;
    /** The shops terms of service. */
    termsOfService: Maybe<Shopify_ShopPolicy>;
  };

/** Shop represents a collection of the general settings and information about the shop. */
export type Shopify_ShopMetafieldArgs = {
  key: Scalars['String'];
  namespace: Scalars['String'];
};

/** Shop represents a collection of the general settings and information about the shop. */
export type Shopify_ShopMetafieldsArgs = {
  identifiers: Array<Shopify_HasMetafieldsIdentifier>;
};

/**
 * The input fields for submitting Shop Pay payment method information for checkout.
 *
 */
export type Shopify_ShopPayWalletContentInput = {
  /** The customer's billing address. */
  billingAddress: Shopify_MailingAddressInput;
  /** Session token for transaction. */
  sessionToken: Scalars['String'];
};

/** Policy that a merchant has configured for their store, such as their refund or privacy policy. */
export type Shopify_ShopPolicy = Shopify_Node & {
  __typename?: 'shopify_ShopPolicy';
  /** Policy text, maximum size of 64kb. */
  body: Scalars['String'];
  /** Policys handle. */
  handle: Scalars['String'];
  /** A globally-unique ID. */
  id: Scalars['ID'];
  /** Policys title. */
  title: Scalars['String'];
  /** Public URL to the policy. */
  url: Scalars['shopify_URL'];
};

/**
 * A policy for the store that comes with a default value, such as a subscription policy.
 * If the merchant hasn't configured a policy for their store, then the policy will return the default value.
 * Otherwise, the policy will return the merchant-configured value.
 *
 */
export type Shopify_ShopPolicyWithDefault = {
  __typename?: 'shopify_ShopPolicyWithDefault';
  /** The text of the policy. Maximum size: 64KB. */
  body: Scalars['String'];
  /** The handle of the policy. */
  handle: Scalars['String'];
  /** The unique ID of the policy. A default policy doesn't have an ID. */
  id: Maybe<Scalars['ID']>;
  /** The title of the policy. */
  title: Scalars['String'];
  /** Public URL to the policy. */
  url: Scalars['shopify_URL'];
};

/**
 * The availability of a product variant at a particular location.
 * Local pick-up must be enabled in the  store's shipping settings, otherwise this will return an empty result.
 *
 */
export type Shopify_StoreAvailability = {
  __typename?: 'shopify_StoreAvailability';
  /** Whether the product variant is in-stock at this location. */
  available: Scalars['Boolean'];
  /** The location where this product variant is stocked at. */
  location: Shopify_Location;
  /** Returns the estimated amount of time it takes for pickup to be ready (Example: Usually ready in 24 hours). */
  pickUpTime: Scalars['String'];
};

/**
 * An auto-generated type for paginating through multiple StoreAvailabilities.
 *
 */
export type Shopify_StoreAvailabilityConnection = {
  __typename?: 'shopify_StoreAvailabilityConnection';
  /** A list of edges. */
  edges: Array<Shopify_StoreAvailabilityEdge>;
  /** A list of the nodes contained in StoreAvailabilityEdge. */
  nodes: Array<Shopify_StoreAvailability>;
  /** Information to aid in pagination. */
  pageInfo: Shopify_PageInfo;
};

/**
 * An auto-generated type which holds one StoreAvailability and a cursor during pagination.
 *
 */
export type Shopify_StoreAvailabilityEdge = {
  __typename?: 'shopify_StoreAvailabilityEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of StoreAvailabilityEdge. */
  node: Shopify_StoreAvailability;
};

/**
 * An auto-generated type for paginating through a list of Strings.
 *
 */
export type Shopify_StringConnection = {
  __typename?: 'shopify_StringConnection';
  /** A list of edges. */
  edges: Array<Shopify_StringEdge>;
  /** Information to aid in pagination. */
  pageInfo: Shopify_PageInfo;
};

/**
 * An auto-generated type which holds one String and a cursor during pagination.
 *
 */
export type Shopify_StringEdge = {
  __typename?: 'shopify_StringEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of StringEdge. */
  node: Scalars['String'];
};

/** An error that occurred during cart submit for completion. */
export type Shopify_SubmissionError = {
  __typename?: 'shopify_SubmissionError';
  /** The error code. */
  code: Shopify_SubmissionErrorCode;
  /** The error message. */
  message: Maybe<Scalars['String']>;
};

/** The code of the error that occurred during cart submit for completion. */
export enum Shopify_SubmissionErrorCode {
  BuyerIdentityEmailIsInvalid = 'BUYER_IDENTITY_EMAIL_IS_INVALID',
  BuyerIdentityEmailRequired = 'BUYER_IDENTITY_EMAIL_REQUIRED',
  BuyerIdentityPhoneIsInvalid = 'BUYER_IDENTITY_PHONE_IS_INVALID',
  DeliveryAddress1Invalid = 'DELIVERY_ADDRESS1_INVALID',
  DeliveryAddress1Required = 'DELIVERY_ADDRESS1_REQUIRED',
  DeliveryAddress1TooLong = 'DELIVERY_ADDRESS1_TOO_LONG',
  DeliveryAddress2Invalid = 'DELIVERY_ADDRESS2_INVALID',
  DeliveryAddress2Required = 'DELIVERY_ADDRESS2_REQUIRED',
  DeliveryAddress2TooLong = 'DELIVERY_ADDRESS2_TOO_LONG',
  DeliveryAddressRequired = 'DELIVERY_ADDRESS_REQUIRED',
  DeliveryCityInvalid = 'DELIVERY_CITY_INVALID',
  DeliveryCityRequired = 'DELIVERY_CITY_REQUIRED',
  DeliveryCityTooLong = 'DELIVERY_CITY_TOO_LONG',
  DeliveryCompanyInvalid = 'DELIVERY_COMPANY_INVALID',
  DeliveryCompanyRequired = 'DELIVERY_COMPANY_REQUIRED',
  DeliveryCompanyTooLong = 'DELIVERY_COMPANY_TOO_LONG',
  DeliveryCountryRequired = 'DELIVERY_COUNTRY_REQUIRED',
  DeliveryFirstNameInvalid = 'DELIVERY_FIRST_NAME_INVALID',
  DeliveryFirstNameRequired = 'DELIVERY_FIRST_NAME_REQUIRED',
  DeliveryFirstNameTooLong = 'DELIVERY_FIRST_NAME_TOO_LONG',
  DeliveryInvalidPostalCodeForCountry = 'DELIVERY_INVALID_POSTAL_CODE_FOR_COUNTRY',
  DeliveryInvalidPostalCodeForZone = 'DELIVERY_INVALID_POSTAL_CODE_FOR_ZONE',
  DeliveryLastNameInvalid = 'DELIVERY_LAST_NAME_INVALID',
  DeliveryLastNameRequired = 'DELIVERY_LAST_NAME_REQUIRED',
  DeliveryLastNameTooLong = 'DELIVERY_LAST_NAME_TOO_LONG',
  DeliveryNoDeliveryAvailable = 'DELIVERY_NO_DELIVERY_AVAILABLE',
  DeliveryNoDeliveryAvailableForMerchandiseLine = 'DELIVERY_NO_DELIVERY_AVAILABLE_FOR_MERCHANDISE_LINE',
  DeliveryOptionsPhoneNumberInvalid = 'DELIVERY_OPTIONS_PHONE_NUMBER_INVALID',
  DeliveryOptionsPhoneNumberRequired = 'DELIVERY_OPTIONS_PHONE_NUMBER_REQUIRED',
  DeliveryPhoneNumberInvalid = 'DELIVERY_PHONE_NUMBER_INVALID',
  DeliveryPhoneNumberRequired = 'DELIVERY_PHONE_NUMBER_REQUIRED',
  DeliveryPostalCodeInvalid = 'DELIVERY_POSTAL_CODE_INVALID',
  DeliveryPostalCodeRequired = 'DELIVERY_POSTAL_CODE_REQUIRED',
  DeliveryZoneNotFound = 'DELIVERY_ZONE_NOT_FOUND',
  DeliveryZoneRequiredForCountry = 'DELIVERY_ZONE_REQUIRED_FOR_COUNTRY',
  Error = 'ERROR',
  MerchandiseLineLimitReached = 'MERCHANDISE_LINE_LIMIT_REACHED',
  MerchandiseNotApplicable = 'MERCHANDISE_NOT_APPLICABLE',
  MerchandiseNotEnoughStockAvailable = 'MERCHANDISE_NOT_ENOUGH_STOCK_AVAILABLE',
  MerchandiseOutOfStock = 'MERCHANDISE_OUT_OF_STOCK',
  MerchandiseProductNotPublished = 'MERCHANDISE_PRODUCT_NOT_PUBLISHED',
  NoDeliveryGroupSelected = 'NO_DELIVERY_GROUP_SELECTED',
  PaymentsAddress1Invalid = 'PAYMENTS_ADDRESS1_INVALID',
  PaymentsAddress1Required = 'PAYMENTS_ADDRESS1_REQUIRED',
  PaymentsAddress1TooLong = 'PAYMENTS_ADDRESS1_TOO_LONG',
  PaymentsAddress2Invalid = 'PAYMENTS_ADDRESS2_INVALID',
  PaymentsAddress2Required = 'PAYMENTS_ADDRESS2_REQUIRED',
  PaymentsAddress2TooLong = 'PAYMENTS_ADDRESS2_TOO_LONG',
  PaymentsBillingAddressZoneNotFound = 'PAYMENTS_BILLING_ADDRESS_ZONE_NOT_FOUND',
  PaymentsBillingAddressZoneRequiredForCountry = 'PAYMENTS_BILLING_ADDRESS_ZONE_REQUIRED_FOR_COUNTRY',
  PaymentsCityInvalid = 'PAYMENTS_CITY_INVALID',
  PaymentsCityRequired = 'PAYMENTS_CITY_REQUIRED',
  PaymentsCityTooLong = 'PAYMENTS_CITY_TOO_LONG',
  PaymentsCompanyInvalid = 'PAYMENTS_COMPANY_INVALID',
  PaymentsCompanyRequired = 'PAYMENTS_COMPANY_REQUIRED',
  PaymentsCompanyTooLong = 'PAYMENTS_COMPANY_TOO_LONG',
  PaymentsCountryRequired = 'PAYMENTS_COUNTRY_REQUIRED',
  PaymentsCreditCardBaseExpired = 'PAYMENTS_CREDIT_CARD_BASE_EXPIRED',
  PaymentsCreditCardBaseGatewayNotSupported = 'PAYMENTS_CREDIT_CARD_BASE_GATEWAY_NOT_SUPPORTED',
  PaymentsCreditCardBaseInvalidStartDateOrIssueNumberForDebit = 'PAYMENTS_CREDIT_CARD_BASE_INVALID_START_DATE_OR_ISSUE_NUMBER_FOR_DEBIT',
  PaymentsCreditCardBrandNotSupported = 'PAYMENTS_CREDIT_CARD_BRAND_NOT_SUPPORTED',
  PaymentsCreditCardFirstNameBlank = 'PAYMENTS_CREDIT_CARD_FIRST_NAME_BLANK',
  PaymentsCreditCardGeneric = 'PAYMENTS_CREDIT_CARD_GENERIC',
  PaymentsCreditCardLastNameBlank = 'PAYMENTS_CREDIT_CARD_LAST_NAME_BLANK',
  PaymentsCreditCardMonthInclusion = 'PAYMENTS_CREDIT_CARD_MONTH_INCLUSION',
  PaymentsCreditCardNameInvalid = 'PAYMENTS_CREDIT_CARD_NAME_INVALID',
  PaymentsCreditCardNumberInvalid = 'PAYMENTS_CREDIT_CARD_NUMBER_INVALID',
  PaymentsCreditCardNumberInvalidFormat = 'PAYMENTS_CREDIT_CARD_NUMBER_INVALID_FORMAT',
  PaymentsCreditCardSessionId = 'PAYMENTS_CREDIT_CARD_SESSION_ID',
  PaymentsCreditCardVerificationValueBlank = 'PAYMENTS_CREDIT_CARD_VERIFICATION_VALUE_BLANK',
  PaymentsCreditCardVerificationValueInvalidForCardType = 'PAYMENTS_CREDIT_CARD_VERIFICATION_VALUE_INVALID_FOR_CARD_TYPE',
  PaymentsCreditCardYearExpired = 'PAYMENTS_CREDIT_CARD_YEAR_EXPIRED',
  PaymentsCreditCardYearInvalidExpiryYear = 'PAYMENTS_CREDIT_CARD_YEAR_INVALID_EXPIRY_YEAR',
  PaymentsFirstNameInvalid = 'PAYMENTS_FIRST_NAME_INVALID',
  PaymentsFirstNameRequired = 'PAYMENTS_FIRST_NAME_REQUIRED',
  PaymentsFirstNameTooLong = 'PAYMENTS_FIRST_NAME_TOO_LONG',
  PaymentsInvalidPostalCodeForCountry = 'PAYMENTS_INVALID_POSTAL_CODE_FOR_COUNTRY',
  PaymentsInvalidPostalCodeForZone = 'PAYMENTS_INVALID_POSTAL_CODE_FOR_ZONE',
  PaymentsLastNameInvalid = 'PAYMENTS_LAST_NAME_INVALID',
  PaymentsLastNameRequired = 'PAYMENTS_LAST_NAME_REQUIRED',
  PaymentsLastNameTooLong = 'PAYMENTS_LAST_NAME_TOO_LONG',
  PaymentsMethodRequired = 'PAYMENTS_METHOD_REQUIRED',
  PaymentsMethodUnavailable = 'PAYMENTS_METHOD_UNAVAILABLE',
  PaymentsPhoneNumberInvalid = 'PAYMENTS_PHONE_NUMBER_INVALID',
  PaymentsPhoneNumberRequired = 'PAYMENTS_PHONE_NUMBER_REQUIRED',
  PaymentsPostalCodeInvalid = 'PAYMENTS_POSTAL_CODE_INVALID',
  PaymentsPostalCodeRequired = 'PAYMENTS_POSTAL_CODE_REQUIRED',
  PaymentsShopifyPaymentsRequired = 'PAYMENTS_SHOPIFY_PAYMENTS_REQUIRED',
  PaymentsUnacceptablePaymentAmount = 'PAYMENTS_UNACCEPTABLE_PAYMENT_AMOUNT',
  PaymentsWalletContentMissing = 'PAYMENTS_WALLET_CONTENT_MISSING',
  TaxesDeliveryGroupIdNotFound = 'TAXES_DELIVERY_GROUP_ID_NOT_FOUND',
  TaxesLineIdNotFound = 'TAXES_LINE_ID_NOT_FOUND',
  TaxesMustBeDefined = 'TAXES_MUST_BE_DEFINED',
}

/** Cart submit for checkout completion is successful. */
export type Shopify_SubmitAlreadyAccepted = {
  __typename?: 'shopify_SubmitAlreadyAccepted';
  /** The ID of the cart completion attempt that will be used for polling for the result. */
  attemptId: Scalars['String'];
};

/** Cart submit for checkout completion failed. */
export type Shopify_SubmitFailed = {
  __typename?: 'shopify_SubmitFailed';
  /** The URL of the checkout for the cart. */
  checkoutUrl: Maybe<Scalars['shopify_URL']>;
  /** The list of errors that occurred from executing the mutation. */
  errors: Array<Shopify_SubmissionError>;
};

/** Cart submit for checkout completion is already accepted. */
export type Shopify_SubmitSuccess = {
  __typename?: 'shopify_SubmitSuccess';
  /** The ID of the cart completion attempt that will be used for polling for the result. */
  attemptId: Scalars['String'];
};

/** Cart submit for checkout completion is throttled. */
export type Shopify_SubmitThrottled = {
  __typename?: 'shopify_SubmitThrottled';
  /**
   * UTC date time string that indicates the time after which clients should make their next
   * poll request. Any poll requests sent before this time will be ignored. Use this value to schedule the
   * next poll request.
   *
   */
  pollAfter: Scalars['shopify_DateTime'];
};

/**
 * Specifies the fields required to complete a checkout with
 * a tokenized payment.
 *
 */
export type Shopify_TokenizedPaymentInputV3 = {
  /** The billing address for the payment. */
  billingAddress: Shopify_MailingAddressInput;
  /** A unique client generated key used to avoid duplicate charges. When a duplicate payment is found, the original is returned instead of creating a new one. For more information, refer to [Idempotent requests](https://shopify.dev/api/usage/idempotent-requests). */
  idempotencyKey: Scalars['String'];
  /** Public Hash Key used for AndroidPay payments only. */
  identifier: InputMaybe<Scalars['String']>;
  /** The amount and currency of the payment. */
  paymentAmount: Shopify_MoneyInput;
  /** A simple string or JSON containing the required payment data for the tokenized payment. */
  paymentData: Scalars['String'];
  /** Whether to execute the payment in test mode, if possible. Test mode isn't supported in production stores. Defaults to `false`. */
  test: InputMaybe<Scalars['Boolean']>;
  /** The type of payment token. */
  type: Shopify_PaymentTokenType;
};

/** An object representing exchange of money for a product or service. */
export type Shopify_Transaction = {
  __typename?: 'shopify_Transaction';
  /** The amount of money that the transaction was for. */
  amount: Shopify_MoneyV2;
  /** The amount of money that the transaction was for. */
  amountV2: Shopify_MoneyV2;
  /** The kind of the transaction. */
  kind: Shopify_TransactionKind;
  /** The status of the transaction. */
  status: Shopify_TransactionStatus;
  /** The status of the transaction. */
  statusV2: Maybe<Shopify_TransactionStatus>;
  /** Whether the transaction was done in test mode or not. */
  test: Scalars['Boolean'];
};

/** The different kinds of order transactions. */
export enum Shopify_TransactionKind {
  /**
   * An amount reserved against the cardholder's funding source.
   * Money does not change hands until the authorization is captured.
   *
   */
  Authorization = 'AUTHORIZATION',
  /** A transfer of the money that was reserved during the authorization stage. */
  Capture = 'CAPTURE',
  /** Money returned to the customer when they have paid too much. */
  Change = 'CHANGE',
  /** An authorization for a payment taken with an EMV credit card reader. */
  EmvAuthorization = 'EMV_AUTHORIZATION',
  /** An authorization and capture performed together in a single step. */
  Sale = 'SALE',
}

/** Transaction statuses describe the status of a transaction. */
export enum Shopify_TransactionStatus {
  /** There was an error while processing the transaction. */
  Error = 'ERROR',
  /** The transaction failed. */
  Failure = 'FAILURE',
  /** The transaction is pending. */
  Pending = 'PENDING',
  /** The transaction succeeded. */
  Success = 'SUCCESS',
}

/**
 * The measurement used to calculate a unit price for a product variant (e.g. $9.99 / 100ml).
 *
 */
export type Shopify_UnitPriceMeasurement = {
  __typename?: 'shopify_UnitPriceMeasurement';
  /** The type of unit of measurement for the unit price measurement. */
  measuredType: Maybe<Shopify_UnitPriceMeasurementMeasuredType>;
  /** The quantity unit for the unit price measurement. */
  quantityUnit: Maybe<Shopify_UnitPriceMeasurementMeasuredUnit>;
  /** The quantity value for the unit price measurement. */
  quantityValue: Scalars['Float'];
  /** The reference unit for the unit price measurement. */
  referenceUnit: Maybe<Shopify_UnitPriceMeasurementMeasuredUnit>;
  /** The reference value for the unit price measurement. */
  referenceValue: Scalars['Int'];
};

/** The accepted types of unit of measurement. */
export enum Shopify_UnitPriceMeasurementMeasuredType {
  /** Unit of measurements representing areas. */
  Area = 'AREA',
  /** Unit of measurements representing lengths. */
  Length = 'LENGTH',
  /** Unit of measurements representing volumes. */
  Volume = 'VOLUME',
  /** Unit of measurements representing weights. */
  Weight = 'WEIGHT',
}

/** The valid units of measurement for a unit price measurement. */
export enum Shopify_UnitPriceMeasurementMeasuredUnit {
  /** 100 centiliters equals 1 liter. */
  Cl = 'CL',
  /** 100 centimeters equals 1 meter. */
  Cm = 'CM',
  /** Metric system unit of weight. */
  G = 'G',
  /** 1 kilogram equals 1000 grams. */
  Kg = 'KG',
  /** Metric system unit of volume. */
  L = 'L',
  /** Metric system unit of length. */
  M = 'M',
  /** Metric system unit of area. */
  M2 = 'M2',
  /** 1 cubic meter equals 1000 liters. */
  M3 = 'M3',
  /** 1000 milligrams equals 1 gram. */
  Mg = 'MG',
  /** 1000 milliliters equals 1 liter. */
  Ml = 'ML',
  /** 1000 millimeters equals 1 meter. */
  Mm = 'MM',
}

/** Systems of weights and measures. */
export enum Shopify_UnitSystem {
  /** Imperial system of weights and measures. */
  ImperialSystem = 'IMPERIAL_SYSTEM',
  /** Metric system of weights and measures. */
  MetricSystem = 'METRIC_SYSTEM',
}

/** A redirect on the online store. */
export type Shopify_UrlRedirect = Shopify_Node & {
  __typename?: 'shopify_UrlRedirect';
  /** The ID of the URL redirect. */
  id: Scalars['ID'];
  /** The old path to be redirected from. When the user visits this path, they'll be redirected to the target location. */
  path: Scalars['String'];
  /** The target location where the user will be redirected to. */
  target: Scalars['String'];
};

/**
 * An auto-generated type for paginating through multiple UrlRedirects.
 *
 */
export type Shopify_UrlRedirectConnection = {
  __typename?: 'shopify_UrlRedirectConnection';
  /** A list of edges. */
  edges: Array<Shopify_UrlRedirectEdge>;
  /** A list of the nodes contained in UrlRedirectEdge. */
  nodes: Array<Shopify_UrlRedirect>;
  /** Information to aid in pagination. */
  pageInfo: Shopify_PageInfo;
};

/**
 * An auto-generated type which holds one UrlRedirect and a cursor during pagination.
 *
 */
export type Shopify_UrlRedirectEdge = {
  __typename?: 'shopify_UrlRedirectEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of UrlRedirectEdge. */
  node: Shopify_UrlRedirect;
};

/** Represents an error in the input of a mutation. */
export type Shopify_UserError = Shopify_DisplayableError & {
  __typename?: 'shopify_UserError';
  /** The path to the input field that caused the error. */
  field: Maybe<Array<Scalars['String']>>;
  /** The error message. */
  message: Scalars['String'];
};

/** The input fields for a filter used to view a subset of products in a collection matching a specific variant option. */
export type Shopify_VariantOptionFilter = {
  /** The name of the variant option to filter on. */
  name: Scalars['String'];
  /** The value of the variant option to filter on. */
  value: Scalars['String'];
};

/** Represents a Shopify hosted video. */
export type Shopify_Video = Shopify_Media &
  Shopify_Node & {
    __typename?: 'shopify_Video';
    /** A word or phrase to share the nature or contents of a media. */
    alt: Maybe<Scalars['String']>;
    /** A globally-unique ID. */
    id: Scalars['ID'];
    /** The media content type. */
    mediaContentType: Shopify_MediaContentType;
    /** The presentation for a media. */
    presentation: Maybe<Shopify_MediaPresentation>;
    /** The preview image for the media. */
    previewImage: Maybe<Shopify_Image>;
    /** The sources for a video. */
    sources: Array<Shopify_VideoSource>;
  };

/** Represents a source for a Shopify hosted video. */
export type Shopify_VideoSource = {
  __typename?: 'shopify_VideoSource';
  /** The format of the video source. */
  format: Scalars['String'];
  /** The height of the video. */
  height: Scalars['Int'];
  /** The video MIME type. */
  mimeType: Scalars['String'];
  /** The URL of the video. */
  url: Scalars['String'];
  /** The width of the video. */
  width: Scalars['Int'];
};

/** Units of measurement for weight. */
export enum Shopify_WeightUnit {
  /** Metric system unit of mass. */
  Grams = 'GRAMS',
  /** 1 kilogram equals 1000 grams. */
  Kilograms = 'KILOGRAMS',
  /** Imperial system unit of mass. */
  Ounces = 'OUNCES',
  /** 1 pound equals 16 ounces. */
  Pounds = 'POUNDS',
}

export type Subscription_Root = {
  __typename?: 'subscription_root';
  /** fetch data from the table: "Checkout" */
  Checkout: Array<Checkout>;
  /** fetch aggregated fields from the table: "Checkout" */
  Checkout_aggregate: Checkout_Aggregate;
  /** fetch data from the table: "Checkout" using primary key columns */
  Checkout_by_pk: Maybe<Checkout>;
  /** fetch data from the table in a streaming manner: "Checkout" */
  Checkout_stream: Array<Checkout>;
  /** fetch data from the table: "Collection" */
  Collection: Array<Collection>;
  /** fetch aggregated fields from the table: "Collection" */
  Collection_aggregate: Collection_Aggregate;
  /** fetch data from the table: "Collection" using primary key columns */
  Collection_by_pk: Maybe<Collection>;
  /** fetch data from the table in a streaming manner: "Collection" */
  Collection_stream: Array<Collection>;
  /** fetch data from the table: "Customer" */
  Customer: Array<Customer>;
  /** fetch aggregated fields from the table: "Customer" */
  Customer_aggregate: Customer_Aggregate;
  /** fetch data from the table: "Customer" using primary key columns */
  Customer_by_pk: Maybe<Customer>;
  /** fetch data from the table in a streaming manner: "Customer" */
  Customer_stream: Array<Customer>;
  /** fetch data from the table: "Dispute" */
  Dispute: Array<Dispute>;
  /** fetch data from the table: "DisputeAttachment" */
  DisputeAttachment: Array<DisputeAttachment>;
  /** fetch aggregated fields from the table: "DisputeAttachment" */
  DisputeAttachment_aggregate: DisputeAttachment_Aggregate;
  /** fetch data from the table: "DisputeAttachment" using primary key columns */
  DisputeAttachment_by_pk: Maybe<DisputeAttachment>;
  /** fetch data from the table in a streaming manner: "DisputeAttachment" */
  DisputeAttachment_stream: Array<DisputeAttachment>;
  /** fetch aggregated fields from the table: "Dispute" */
  Dispute_aggregate: Dispute_Aggregate;
  /** fetch data from the table: "Dispute" using primary key columns */
  Dispute_by_pk: Maybe<Dispute>;
  /** fetch data from the table in a streaming manner: "Dispute" */
  Dispute_stream: Array<Dispute>;
  /** fetch data from the table: "Event" */
  Event: Array<Event>;
  /** fetch aggregated fields from the table: "Event" */
  Event_aggregate: Event_Aggregate;
  /** fetch data from the table: "Event" using primary key columns */
  Event_by_pk: Maybe<Event>;
  /** fetch data from the table in a streaming manner: "Event" */
  Event_stream: Array<Event>;
  /** fetch data from the table: "FacetFilter" */
  FacetFilter: Array<FacetFilter>;
  /** fetch aggregated fields from the table: "FacetFilter" */
  FacetFilter_aggregate: FacetFilter_Aggregate;
  /** fetch data from the table: "FacetFilter" using primary key columns */
  FacetFilter_by_pk: Maybe<FacetFilter>;
  /** fetch data from the table in a streaming manner: "FacetFilter" */
  FacetFilter_stream: Array<FacetFilter>;
  /** fetch data from the table: "FavoriteProducts" */
  FavoriteProducts: Array<FavoriteProducts>;
  /** fetch aggregated fields from the table: "FavoriteProducts" */
  FavoriteProducts_aggregate: FavoriteProducts_Aggregate;
  /** fetch data from the table: "FavoriteProducts" using primary key columns */
  FavoriteProducts_by_pk: Maybe<FavoriteProducts>;
  /** fetch data from the table in a streaming manner: "FavoriteProducts" */
  FavoriteProducts_stream: Array<FavoriteProducts>;
  /** fetch data from the table: "Fulfillment" */
  Fulfillment: Array<Fulfillment>;
  /** fetch data from the table: "FulfillmentItem" */
  FulfillmentItem: Array<FulfillmentItem>;
  /** fetch aggregated fields from the table: "FulfillmentItem" */
  FulfillmentItem_aggregate: FulfillmentItem_Aggregate;
  /** fetch data from the table: "FulfillmentItem" using primary key columns */
  FulfillmentItem_by_pk: Maybe<FulfillmentItem>;
  /** fetch data from the table in a streaming manner: "FulfillmentItem" */
  FulfillmentItem_stream: Array<FulfillmentItem>;
  /** fetch data from the table: "FulfillmentOrder" */
  FulfillmentOrder: Array<FulfillmentOrder>;
  /** fetch aggregated fields from the table: "FulfillmentOrder" */
  FulfillmentOrder_aggregate: FulfillmentOrder_Aggregate;
  /** fetch data from the table: "FulfillmentOrder" using primary key columns */
  FulfillmentOrder_by_pk: Maybe<FulfillmentOrder>;
  /** fetch data from the table in a streaming manner: "FulfillmentOrder" */
  FulfillmentOrder_stream: Array<FulfillmentOrder>;
  /** fetch aggregated fields from the table: "Fulfillment" */
  Fulfillment_aggregate: Fulfillment_Aggregate;
  /** fetch data from the table: "Fulfillment" using primary key columns */
  Fulfillment_by_pk: Maybe<Fulfillment>;
  /** fetch data from the table in a streaming manner: "Fulfillment" */
  Fulfillment_stream: Array<Fulfillment>;
  /** fetch data from the table: "NegociationAgreement" */
  NegociationAgreement: Array<NegociationAgreement>;
  /** fetch aggregated fields from the table: "NegociationAgreement" */
  NegociationAgreement_aggregate: NegociationAgreement_Aggregate;
  /** fetch data from the table: "NegociationAgreement" using primary key columns */
  NegociationAgreement_by_pk: Maybe<NegociationAgreement>;
  /** fetch data from the table in a streaming manner: "NegociationAgreement" */
  NegociationAgreement_stream: Array<NegociationAgreement>;
  /** fetch data from the table: "NumericFilter" */
  NumericFilter: Array<NumericFilter>;
  /** fetch aggregated fields from the table: "NumericFilter" */
  NumericFilter_aggregate: NumericFilter_Aggregate;
  /** fetch data from the table: "NumericFilter" using primary key columns */
  NumericFilter_by_pk: Maybe<NumericFilter>;
  /** fetch data from the table in a streaming manner: "NumericFilter" */
  NumericFilter_stream: Array<NumericFilter>;
  /** fetch data from the table: "Order" */
  Order: Array<Order>;
  /** fetch data from the table: "OrderLines" */
  OrderLines: Array<OrderLines>;
  /** fetch aggregated fields from the table: "OrderLines" */
  OrderLines_aggregate: OrderLines_Aggregate;
  /** fetch data from the table: "OrderLines" using primary key columns */
  OrderLines_by_pk: Maybe<OrderLines>;
  /** fetch data from the table in a streaming manner: "OrderLines" */
  OrderLines_stream: Array<OrderLines>;
  /** fetch aggregated fields from the table: "Order" */
  Order_aggregate: Order_Aggregate;
  /** fetch data from the table: "Order" using primary key columns */
  Order_by_pk: Maybe<Order>;
  /** fetch data from the table in a streaming manner: "Order" */
  Order_stream: Array<Order>;
  /** fetch data from the table: "Payment" */
  Payment: Array<Payment>;
  /** fetch data from the table: "PaymentAccounts" */
  PaymentAccounts: Array<PaymentAccounts>;
  /** fetch aggregated fields from the table: "PaymentAccounts" */
  PaymentAccounts_aggregate: PaymentAccounts_Aggregate;
  /** fetch data from the table: "PaymentAccounts" using primary key columns */
  PaymentAccounts_by_pk: Maybe<PaymentAccounts>;
  /** fetch data from the table in a streaming manner: "PaymentAccounts" */
  PaymentAccounts_stream: Array<PaymentAccounts>;
  /** fetch aggregated fields from the table: "Payment" */
  Payment_aggregate: Payment_Aggregate;
  /** fetch data from the table: "Payment" using primary key columns */
  Payment_by_pk: Maybe<Payment>;
  /** fetch data from the table in a streaming manner: "Payment" */
  Payment_stream: Array<Payment>;
  /** fetch data from the table: "Payout" */
  Payout: Array<Payout>;
  /** fetch aggregated fields from the table: "Payout" */
  Payout_aggregate: Payout_Aggregate;
  /** fetch data from the table: "Payout" using primary key columns */
  Payout_by_pk: Maybe<Payout>;
  /** fetch data from the table in a streaming manner: "Payout" */
  Payout_stream: Array<Payout>;
  /** fetch data from the table: "PriceOffer" */
  PriceOffer: Array<PriceOffer>;
  /** fetch aggregated fields from the table: "PriceOffer" */
  PriceOffer_aggregate: PriceOffer_Aggregate;
  /** fetch data from the table: "PriceOffer" using primary key columns */
  PriceOffer_by_pk: Maybe<PriceOffer>;
  /** fetch data from the table in a streaming manner: "PriceOffer" */
  PriceOffer_stream: Array<PriceOffer>;
  /** fetch data from the table: "Product" */
  Product: Array<Product>;
  /** fetch data from the table: "ProductVariant" */
  ProductVariant: Array<ProductVariant>;
  /** fetch aggregated fields from the table: "ProductVariant" */
  ProductVariant_aggregate: ProductVariant_Aggregate;
  /** fetch data from the table: "ProductVariant" using primary key columns */
  ProductVariant_by_pk: Maybe<ProductVariant>;
  /** fetch data from the table in a streaming manner: "ProductVariant" */
  ProductVariant_stream: Array<ProductVariant>;
  /** fetch aggregated fields from the table: "Product" */
  Product_aggregate: Product_Aggregate;
  /** fetch data from the table: "Product" using primary key columns */
  Product_by_pk: Maybe<Product>;
  /** fetch data from the table in a streaming manner: "Product" */
  Product_stream: Array<Product>;
  /** fetch data from the table: "Return" */
  Return: Array<Return>;
  /** fetch data from the table: "ReturnItem" */
  ReturnItem: Array<ReturnItem>;
  /** fetch aggregated fields from the table: "ReturnItem" */
  ReturnItem_aggregate: ReturnItem_Aggregate;
  /** fetch data from the table: "ReturnItem" using primary key columns */
  ReturnItem_by_pk: Maybe<ReturnItem>;
  /** fetch data from the table in a streaming manner: "ReturnItem" */
  ReturnItem_stream: Array<ReturnItem>;
  /** fetch aggregated fields from the table: "Return" */
  Return_aggregate: Return_Aggregate;
  /** fetch data from the table: "Return" using primary key columns */
  Return_by_pk: Maybe<Return>;
  /** fetch data from the table in a streaming manner: "Return" */
  Return_stream: Array<Return>;
  /** fetch data from the table: "Review" */
  Review: Array<Review>;
  /** fetch aggregated fields from the table: "Review" */
  Review_aggregate: Review_Aggregate;
  /** fetch data from the table: "Review" using primary key columns */
  Review_by_pk: Maybe<Review>;
  /** fetch data from the table in a streaming manner: "Review" */
  Review_stream: Array<Review>;
  /** fetch data from the table: "SavedSearch" */
  SavedSearch: Array<SavedSearch>;
  /** fetch aggregated fields from the table: "SavedSearch" */
  SavedSearch_aggregate: SavedSearch_Aggregate;
  /** fetch data from the table: "SavedSearch" using primary key columns */
  SavedSearch_by_pk: Maybe<SavedSearch>;
  /** fetch data from the table in a streaming manner: "SavedSearch" */
  SavedSearch_stream: Array<SavedSearch>;
  /** fetch data from the table: "SearchAlert" */
  SearchAlert: Array<SearchAlert>;
  /** fetch aggregated fields from the table: "SearchAlert" */
  SearchAlert_aggregate: SearchAlert_Aggregate;
  /** fetch data from the table: "SearchAlert" using primary key columns */
  SearchAlert_by_pk: Maybe<SearchAlert>;
  /** fetch data from the table in a streaming manner: "SearchAlert" */
  SearchAlert_stream: Array<SearchAlert>;
  /** fetch data from the table: "VendorProCategoryMapping" */
  VendorProCategoryMapping: Array<VendorProCategoryMapping>;
  /** fetch aggregated fields from the table: "VendorProCategoryMapping" */
  VendorProCategoryMapping_aggregate: VendorProCategoryMapping_Aggregate;
  /** fetch data from the table: "VendorProCategoryMapping" using primary key columns */
  VendorProCategoryMapping_by_pk: Maybe<VendorProCategoryMapping>;
  /** fetch data from the table in a streaming manner: "VendorProCategoryMapping" */
  VendorProCategoryMapping_stream: Array<VendorProCategoryMapping>;
  /** fetch data from the table: "VendorProTagMapping" */
  VendorProTagMapping: Array<VendorProTagMapping>;
  /** fetch aggregated fields from the table: "VendorProTagMapping" */
  VendorProTagMapping_aggregate: VendorProTagMapping_Aggregate;
  /** fetch data from the table: "VendorProTagMapping" using primary key columns */
  VendorProTagMapping_by_pk: Maybe<VendorProTagMapping>;
  /** fetch data from the table in a streaming manner: "VendorProTagMapping" */
  VendorProTagMapping_stream: Array<VendorProTagMapping>;
  /** fetch data from the table: "VendorProTagValueMapping" */
  VendorProTagValueMapping: Array<VendorProTagValueMapping>;
  /** fetch aggregated fields from the table: "VendorProTagValueMapping" */
  VendorProTagValueMapping_aggregate: VendorProTagValueMapping_Aggregate;
  /** fetch data from the table: "VendorProTagValueMapping" using primary key columns */
  VendorProTagValueMapping_by_pk: Maybe<VendorProTagValueMapping>;
  /** fetch data from the table in a streaming manner: "VendorProTagValueMapping" */
  VendorProTagValueMapping_stream: Array<VendorProTagValueMapping>;
  /** An array relationship */
  VendorReview: Array<VendorReview>;
  /** An aggregate relationship */
  VendorReview_aggregate: VendorReview_Aggregate;
  /** fetch data from the table: "VendorReview" using primary key columns */
  VendorReview_by_pk: Maybe<VendorReview>;
  /** fetch data from the table in a streaming manner: "VendorReview" */
  VendorReview_stream: Array<VendorReview>;
  /** fetch data from the table: "auth.providers" using primary key columns */
  authProvider: Maybe<AuthProviders>;
  /** fetch data from the table: "auth.provider_requests" using primary key columns */
  authProviderRequest: Maybe<AuthProviderRequests>;
  /** fetch data from the table: "auth.provider_requests" */
  authProviderRequests: Array<AuthProviderRequests>;
  /** fetch aggregated fields from the table: "auth.provider_requests" */
  authProviderRequestsAggregate: AuthProviderRequests_Aggregate;
  /** fetch data from the table in a streaming manner: "auth.provider_requests" */
  authProviderRequests_stream: Array<AuthProviderRequests>;
  /** fetch data from the table: "auth.providers" */
  authProviders: Array<AuthProviders>;
  /** fetch aggregated fields from the table: "auth.providers" */
  authProvidersAggregate: AuthProviders_Aggregate;
  /** fetch data from the table in a streaming manner: "auth.providers" */
  authProviders_stream: Array<AuthProviders>;
  /** fetch data from the table: "auth.refresh_tokens" using primary key columns */
  authRefreshToken: Maybe<AuthRefreshTokens>;
  /** fetch data from the table: "auth.refresh_tokens" */
  authRefreshTokens: Array<AuthRefreshTokens>;
  /** fetch aggregated fields from the table: "auth.refresh_tokens" */
  authRefreshTokensAggregate: AuthRefreshTokens_Aggregate;
  /** fetch data from the table in a streaming manner: "auth.refresh_tokens" */
  authRefreshTokens_stream: Array<AuthRefreshTokens>;
  /** fetch data from the table: "auth.user_roles" using primary key columns */
  authUserRole: Maybe<AuthUserRoles>;
  /** fetch data from the table: "auth.user_roles" */
  authUserRoles: Array<AuthUserRoles>;
  /** fetch aggregated fields from the table: "auth.user_roles" */
  authUserRolesAggregate: AuthUserRoles_Aggregate;
  /** fetch data from the table in a streaming manner: "auth.user_roles" */
  authUserRoles_stream: Array<AuthUserRoles>;
  /** fetch data from the table: "auth.user_security_keys" using primary key columns */
  authUserSecurityKey: Maybe<AuthUserSecurityKeys>;
  /** fetch data from the table: "auth.user_security_keys" */
  authUserSecurityKeys: Array<AuthUserSecurityKeys>;
  /** fetch aggregated fields from the table: "auth.user_security_keys" */
  authUserSecurityKeysAggregate: AuthUserSecurityKeys_Aggregate;
  /** fetch data from the table in a streaming manner: "auth.user_security_keys" */
  authUserSecurityKeys_stream: Array<AuthUserSecurityKeys>;
  /** fetch data from the table: "auth.roles" */
  auth_roles: Array<Auth_Roles>;
  /** fetch aggregated fields from the table: "auth.roles" */
  auth_roles_aggregate: Auth_Roles_Aggregate;
  /** fetch data from the table: "auth.roles" using primary key columns */
  auth_roles_by_pk: Maybe<Auth_Roles>;
  /** fetch data from the table in a streaming manner: "auth.roles" */
  auth_roles_stream: Array<Auth_Roles>;
  /** fetch data from the table: "auth.user_providers" */
  auth_user_providers: Array<Auth_User_Providers>;
  /** fetch aggregated fields from the table: "auth.user_providers" */
  auth_user_providers_aggregate: Auth_User_Providers_Aggregate;
  /** fetch data from the table: "auth.user_providers" using primary key columns */
  auth_user_providers_by_pk: Maybe<Auth_User_Providers>;
  /** fetch data from the table in a streaming manner: "auth.user_providers" */
  auth_user_providers_stream: Array<Auth_User_Providers>;
  /** fetch data from the table: "dbt.store_base_product" */
  dbt_store_base_product: Array<Dbt_Store_Base_Product>;
  /** fetch aggregated fields from the table: "dbt.store_base_product" */
  dbt_store_base_product_aggregate: Dbt_Store_Base_Product_Aggregate;
  /** fetch data from the table: "dbt.store_base_product" using primary key columns */
  dbt_store_base_product_by_pk: Maybe<Dbt_Store_Base_Product>;
  /** fetch data from the table in a streaming manner: "dbt.store_base_product" */
  dbt_store_base_product_stream: Array<Dbt_Store_Base_Product>;
  /** fetch data from the table: "dbt.store_base_product_variant" */
  dbt_store_base_product_variant: Array<Dbt_Store_Base_Product_Variant>;
  /** fetch aggregated fields from the table: "dbt.store_base_product_variant" */
  dbt_store_base_product_variant_aggregate: Dbt_Store_Base_Product_Variant_Aggregate;
  /** fetch data from the table: "dbt.store_base_product_variant" using primary key columns */
  dbt_store_base_product_variant_by_pk: Maybe<Dbt_Store_Base_Product_Variant>;
  /** fetch data from the table in a streaming manner: "dbt.store_base_product_variant" */
  dbt_store_base_product_variant_stream: Array<Dbt_Store_Base_Product_Variant>;
  /** fetch data from the table: "dbt.store_discount" */
  dbt_store_discount: Array<Dbt_Store_Discount>;
  /** fetch aggregated fields from the table: "dbt.store_discount" */
  dbt_store_discount_aggregate: Dbt_Store_Discount_Aggregate;
  /** fetch data from the table: "dbt.store_discount_collection" */
  dbt_store_discount_collection: Array<Dbt_Store_Discount_Collection>;
  /** fetch aggregated fields from the table: "dbt.store_discount_collection" */
  dbt_store_discount_collection_aggregate: Dbt_Store_Discount_Collection_Aggregate;
  /** fetch data from the table: "dbt.store_discount_collection" using primary key columns */
  dbt_store_discount_collection_by_pk: Maybe<Dbt_Store_Discount_Collection>;
  /** fetch data from the table in a streaming manner: "dbt.store_discount_collection" */
  dbt_store_discount_collection_stream: Array<Dbt_Store_Discount_Collection>;
  /** fetch data from the table in a streaming manner: "dbt.store_discount" */
  dbt_store_discount_stream: Array<Dbt_Store_Discount>;
  /** fetch data from the table: "dbt.store_exposed_product" */
  dbt_store_exposed_product: Array<Dbt_Store_Exposed_Product>;
  /** fetch aggregated fields from the table: "dbt.store_exposed_product" */
  dbt_store_exposed_product_aggregate: Dbt_Store_Exposed_Product_Aggregate;
  /** fetch data from the table: "dbt.store_exposed_product" using primary key columns */
  dbt_store_exposed_product_by_pk: Maybe<Dbt_Store_Exposed_Product>;
  /** fetch data from the table: "dbt.store_exposed_product_image" */
  dbt_store_exposed_product_image: Array<Dbt_Store_Exposed_Product_Image>;
  /** fetch aggregated fields from the table: "dbt.store_exposed_product_image" */
  dbt_store_exposed_product_image_aggregate: Dbt_Store_Exposed_Product_Image_Aggregate;
  /** fetch data from the table: "dbt.store_exposed_product_image" using primary key columns */
  dbt_store_exposed_product_image_by_pk: Maybe<Dbt_Store_Exposed_Product_Image>;
  /** fetch data from the table in a streaming manner: "dbt.store_exposed_product_image" */
  dbt_store_exposed_product_image_stream: Array<Dbt_Store_Exposed_Product_Image>;
  /** fetch data from the table in a streaming manner: "dbt.store_exposed_product" */
  dbt_store_exposed_product_stream: Array<Dbt_Store_Exposed_Product>;
  /** fetch data from the table: "dbt.store_exposed_product_tag" */
  dbt_store_exposed_product_tag: Array<Dbt_Store_Exposed_Product_Tag>;
  /** fetch aggregated fields from the table: "dbt.store_exposed_product_tag" */
  dbt_store_exposed_product_tag_aggregate: Dbt_Store_Exposed_Product_Tag_Aggregate;
  /** fetch data from the table in a streaming manner: "dbt.store_exposed_product_tag" */
  dbt_store_exposed_product_tag_stream: Array<Dbt_Store_Exposed_Product_Tag>;
  /** fetch data from the table: "dbt.store_exposed_product_variant" */
  dbt_store_exposed_product_variant: Array<Dbt_Store_Exposed_Product_Variant>;
  /** fetch aggregated fields from the table: "dbt.store_exposed_product_variant" */
  dbt_store_exposed_product_variant_aggregate: Dbt_Store_Exposed_Product_Variant_Aggregate;
  /** fetch data from the table: "dbt.store_exposed_product_variant" using primary key columns */
  dbt_store_exposed_product_variant_by_pk: Maybe<Dbt_Store_Exposed_Product_Variant>;
  /** fetch data from the table in a streaming manner: "dbt.store_exposed_product_variant" */
  dbt_store_exposed_product_variant_stream: Array<Dbt_Store_Exposed_Product_Variant>;
  /** fetch data from the table: "dbt.store_product_collection" */
  dbt_store_product_collection: Array<Dbt_Store_Product_Collection>;
  /** fetch aggregated fields from the table: "dbt.store_product_collection" */
  dbt_store_product_collection_aggregate: Dbt_Store_Product_Collection_Aggregate;
  /** fetch data from the table: "dbt.store_product_collection" using primary key columns */
  dbt_store_product_collection_by_pk: Maybe<Dbt_Store_Product_Collection>;
  /** fetch data from the table in a streaming manner: "dbt.store_product_collection" */
  dbt_store_product_collection_stream: Array<Dbt_Store_Product_Collection>;
  /** fetch data from the table: "dbt.store_product_for_analytics" */
  dbt_store_product_for_analytics: Array<Dbt_Store_Product_For_Analytics>;
  /** fetch aggregated fields from the table: "dbt.store_product_for_analytics" */
  dbt_store_product_for_analytics_aggregate: Dbt_Store_Product_For_Analytics_Aggregate;
  /** fetch data from the table: "dbt.store_product_for_analytics" using primary key columns */
  dbt_store_product_for_analytics_by_pk: Maybe<Dbt_Store_Product_For_Analytics>;
  /** fetch data from the table in a streaming manner: "dbt.store_product_for_analytics" */
  dbt_store_product_for_analytics_stream: Array<Dbt_Store_Product_For_Analytics>;
  /** fetch data from the table: "auth.users" using primary key columns */
  user: Maybe<Users>;
  /** fetch data from the table: "auth.users" */
  users: Array<Users>;
  /** fetch aggregated fields from the table: "auth.users" */
  usersAggregate: Users_Aggregate;
  /** fetch data from the table in a streaming manner: "auth.users" */
  users_stream: Array<Users>;
};

export type Subscription_RootCheckoutArgs = {
  distinct_on: InputMaybe<Array<Checkout_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Checkout_Order_By>>;
  where: InputMaybe<Checkout_Bool_Exp>;
};

export type Subscription_RootCheckout_AggregateArgs = {
  distinct_on: InputMaybe<Array<Checkout_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Checkout_Order_By>>;
  where: InputMaybe<Checkout_Bool_Exp>;
};

export type Subscription_RootCheckout_By_PkArgs = {
  id: Scalars['String'];
};

export type Subscription_RootCheckout_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Checkout_Stream_Cursor_Input>>;
  where: InputMaybe<Checkout_Bool_Exp>;
};

export type Subscription_RootCollectionArgs = {
  distinct_on: InputMaybe<Array<Collection_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Collection_Order_By>>;
  where: InputMaybe<Collection_Bool_Exp>;
};

export type Subscription_RootCollection_AggregateArgs = {
  distinct_on: InputMaybe<Array<Collection_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Collection_Order_By>>;
  where: InputMaybe<Collection_Bool_Exp>;
};

export type Subscription_RootCollection_By_PkArgs = {
  id: Scalars['String'];
};

export type Subscription_RootCollection_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Collection_Stream_Cursor_Input>>;
  where: InputMaybe<Collection_Bool_Exp>;
};

export type Subscription_RootCustomerArgs = {
  distinct_on: InputMaybe<Array<Customer_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Customer_Order_By>>;
  where: InputMaybe<Customer_Bool_Exp>;
};

export type Subscription_RootCustomer_AggregateArgs = {
  distinct_on: InputMaybe<Array<Customer_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Customer_Order_By>>;
  where: InputMaybe<Customer_Bool_Exp>;
};

export type Subscription_RootCustomer_By_PkArgs = {
  authUserId: Scalars['uuid'];
};

export type Subscription_RootCustomer_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Customer_Stream_Cursor_Input>>;
  where: InputMaybe<Customer_Bool_Exp>;
};

export type Subscription_RootDisputeArgs = {
  distinct_on: InputMaybe<Array<Dispute_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dispute_Order_By>>;
  where: InputMaybe<Dispute_Bool_Exp>;
};

export type Subscription_RootDisputeAttachmentArgs = {
  distinct_on: InputMaybe<Array<DisputeAttachment_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<DisputeAttachment_Order_By>>;
  where: InputMaybe<DisputeAttachment_Bool_Exp>;
};

export type Subscription_RootDisputeAttachment_AggregateArgs = {
  distinct_on: InputMaybe<Array<DisputeAttachment_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<DisputeAttachment_Order_By>>;
  where: InputMaybe<DisputeAttachment_Bool_Exp>;
};

export type Subscription_RootDisputeAttachment_By_PkArgs = {
  id: Scalars['String'];
};

export type Subscription_RootDisputeAttachment_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<DisputeAttachment_Stream_Cursor_Input>>;
  where: InputMaybe<DisputeAttachment_Bool_Exp>;
};

export type Subscription_RootDispute_AggregateArgs = {
  distinct_on: InputMaybe<Array<Dispute_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dispute_Order_By>>;
  where: InputMaybe<Dispute_Bool_Exp>;
};

export type Subscription_RootDispute_By_PkArgs = {
  id: Scalars['String'];
};

export type Subscription_RootDispute_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Dispute_Stream_Cursor_Input>>;
  where: InputMaybe<Dispute_Bool_Exp>;
};

export type Subscription_RootEventArgs = {
  distinct_on: InputMaybe<Array<Event_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Event_Order_By>>;
  where: InputMaybe<Event_Bool_Exp>;
};

export type Subscription_RootEvent_AggregateArgs = {
  distinct_on: InputMaybe<Array<Event_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Event_Order_By>>;
  where: InputMaybe<Event_Bool_Exp>;
};

export type Subscription_RootEvent_By_PkArgs = {
  id: Scalars['String'];
};

export type Subscription_RootEvent_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Event_Stream_Cursor_Input>>;
  where: InputMaybe<Event_Bool_Exp>;
};

export type Subscription_RootFacetFilterArgs = {
  distinct_on: InputMaybe<Array<FacetFilter_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<FacetFilter_Order_By>>;
  where: InputMaybe<FacetFilter_Bool_Exp>;
};

export type Subscription_RootFacetFilter_AggregateArgs = {
  distinct_on: InputMaybe<Array<FacetFilter_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<FacetFilter_Order_By>>;
  where: InputMaybe<FacetFilter_Bool_Exp>;
};

export type Subscription_RootFacetFilter_By_PkArgs = {
  id: Scalars['String'];
};

export type Subscription_RootFacetFilter_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<FacetFilter_Stream_Cursor_Input>>;
  where: InputMaybe<FacetFilter_Bool_Exp>;
};

export type Subscription_RootFavoriteProductsArgs = {
  distinct_on: InputMaybe<Array<FavoriteProducts_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<FavoriteProducts_Order_By>>;
  where: InputMaybe<FavoriteProducts_Bool_Exp>;
};

export type Subscription_RootFavoriteProducts_AggregateArgs = {
  distinct_on: InputMaybe<Array<FavoriteProducts_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<FavoriteProducts_Order_By>>;
  where: InputMaybe<FavoriteProducts_Bool_Exp>;
};

export type Subscription_RootFavoriteProducts_By_PkArgs = {
  id: Scalars['String'];
};

export type Subscription_RootFavoriteProducts_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<FavoriteProducts_Stream_Cursor_Input>>;
  where: InputMaybe<FavoriteProducts_Bool_Exp>;
};

export type Subscription_RootFulfillmentArgs = {
  distinct_on: InputMaybe<Array<Fulfillment_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Fulfillment_Order_By>>;
  where: InputMaybe<Fulfillment_Bool_Exp>;
};

export type Subscription_RootFulfillmentItemArgs = {
  distinct_on: InputMaybe<Array<FulfillmentItem_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<FulfillmentItem_Order_By>>;
  where: InputMaybe<FulfillmentItem_Bool_Exp>;
};

export type Subscription_RootFulfillmentItem_AggregateArgs = {
  distinct_on: InputMaybe<Array<FulfillmentItem_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<FulfillmentItem_Order_By>>;
  where: InputMaybe<FulfillmentItem_Bool_Exp>;
};

export type Subscription_RootFulfillmentItem_By_PkArgs = {
  id: Scalars['String'];
};

export type Subscription_RootFulfillmentItem_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<FulfillmentItem_Stream_Cursor_Input>>;
  where: InputMaybe<FulfillmentItem_Bool_Exp>;
};

export type Subscription_RootFulfillmentOrderArgs = {
  distinct_on: InputMaybe<Array<FulfillmentOrder_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<FulfillmentOrder_Order_By>>;
  where: InputMaybe<FulfillmentOrder_Bool_Exp>;
};

export type Subscription_RootFulfillmentOrder_AggregateArgs = {
  distinct_on: InputMaybe<Array<FulfillmentOrder_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<FulfillmentOrder_Order_By>>;
  where: InputMaybe<FulfillmentOrder_Bool_Exp>;
};

export type Subscription_RootFulfillmentOrder_By_PkArgs = {
  id: Scalars['String'];
};

export type Subscription_RootFulfillmentOrder_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<FulfillmentOrder_Stream_Cursor_Input>>;
  where: InputMaybe<FulfillmentOrder_Bool_Exp>;
};

export type Subscription_RootFulfillment_AggregateArgs = {
  distinct_on: InputMaybe<Array<Fulfillment_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Fulfillment_Order_By>>;
  where: InputMaybe<Fulfillment_Bool_Exp>;
};

export type Subscription_RootFulfillment_By_PkArgs = {
  id: Scalars['String'];
};

export type Subscription_RootFulfillment_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Fulfillment_Stream_Cursor_Input>>;
  where: InputMaybe<Fulfillment_Bool_Exp>;
};

export type Subscription_RootNegociationAgreementArgs = {
  distinct_on: InputMaybe<Array<NegociationAgreement_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<NegociationAgreement_Order_By>>;
  where: InputMaybe<NegociationAgreement_Bool_Exp>;
};

export type Subscription_RootNegociationAgreement_AggregateArgs = {
  distinct_on: InputMaybe<Array<NegociationAgreement_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<NegociationAgreement_Order_By>>;
  where: InputMaybe<NegociationAgreement_Bool_Exp>;
};

export type Subscription_RootNegociationAgreement_By_PkArgs = {
  id: Scalars['String'];
};

export type Subscription_RootNegociationAgreement_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<NegociationAgreement_Stream_Cursor_Input>>;
  where: InputMaybe<NegociationAgreement_Bool_Exp>;
};

export type Subscription_RootNumericFilterArgs = {
  distinct_on: InputMaybe<Array<NumericFilter_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<NumericFilter_Order_By>>;
  where: InputMaybe<NumericFilter_Bool_Exp>;
};

export type Subscription_RootNumericFilter_AggregateArgs = {
  distinct_on: InputMaybe<Array<NumericFilter_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<NumericFilter_Order_By>>;
  where: InputMaybe<NumericFilter_Bool_Exp>;
};

export type Subscription_RootNumericFilter_By_PkArgs = {
  id: Scalars['String'];
};

export type Subscription_RootNumericFilter_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<NumericFilter_Stream_Cursor_Input>>;
  where: InputMaybe<NumericFilter_Bool_Exp>;
};

export type Subscription_RootOrderArgs = {
  distinct_on: InputMaybe<Array<Order_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Order_Order_By>>;
  where: InputMaybe<Order_Bool_Exp>;
};

export type Subscription_RootOrderLinesArgs = {
  distinct_on: InputMaybe<Array<OrderLines_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<OrderLines_Order_By>>;
  where: InputMaybe<OrderLines_Bool_Exp>;
};

export type Subscription_RootOrderLines_AggregateArgs = {
  distinct_on: InputMaybe<Array<OrderLines_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<OrderLines_Order_By>>;
  where: InputMaybe<OrderLines_Bool_Exp>;
};

export type Subscription_RootOrderLines_By_PkArgs = {
  id: Scalars['String'];
};

export type Subscription_RootOrderLines_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<OrderLines_Stream_Cursor_Input>>;
  where: InputMaybe<OrderLines_Bool_Exp>;
};

export type Subscription_RootOrder_AggregateArgs = {
  distinct_on: InputMaybe<Array<Order_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Order_Order_By>>;
  where: InputMaybe<Order_Bool_Exp>;
};

export type Subscription_RootOrder_By_PkArgs = {
  id: Scalars['String'];
};

export type Subscription_RootOrder_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Order_Stream_Cursor_Input>>;
  where: InputMaybe<Order_Bool_Exp>;
};

export type Subscription_RootPaymentArgs = {
  distinct_on: InputMaybe<Array<Payment_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Payment_Order_By>>;
  where: InputMaybe<Payment_Bool_Exp>;
};

export type Subscription_RootPaymentAccountsArgs = {
  distinct_on: InputMaybe<Array<PaymentAccounts_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<PaymentAccounts_Order_By>>;
  where: InputMaybe<PaymentAccounts_Bool_Exp>;
};

export type Subscription_RootPaymentAccounts_AggregateArgs = {
  distinct_on: InputMaybe<Array<PaymentAccounts_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<PaymentAccounts_Order_By>>;
  where: InputMaybe<PaymentAccounts_Bool_Exp>;
};

export type Subscription_RootPaymentAccounts_By_PkArgs = {
  id: Scalars['String'];
};

export type Subscription_RootPaymentAccounts_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<PaymentAccounts_Stream_Cursor_Input>>;
  where: InputMaybe<PaymentAccounts_Bool_Exp>;
};

export type Subscription_RootPayment_AggregateArgs = {
  distinct_on: InputMaybe<Array<Payment_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Payment_Order_By>>;
  where: InputMaybe<Payment_Bool_Exp>;
};

export type Subscription_RootPayment_By_PkArgs = {
  id: Scalars['String'];
};

export type Subscription_RootPayment_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Payment_Stream_Cursor_Input>>;
  where: InputMaybe<Payment_Bool_Exp>;
};

export type Subscription_RootPayoutArgs = {
  distinct_on: InputMaybe<Array<Payout_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Payout_Order_By>>;
  where: InputMaybe<Payout_Bool_Exp>;
};

export type Subscription_RootPayout_AggregateArgs = {
  distinct_on: InputMaybe<Array<Payout_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Payout_Order_By>>;
  where: InputMaybe<Payout_Bool_Exp>;
};

export type Subscription_RootPayout_By_PkArgs = {
  id: Scalars['String'];
};

export type Subscription_RootPayout_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Payout_Stream_Cursor_Input>>;
  where: InputMaybe<Payout_Bool_Exp>;
};

export type Subscription_RootPriceOfferArgs = {
  distinct_on: InputMaybe<Array<PriceOffer_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<PriceOffer_Order_By>>;
  where: InputMaybe<PriceOffer_Bool_Exp>;
};

export type Subscription_RootPriceOffer_AggregateArgs = {
  distinct_on: InputMaybe<Array<PriceOffer_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<PriceOffer_Order_By>>;
  where: InputMaybe<PriceOffer_Bool_Exp>;
};

export type Subscription_RootPriceOffer_By_PkArgs = {
  id: Scalars['String'];
};

export type Subscription_RootPriceOffer_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<PriceOffer_Stream_Cursor_Input>>;
  where: InputMaybe<PriceOffer_Bool_Exp>;
};

export type Subscription_RootProductArgs = {
  distinct_on: InputMaybe<Array<Product_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Product_Order_By>>;
  where: InputMaybe<Product_Bool_Exp>;
};

export type Subscription_RootProductVariantArgs = {
  distinct_on: InputMaybe<Array<ProductVariant_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<ProductVariant_Order_By>>;
  where: InputMaybe<ProductVariant_Bool_Exp>;
};

export type Subscription_RootProductVariant_AggregateArgs = {
  distinct_on: InputMaybe<Array<ProductVariant_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<ProductVariant_Order_By>>;
  where: InputMaybe<ProductVariant_Bool_Exp>;
};

export type Subscription_RootProductVariant_By_PkArgs = {
  id: Scalars['String'];
};

export type Subscription_RootProductVariant_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<ProductVariant_Stream_Cursor_Input>>;
  where: InputMaybe<ProductVariant_Bool_Exp>;
};

export type Subscription_RootProduct_AggregateArgs = {
  distinct_on: InputMaybe<Array<Product_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Product_Order_By>>;
  where: InputMaybe<Product_Bool_Exp>;
};

export type Subscription_RootProduct_By_PkArgs = {
  id: Scalars['String'];
};

export type Subscription_RootProduct_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Product_Stream_Cursor_Input>>;
  where: InputMaybe<Product_Bool_Exp>;
};

export type Subscription_RootReturnArgs = {
  distinct_on: InputMaybe<Array<Return_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Return_Order_By>>;
  where: InputMaybe<Return_Bool_Exp>;
};

export type Subscription_RootReturnItemArgs = {
  distinct_on: InputMaybe<Array<ReturnItem_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<ReturnItem_Order_By>>;
  where: InputMaybe<ReturnItem_Bool_Exp>;
};

export type Subscription_RootReturnItem_AggregateArgs = {
  distinct_on: InputMaybe<Array<ReturnItem_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<ReturnItem_Order_By>>;
  where: InputMaybe<ReturnItem_Bool_Exp>;
};

export type Subscription_RootReturnItem_By_PkArgs = {
  id: Scalars['String'];
};

export type Subscription_RootReturnItem_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<ReturnItem_Stream_Cursor_Input>>;
  where: InputMaybe<ReturnItem_Bool_Exp>;
};

export type Subscription_RootReturn_AggregateArgs = {
  distinct_on: InputMaybe<Array<Return_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Return_Order_By>>;
  where: InputMaybe<Return_Bool_Exp>;
};

export type Subscription_RootReturn_By_PkArgs = {
  id: Scalars['String'];
};

export type Subscription_RootReturn_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Return_Stream_Cursor_Input>>;
  where: InputMaybe<Return_Bool_Exp>;
};

export type Subscription_RootReviewArgs = {
  distinct_on: InputMaybe<Array<Review_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Review_Order_By>>;
  where: InputMaybe<Review_Bool_Exp>;
};

export type Subscription_RootReview_AggregateArgs = {
  distinct_on: InputMaybe<Array<Review_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Review_Order_By>>;
  where: InputMaybe<Review_Bool_Exp>;
};

export type Subscription_RootReview_By_PkArgs = {
  id: Scalars['String'];
};

export type Subscription_RootReview_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Review_Stream_Cursor_Input>>;
  where: InputMaybe<Review_Bool_Exp>;
};

export type Subscription_RootSavedSearchArgs = {
  distinct_on: InputMaybe<Array<SavedSearch_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<SavedSearch_Order_By>>;
  where: InputMaybe<SavedSearch_Bool_Exp>;
};

export type Subscription_RootSavedSearch_AggregateArgs = {
  distinct_on: InputMaybe<Array<SavedSearch_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<SavedSearch_Order_By>>;
  where: InputMaybe<SavedSearch_Bool_Exp>;
};

export type Subscription_RootSavedSearch_By_PkArgs = {
  id: Scalars['String'];
};

export type Subscription_RootSavedSearch_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<SavedSearch_Stream_Cursor_Input>>;
  where: InputMaybe<SavedSearch_Bool_Exp>;
};

export type Subscription_RootSearchAlertArgs = {
  distinct_on: InputMaybe<Array<SearchAlert_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<SearchAlert_Order_By>>;
  where: InputMaybe<SearchAlert_Bool_Exp>;
};

export type Subscription_RootSearchAlert_AggregateArgs = {
  distinct_on: InputMaybe<Array<SearchAlert_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<SearchAlert_Order_By>>;
  where: InputMaybe<SearchAlert_Bool_Exp>;
};

export type Subscription_RootSearchAlert_By_PkArgs = {
  id: Scalars['String'];
};

export type Subscription_RootSearchAlert_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<SearchAlert_Stream_Cursor_Input>>;
  where: InputMaybe<SearchAlert_Bool_Exp>;
};

export type Subscription_RootVendorProCategoryMappingArgs = {
  distinct_on: InputMaybe<Array<VendorProCategoryMapping_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<VendorProCategoryMapping_Order_By>>;
  where: InputMaybe<VendorProCategoryMapping_Bool_Exp>;
};

export type Subscription_RootVendorProCategoryMapping_AggregateArgs = {
  distinct_on: InputMaybe<Array<VendorProCategoryMapping_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<VendorProCategoryMapping_Order_By>>;
  where: InputMaybe<VendorProCategoryMapping_Bool_Exp>;
};

export type Subscription_RootVendorProCategoryMapping_By_PkArgs = {
  id: Scalars['String'];
};

export type Subscription_RootVendorProCategoryMapping_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<VendorProCategoryMapping_Stream_Cursor_Input>>;
  where: InputMaybe<VendorProCategoryMapping_Bool_Exp>;
};

export type Subscription_RootVendorProTagMappingArgs = {
  distinct_on: InputMaybe<Array<VendorProTagMapping_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<VendorProTagMapping_Order_By>>;
  where: InputMaybe<VendorProTagMapping_Bool_Exp>;
};

export type Subscription_RootVendorProTagMapping_AggregateArgs = {
  distinct_on: InputMaybe<Array<VendorProTagMapping_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<VendorProTagMapping_Order_By>>;
  where: InputMaybe<VendorProTagMapping_Bool_Exp>;
};

export type Subscription_RootVendorProTagMapping_By_PkArgs = {
  id: Scalars['String'];
};

export type Subscription_RootVendorProTagMapping_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<VendorProTagMapping_Stream_Cursor_Input>>;
  where: InputMaybe<VendorProTagMapping_Bool_Exp>;
};

export type Subscription_RootVendorProTagValueMappingArgs = {
  distinct_on: InputMaybe<Array<VendorProTagValueMapping_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<VendorProTagValueMapping_Order_By>>;
  where: InputMaybe<VendorProTagValueMapping_Bool_Exp>;
};

export type Subscription_RootVendorProTagValueMapping_AggregateArgs = {
  distinct_on: InputMaybe<Array<VendorProTagValueMapping_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<VendorProTagValueMapping_Order_By>>;
  where: InputMaybe<VendorProTagValueMapping_Bool_Exp>;
};

export type Subscription_RootVendorProTagValueMapping_By_PkArgs = {
  id: Scalars['String'];
};

export type Subscription_RootVendorProTagValueMapping_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<VendorProTagValueMapping_Stream_Cursor_Input>>;
  where: InputMaybe<VendorProTagValueMapping_Bool_Exp>;
};

export type Subscription_RootVendorReviewArgs = {
  distinct_on: InputMaybe<Array<VendorReview_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<VendorReview_Order_By>>;
  where: InputMaybe<VendorReview_Bool_Exp>;
};

export type Subscription_RootVendorReview_AggregateArgs = {
  distinct_on: InputMaybe<Array<VendorReview_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<VendorReview_Order_By>>;
  where: InputMaybe<VendorReview_Bool_Exp>;
};

export type Subscription_RootVendorReview_By_PkArgs = {
  reviewId: Scalars['String'];
};

export type Subscription_RootVendorReview_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<VendorReview_Stream_Cursor_Input>>;
  where: InputMaybe<VendorReview_Bool_Exp>;
};

export type Subscription_RootAuthProviderArgs = {
  id: Scalars['String'];
};

export type Subscription_RootAuthProviderRequestArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootAuthProviderRequestsArgs = {
  distinct_on: InputMaybe<Array<AuthProviderRequests_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<AuthProviderRequests_Order_By>>;
  where: InputMaybe<AuthProviderRequests_Bool_Exp>;
};

export type Subscription_RootAuthProviderRequestsAggregateArgs = {
  distinct_on: InputMaybe<Array<AuthProviderRequests_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<AuthProviderRequests_Order_By>>;
  where: InputMaybe<AuthProviderRequests_Bool_Exp>;
};

export type Subscription_RootAuthProviderRequests_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<AuthProviderRequests_Stream_Cursor_Input>>;
  where: InputMaybe<AuthProviderRequests_Bool_Exp>;
};

export type Subscription_RootAuthProvidersArgs = {
  distinct_on: InputMaybe<Array<AuthProviders_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<AuthProviders_Order_By>>;
  where: InputMaybe<AuthProviders_Bool_Exp>;
};

export type Subscription_RootAuthProvidersAggregateArgs = {
  distinct_on: InputMaybe<Array<AuthProviders_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<AuthProviders_Order_By>>;
  where: InputMaybe<AuthProviders_Bool_Exp>;
};

export type Subscription_RootAuthProviders_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<AuthProviders_Stream_Cursor_Input>>;
  where: InputMaybe<AuthProviders_Bool_Exp>;
};

export type Subscription_RootAuthRefreshTokenArgs = {
  refreshToken: Scalars['uuid'];
};

export type Subscription_RootAuthRefreshTokensArgs = {
  distinct_on: InputMaybe<Array<AuthRefreshTokens_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<AuthRefreshTokens_Order_By>>;
  where: InputMaybe<AuthRefreshTokens_Bool_Exp>;
};

export type Subscription_RootAuthRefreshTokensAggregateArgs = {
  distinct_on: InputMaybe<Array<AuthRefreshTokens_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<AuthRefreshTokens_Order_By>>;
  where: InputMaybe<AuthRefreshTokens_Bool_Exp>;
};

export type Subscription_RootAuthRefreshTokens_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<AuthRefreshTokens_Stream_Cursor_Input>>;
  where: InputMaybe<AuthRefreshTokens_Bool_Exp>;
};

export type Subscription_RootAuthUserRoleArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootAuthUserRolesArgs = {
  distinct_on: InputMaybe<Array<AuthUserRoles_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<AuthUserRoles_Order_By>>;
  where: InputMaybe<AuthUserRoles_Bool_Exp>;
};

export type Subscription_RootAuthUserRolesAggregateArgs = {
  distinct_on: InputMaybe<Array<AuthUserRoles_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<AuthUserRoles_Order_By>>;
  where: InputMaybe<AuthUserRoles_Bool_Exp>;
};

export type Subscription_RootAuthUserRoles_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<AuthUserRoles_Stream_Cursor_Input>>;
  where: InputMaybe<AuthUserRoles_Bool_Exp>;
};

export type Subscription_RootAuthUserSecurityKeyArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootAuthUserSecurityKeysArgs = {
  distinct_on: InputMaybe<Array<AuthUserSecurityKeys_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<AuthUserSecurityKeys_Order_By>>;
  where: InputMaybe<AuthUserSecurityKeys_Bool_Exp>;
};

export type Subscription_RootAuthUserSecurityKeysAggregateArgs = {
  distinct_on: InputMaybe<Array<AuthUserSecurityKeys_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<AuthUserSecurityKeys_Order_By>>;
  where: InputMaybe<AuthUserSecurityKeys_Bool_Exp>;
};

export type Subscription_RootAuthUserSecurityKeys_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<AuthUserSecurityKeys_Stream_Cursor_Input>>;
  where: InputMaybe<AuthUserSecurityKeys_Bool_Exp>;
};

export type Subscription_RootAuth_RolesArgs = {
  distinct_on: InputMaybe<Array<Auth_Roles_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Auth_Roles_Order_By>>;
  where: InputMaybe<Auth_Roles_Bool_Exp>;
};

export type Subscription_RootAuth_Roles_AggregateArgs = {
  distinct_on: InputMaybe<Array<Auth_Roles_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Auth_Roles_Order_By>>;
  where: InputMaybe<Auth_Roles_Bool_Exp>;
};

export type Subscription_RootAuth_Roles_By_PkArgs = {
  role: Scalars['String'];
};

export type Subscription_RootAuth_Roles_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Auth_Roles_Stream_Cursor_Input>>;
  where: InputMaybe<Auth_Roles_Bool_Exp>;
};

export type Subscription_RootAuth_User_ProvidersArgs = {
  distinct_on: InputMaybe<Array<Auth_User_Providers_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Auth_User_Providers_Order_By>>;
  where: InputMaybe<Auth_User_Providers_Bool_Exp>;
};

export type Subscription_RootAuth_User_Providers_AggregateArgs = {
  distinct_on: InputMaybe<Array<Auth_User_Providers_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Auth_User_Providers_Order_By>>;
  where: InputMaybe<Auth_User_Providers_Bool_Exp>;
};

export type Subscription_RootAuth_User_Providers_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootAuth_User_Providers_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Auth_User_Providers_Stream_Cursor_Input>>;
  where: InputMaybe<Auth_User_Providers_Bool_Exp>;
};

export type Subscription_RootDbt_Store_Base_ProductArgs = {
  distinct_on: InputMaybe<Array<Dbt_Store_Base_Product_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Base_Product_Order_By>>;
  where: InputMaybe<Dbt_Store_Base_Product_Bool_Exp>;
};

export type Subscription_RootDbt_Store_Base_Product_AggregateArgs = {
  distinct_on: InputMaybe<Array<Dbt_Store_Base_Product_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Base_Product_Order_By>>;
  where: InputMaybe<Dbt_Store_Base_Product_Bool_Exp>;
};

export type Subscription_RootDbt_Store_Base_Product_By_PkArgs = {
  id: Scalars['String'];
};

export type Subscription_RootDbt_Store_Base_Product_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Dbt_Store_Base_Product_Stream_Cursor_Input>>;
  where: InputMaybe<Dbt_Store_Base_Product_Bool_Exp>;
};

export type Subscription_RootDbt_Store_Base_Product_VariantArgs = {
  distinct_on: InputMaybe<Array<Dbt_Store_Base_Product_Variant_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Base_Product_Variant_Order_By>>;
  where: InputMaybe<Dbt_Store_Base_Product_Variant_Bool_Exp>;
};

export type Subscription_RootDbt_Store_Base_Product_Variant_AggregateArgs = {
  distinct_on: InputMaybe<Array<Dbt_Store_Base_Product_Variant_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Base_Product_Variant_Order_By>>;
  where: InputMaybe<Dbt_Store_Base_Product_Variant_Bool_Exp>;
};

export type Subscription_RootDbt_Store_Base_Product_Variant_By_PkArgs = {
  shopify_id: Scalars['bigint'];
};

export type Subscription_RootDbt_Store_Base_Product_Variant_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Dbt_Store_Base_Product_Variant_Stream_Cursor_Input>>;
  where: InputMaybe<Dbt_Store_Base_Product_Variant_Bool_Exp>;
};

export type Subscription_RootDbt_Store_DiscountArgs = {
  distinct_on: InputMaybe<Array<Dbt_Store_Discount_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Discount_Order_By>>;
  where: InputMaybe<Dbt_Store_Discount_Bool_Exp>;
};

export type Subscription_RootDbt_Store_Discount_AggregateArgs = {
  distinct_on: InputMaybe<Array<Dbt_Store_Discount_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Discount_Order_By>>;
  where: InputMaybe<Dbt_Store_Discount_Bool_Exp>;
};

export type Subscription_RootDbt_Store_Discount_CollectionArgs = {
  distinct_on: InputMaybe<Array<Dbt_Store_Discount_Collection_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Discount_Collection_Order_By>>;
  where: InputMaybe<Dbt_Store_Discount_Collection_Bool_Exp>;
};

export type Subscription_RootDbt_Store_Discount_Collection_AggregateArgs = {
  distinct_on: InputMaybe<Array<Dbt_Store_Discount_Collection_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Discount_Collection_Order_By>>;
  where: InputMaybe<Dbt_Store_Discount_Collection_Bool_Exp>;
};

export type Subscription_RootDbt_Store_Discount_Collection_By_PkArgs = {
  collection_internal_id: Scalars['String'];
  discount_id: Scalars['bigint'];
};

export type Subscription_RootDbt_Store_Discount_Collection_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Dbt_Store_Discount_Collection_Stream_Cursor_Input>>;
  where: InputMaybe<Dbt_Store_Discount_Collection_Bool_Exp>;
};

export type Subscription_RootDbt_Store_Discount_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Dbt_Store_Discount_Stream_Cursor_Input>>;
  where: InputMaybe<Dbt_Store_Discount_Bool_Exp>;
};

export type Subscription_RootDbt_Store_Exposed_ProductArgs = {
  distinct_on: InputMaybe<Array<Dbt_Store_Exposed_Product_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Exposed_Product_Order_By>>;
  where: InputMaybe<Dbt_Store_Exposed_Product_Bool_Exp>;
};

export type Subscription_RootDbt_Store_Exposed_Product_AggregateArgs = {
  distinct_on: InputMaybe<Array<Dbt_Store_Exposed_Product_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Exposed_Product_Order_By>>;
  where: InputMaybe<Dbt_Store_Exposed_Product_Bool_Exp>;
};

export type Subscription_RootDbt_Store_Exposed_Product_By_PkArgs = {
  id: Scalars['String'];
};

export type Subscription_RootDbt_Store_Exposed_Product_ImageArgs = {
  distinct_on: InputMaybe<Array<Dbt_Store_Exposed_Product_Image_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Exposed_Product_Image_Order_By>>;
  where: InputMaybe<Dbt_Store_Exposed_Product_Image_Bool_Exp>;
};

export type Subscription_RootDbt_Store_Exposed_Product_Image_AggregateArgs = {
  distinct_on: InputMaybe<Array<Dbt_Store_Exposed_Product_Image_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Exposed_Product_Image_Order_By>>;
  where: InputMaybe<Dbt_Store_Exposed_Product_Image_Bool_Exp>;
};

export type Subscription_RootDbt_Store_Exposed_Product_Image_By_PkArgs = {
  shopify_id: Scalars['bigint'];
};

export type Subscription_RootDbt_Store_Exposed_Product_Image_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<
    InputMaybe<Dbt_Store_Exposed_Product_Image_Stream_Cursor_Input>
  >;
  where: InputMaybe<Dbt_Store_Exposed_Product_Image_Bool_Exp>;
};

export type Subscription_RootDbt_Store_Exposed_Product_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Dbt_Store_Exposed_Product_Stream_Cursor_Input>>;
  where: InputMaybe<Dbt_Store_Exposed_Product_Bool_Exp>;
};

export type Subscription_RootDbt_Store_Exposed_Product_TagArgs = {
  distinct_on: InputMaybe<Array<Dbt_Store_Exposed_Product_Tag_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Exposed_Product_Tag_Order_By>>;
  where: InputMaybe<Dbt_Store_Exposed_Product_Tag_Bool_Exp>;
};

export type Subscription_RootDbt_Store_Exposed_Product_Tag_AggregateArgs = {
  distinct_on: InputMaybe<Array<Dbt_Store_Exposed_Product_Tag_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Exposed_Product_Tag_Order_By>>;
  where: InputMaybe<Dbt_Store_Exposed_Product_Tag_Bool_Exp>;
};

export type Subscription_RootDbt_Store_Exposed_Product_Tag_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Dbt_Store_Exposed_Product_Tag_Stream_Cursor_Input>>;
  where: InputMaybe<Dbt_Store_Exposed_Product_Tag_Bool_Exp>;
};

export type Subscription_RootDbt_Store_Exposed_Product_VariantArgs = {
  distinct_on: InputMaybe<
    Array<Dbt_Store_Exposed_Product_Variant_Select_Column>
  >;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Exposed_Product_Variant_Order_By>>;
  where: InputMaybe<Dbt_Store_Exposed_Product_Variant_Bool_Exp>;
};

export type Subscription_RootDbt_Store_Exposed_Product_Variant_AggregateArgs = {
  distinct_on: InputMaybe<
    Array<Dbt_Store_Exposed_Product_Variant_Select_Column>
  >;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Exposed_Product_Variant_Order_By>>;
  where: InputMaybe<Dbt_Store_Exposed_Product_Variant_Bool_Exp>;
};

export type Subscription_RootDbt_Store_Exposed_Product_Variant_By_PkArgs = {
  shopify_id: Scalars['bigint'];
};

export type Subscription_RootDbt_Store_Exposed_Product_Variant_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<
    InputMaybe<Dbt_Store_Exposed_Product_Variant_Stream_Cursor_Input>
  >;
  where: InputMaybe<Dbt_Store_Exposed_Product_Variant_Bool_Exp>;
};

export type Subscription_RootDbt_Store_Product_CollectionArgs = {
  distinct_on: InputMaybe<Array<Dbt_Store_Product_Collection_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Product_Collection_Order_By>>;
  where: InputMaybe<Dbt_Store_Product_Collection_Bool_Exp>;
};

export type Subscription_RootDbt_Store_Product_Collection_AggregateArgs = {
  distinct_on: InputMaybe<Array<Dbt_Store_Product_Collection_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Product_Collection_Order_By>>;
  where: InputMaybe<Dbt_Store_Product_Collection_Bool_Exp>;
};

export type Subscription_RootDbt_Store_Product_Collection_By_PkArgs = {
  collection_id: Scalars['String'];
  product_id: Scalars['String'];
};

export type Subscription_RootDbt_Store_Product_Collection_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Dbt_Store_Product_Collection_Stream_Cursor_Input>>;
  where: InputMaybe<Dbt_Store_Product_Collection_Bool_Exp>;
};

export type Subscription_RootDbt_Store_Product_For_AnalyticsArgs = {
  distinct_on: InputMaybe<Array<Dbt_Store_Product_For_Analytics_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Product_For_Analytics_Order_By>>;
  where: InputMaybe<Dbt_Store_Product_For_Analytics_Bool_Exp>;
};

export type Subscription_RootDbt_Store_Product_For_Analytics_AggregateArgs = {
  distinct_on: InputMaybe<Array<Dbt_Store_Product_For_Analytics_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Dbt_Store_Product_For_Analytics_Order_By>>;
  where: InputMaybe<Dbt_Store_Product_For_Analytics_Bool_Exp>;
};

export type Subscription_RootDbt_Store_Product_For_Analytics_By_PkArgs = {
  id: Scalars['String'];
};

export type Subscription_RootDbt_Store_Product_For_Analytics_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<
    InputMaybe<Dbt_Store_Product_For_Analytics_Stream_Cursor_Input>
  >;
  where: InputMaybe<Dbt_Store_Product_For_Analytics_Bool_Exp>;
};

export type Subscription_RootUserArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootUsersArgs = {
  distinct_on: InputMaybe<Array<Users_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Users_Order_By>>;
  where: InputMaybe<Users_Bool_Exp>;
};

export type Subscription_RootUsersAggregateArgs = {
  distinct_on: InputMaybe<Array<Users_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Users_Order_By>>;
  where: InputMaybe<Users_Bool_Exp>;
};

export type Subscription_RootUsers_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Users_Stream_Cursor_Input>>;
  where: InputMaybe<Users_Bool_Exp>;
};

/** Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'. */
export type Timestamp_Comparison_Exp = {
  _eq: InputMaybe<Scalars['timestamp']>;
  _gt: InputMaybe<Scalars['timestamp']>;
  _gte: InputMaybe<Scalars['timestamp']>;
  _in: InputMaybe<Array<Scalars['timestamp']>>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  _lt: InputMaybe<Scalars['timestamp']>;
  _lte: InputMaybe<Scalars['timestamp']>;
  _neq: InputMaybe<Scalars['timestamp']>;
  _nin: InputMaybe<Array<Scalars['timestamp']>>;
};

/** Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'. */
export type Timestamptz_Comparison_Exp = {
  _eq: InputMaybe<Scalars['timestamptz']>;
  _gt: InputMaybe<Scalars['timestamptz']>;
  _gte: InputMaybe<Scalars['timestamptz']>;
  _in: InputMaybe<Array<Scalars['timestamptz']>>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  _lt: InputMaybe<Scalars['timestamptz']>;
  _lte: InputMaybe<Scalars['timestamptz']>;
  _neq: InputMaybe<Scalars['timestamptz']>;
  _nin: InputMaybe<Array<Scalars['timestamptz']>>;
};

/** columns and relationships of "auth.users" */
export type Users = {
  __typename?: 'users';
  activeMfaType: Maybe<Scalars['String']>;
  avatarUrl: Scalars['String'];
  createdAt: Scalars['timestamptz'];
  currentChallenge: Maybe<Scalars['String']>;
  /** An object relationship */
  customer: Maybe<Customer>;
  defaultRole: Scalars['String'];
  /** An object relationship */
  defaultRoleByRole: Auth_Roles;
  disabled: Scalars['Boolean'];
  displayName: Scalars['String'];
  email: Maybe<Scalars['citext']>;
  emailVerified: Scalars['Boolean'];
  id: Scalars['uuid'];
  isAnonymous: Scalars['Boolean'];
  lastSeen: Maybe<Scalars['timestamptz']>;
  locale: Scalars['String'];
  metadata: Maybe<Scalars['jsonb']>;
  newEmail: Maybe<Scalars['citext']>;
  otpHash: Maybe<Scalars['String']>;
  otpHashExpiresAt: Scalars['timestamptz'];
  otpMethodLastUsed: Maybe<Scalars['String']>;
  passwordHash: Maybe<Scalars['String']>;
  phoneNumber: Maybe<Scalars['String']>;
  phoneNumberVerified: Scalars['Boolean'];
  /** An array relationship */
  refreshTokens: Array<AuthRefreshTokens>;
  /** An aggregate relationship */
  refreshTokens_aggregate: AuthRefreshTokens_Aggregate;
  /** An array relationship */
  roles: Array<AuthUserRoles>;
  /** An aggregate relationship */
  roles_aggregate: AuthUserRoles_Aggregate;
  /** An array relationship */
  securityKeys: Array<AuthUserSecurityKeys>;
  /** An aggregate relationship */
  securityKeys_aggregate: AuthUserSecurityKeys_Aggregate;
  ticket: Maybe<Scalars['String']>;
  ticketExpiresAt: Scalars['timestamptz'];
  totpSecret: Maybe<Scalars['String']>;
  updatedAt: Scalars['timestamptz'];
  /** An array relationship */
  userProviders: Array<Auth_User_Providers>;
  /** An aggregate relationship */
  userProviders_aggregate: Auth_User_Providers_Aggregate;
};

/** columns and relationships of "auth.users" */
export type UsersMetadataArgs = {
  path: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "auth.users" */
export type UsersRefreshTokensArgs = {
  distinct_on: InputMaybe<Array<AuthRefreshTokens_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<AuthRefreshTokens_Order_By>>;
  where: InputMaybe<AuthRefreshTokens_Bool_Exp>;
};

/** columns and relationships of "auth.users" */
export type UsersRefreshTokens_AggregateArgs = {
  distinct_on: InputMaybe<Array<AuthRefreshTokens_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<AuthRefreshTokens_Order_By>>;
  where: InputMaybe<AuthRefreshTokens_Bool_Exp>;
};

/** columns and relationships of "auth.users" */
export type UsersRolesArgs = {
  distinct_on: InputMaybe<Array<AuthUserRoles_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<AuthUserRoles_Order_By>>;
  where: InputMaybe<AuthUserRoles_Bool_Exp>;
};

/** columns and relationships of "auth.users" */
export type UsersRoles_AggregateArgs = {
  distinct_on: InputMaybe<Array<AuthUserRoles_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<AuthUserRoles_Order_By>>;
  where: InputMaybe<AuthUserRoles_Bool_Exp>;
};

/** columns and relationships of "auth.users" */
export type UsersSecurityKeysArgs = {
  distinct_on: InputMaybe<Array<AuthUserSecurityKeys_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<AuthUserSecurityKeys_Order_By>>;
  where: InputMaybe<AuthUserSecurityKeys_Bool_Exp>;
};

/** columns and relationships of "auth.users" */
export type UsersSecurityKeys_AggregateArgs = {
  distinct_on: InputMaybe<Array<AuthUserSecurityKeys_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<AuthUserSecurityKeys_Order_By>>;
  where: InputMaybe<AuthUserSecurityKeys_Bool_Exp>;
};

/** columns and relationships of "auth.users" */
export type UsersUserProvidersArgs = {
  distinct_on: InputMaybe<Array<Auth_User_Providers_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Auth_User_Providers_Order_By>>;
  where: InputMaybe<Auth_User_Providers_Bool_Exp>;
};

/** columns and relationships of "auth.users" */
export type UsersUserProviders_AggregateArgs = {
  distinct_on: InputMaybe<Array<Auth_User_Providers_Select_Column>>;
  limit: InputMaybe<Scalars['Int']>;
  offset: InputMaybe<Scalars['Int']>;
  order_by: InputMaybe<Array<Auth_User_Providers_Order_By>>;
  where: InputMaybe<Auth_User_Providers_Bool_Exp>;
};

/** aggregated selection of "auth.users" */
export type Users_Aggregate = {
  __typename?: 'users_aggregate';
  aggregate: Maybe<Users_Aggregate_Fields>;
  nodes: Array<Users>;
};

/** aggregate fields of "auth.users" */
export type Users_Aggregate_Fields = {
  __typename?: 'users_aggregate_fields';
  count: Scalars['Int'];
  max: Maybe<Users_Max_Fields>;
  min: Maybe<Users_Min_Fields>;
};

/** aggregate fields of "auth.users" */
export type Users_Aggregate_FieldsCountArgs = {
  columns: InputMaybe<Array<Users_Select_Column>>;
  distinct: InputMaybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Users_Append_Input = {
  metadata: InputMaybe<Scalars['jsonb']>;
};

/** Boolean expression to filter rows from the table "auth.users". All fields are combined with a logical 'AND'. */
export type Users_Bool_Exp = {
  _and: InputMaybe<Array<Users_Bool_Exp>>;
  _not: InputMaybe<Users_Bool_Exp>;
  _or: InputMaybe<Array<Users_Bool_Exp>>;
  activeMfaType: InputMaybe<String_Comparison_Exp>;
  avatarUrl: InputMaybe<String_Comparison_Exp>;
  createdAt: InputMaybe<Timestamptz_Comparison_Exp>;
  currentChallenge: InputMaybe<String_Comparison_Exp>;
  customer: InputMaybe<Customer_Bool_Exp>;
  defaultRole: InputMaybe<String_Comparison_Exp>;
  defaultRoleByRole: InputMaybe<Auth_Roles_Bool_Exp>;
  disabled: InputMaybe<Boolean_Comparison_Exp>;
  displayName: InputMaybe<String_Comparison_Exp>;
  email: InputMaybe<Citext_Comparison_Exp>;
  emailVerified: InputMaybe<Boolean_Comparison_Exp>;
  id: InputMaybe<Uuid_Comparison_Exp>;
  isAnonymous: InputMaybe<Boolean_Comparison_Exp>;
  lastSeen: InputMaybe<Timestamptz_Comparison_Exp>;
  locale: InputMaybe<String_Comparison_Exp>;
  metadata: InputMaybe<Jsonb_Comparison_Exp>;
  newEmail: InputMaybe<Citext_Comparison_Exp>;
  otpHash: InputMaybe<String_Comparison_Exp>;
  otpHashExpiresAt: InputMaybe<Timestamptz_Comparison_Exp>;
  otpMethodLastUsed: InputMaybe<String_Comparison_Exp>;
  passwordHash: InputMaybe<String_Comparison_Exp>;
  phoneNumber: InputMaybe<String_Comparison_Exp>;
  phoneNumberVerified: InputMaybe<Boolean_Comparison_Exp>;
  refreshTokens: InputMaybe<AuthRefreshTokens_Bool_Exp>;
  refreshTokens_aggregate: InputMaybe<AuthRefreshTokens_Aggregate_Bool_Exp>;
  roles: InputMaybe<AuthUserRoles_Bool_Exp>;
  roles_aggregate: InputMaybe<AuthUserRoles_Aggregate_Bool_Exp>;
  securityKeys: InputMaybe<AuthUserSecurityKeys_Bool_Exp>;
  securityKeys_aggregate: InputMaybe<AuthUserSecurityKeys_Aggregate_Bool_Exp>;
  ticket: InputMaybe<String_Comparison_Exp>;
  ticketExpiresAt: InputMaybe<Timestamptz_Comparison_Exp>;
  totpSecret: InputMaybe<String_Comparison_Exp>;
  updatedAt: InputMaybe<Timestamptz_Comparison_Exp>;
  userProviders: InputMaybe<Auth_User_Providers_Bool_Exp>;
  userProviders_aggregate: InputMaybe<Auth_User_Providers_Aggregate_Bool_Exp>;
};

/** unique or primary key constraints on table "auth.users" */
export enum Users_Constraint {
  /** unique or primary key constraint on columns "email" */
  UsersEmailKey = 'users_email_key',
  /** unique or primary key constraint on columns "id" */
  UsersPkey = 'users_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Users_Delete_At_Path_Input = {
  metadata: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Users_Delete_Elem_Input = {
  metadata: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Users_Delete_Key_Input = {
  metadata: InputMaybe<Scalars['String']>;
};

/** input type for inserting data into table "auth.users" */
export type Users_Insert_Input = {
  activeMfaType: InputMaybe<Scalars['String']>;
  avatarUrl: InputMaybe<Scalars['String']>;
  createdAt: InputMaybe<Scalars['timestamptz']>;
  currentChallenge: InputMaybe<Scalars['String']>;
  customer: InputMaybe<Customer_Obj_Rel_Insert_Input>;
  defaultRole: InputMaybe<Scalars['String']>;
  defaultRoleByRole: InputMaybe<Auth_Roles_Obj_Rel_Insert_Input>;
  disabled: InputMaybe<Scalars['Boolean']>;
  displayName: InputMaybe<Scalars['String']>;
  email: InputMaybe<Scalars['citext']>;
  emailVerified: InputMaybe<Scalars['Boolean']>;
  id: InputMaybe<Scalars['uuid']>;
  isAnonymous: InputMaybe<Scalars['Boolean']>;
  lastSeen: InputMaybe<Scalars['timestamptz']>;
  locale: InputMaybe<Scalars['String']>;
  metadata: InputMaybe<Scalars['jsonb']>;
  newEmail: InputMaybe<Scalars['citext']>;
  otpHash: InputMaybe<Scalars['String']>;
  otpHashExpiresAt: InputMaybe<Scalars['timestamptz']>;
  otpMethodLastUsed: InputMaybe<Scalars['String']>;
  passwordHash: InputMaybe<Scalars['String']>;
  phoneNumber: InputMaybe<Scalars['String']>;
  phoneNumberVerified: InputMaybe<Scalars['Boolean']>;
  refreshTokens: InputMaybe<AuthRefreshTokens_Arr_Rel_Insert_Input>;
  roles: InputMaybe<AuthUserRoles_Arr_Rel_Insert_Input>;
  securityKeys: InputMaybe<AuthUserSecurityKeys_Arr_Rel_Insert_Input>;
  ticket: InputMaybe<Scalars['String']>;
  ticketExpiresAt: InputMaybe<Scalars['timestamptz']>;
  totpSecret: InputMaybe<Scalars['String']>;
  updatedAt: InputMaybe<Scalars['timestamptz']>;
  userProviders: InputMaybe<Auth_User_Providers_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Users_Max_Fields = {
  __typename?: 'users_max_fields';
  activeMfaType: Maybe<Scalars['String']>;
  avatarUrl: Maybe<Scalars['String']>;
  createdAt: Maybe<Scalars['timestamptz']>;
  currentChallenge: Maybe<Scalars['String']>;
  defaultRole: Maybe<Scalars['String']>;
  displayName: Maybe<Scalars['String']>;
  email: Maybe<Scalars['citext']>;
  id: Maybe<Scalars['uuid']>;
  lastSeen: Maybe<Scalars['timestamptz']>;
  locale: Maybe<Scalars['String']>;
  newEmail: Maybe<Scalars['citext']>;
  otpHash: Maybe<Scalars['String']>;
  otpHashExpiresAt: Maybe<Scalars['timestamptz']>;
  otpMethodLastUsed: Maybe<Scalars['String']>;
  passwordHash: Maybe<Scalars['String']>;
  phoneNumber: Maybe<Scalars['String']>;
  ticket: Maybe<Scalars['String']>;
  ticketExpiresAt: Maybe<Scalars['timestamptz']>;
  totpSecret: Maybe<Scalars['String']>;
  updatedAt: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Users_Min_Fields = {
  __typename?: 'users_min_fields';
  activeMfaType: Maybe<Scalars['String']>;
  avatarUrl: Maybe<Scalars['String']>;
  createdAt: Maybe<Scalars['timestamptz']>;
  currentChallenge: Maybe<Scalars['String']>;
  defaultRole: Maybe<Scalars['String']>;
  displayName: Maybe<Scalars['String']>;
  email: Maybe<Scalars['citext']>;
  id: Maybe<Scalars['uuid']>;
  lastSeen: Maybe<Scalars['timestamptz']>;
  locale: Maybe<Scalars['String']>;
  newEmail: Maybe<Scalars['citext']>;
  otpHash: Maybe<Scalars['String']>;
  otpHashExpiresAt: Maybe<Scalars['timestamptz']>;
  otpMethodLastUsed: Maybe<Scalars['String']>;
  passwordHash: Maybe<Scalars['String']>;
  phoneNumber: Maybe<Scalars['String']>;
  ticket: Maybe<Scalars['String']>;
  ticketExpiresAt: Maybe<Scalars['timestamptz']>;
  totpSecret: Maybe<Scalars['String']>;
  updatedAt: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "auth.users" */
export type Users_Mutation_Response = {
  __typename?: 'users_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Users>;
};

/** input type for inserting object relation for remote table "auth.users" */
export type Users_Obj_Rel_Insert_Input = {
  data: Users_Insert_Input;
  /** upsert condition */
  on_conflict: InputMaybe<Users_On_Conflict>;
};

/** on_conflict condition type for table "auth.users" */
export type Users_On_Conflict = {
  constraint: Users_Constraint;
  update_columns: Array<Users_Update_Column>;
  where: InputMaybe<Users_Bool_Exp>;
};

/** Ordering options when selecting data from "auth.users". */
export type Users_Order_By = {
  activeMfaType: InputMaybe<Order_By>;
  avatarUrl: InputMaybe<Order_By>;
  createdAt: InputMaybe<Order_By>;
  currentChallenge: InputMaybe<Order_By>;
  customer: InputMaybe<Customer_Order_By>;
  defaultRole: InputMaybe<Order_By>;
  defaultRoleByRole: InputMaybe<Auth_Roles_Order_By>;
  disabled: InputMaybe<Order_By>;
  displayName: InputMaybe<Order_By>;
  email: InputMaybe<Order_By>;
  emailVerified: InputMaybe<Order_By>;
  id: InputMaybe<Order_By>;
  isAnonymous: InputMaybe<Order_By>;
  lastSeen: InputMaybe<Order_By>;
  locale: InputMaybe<Order_By>;
  metadata: InputMaybe<Order_By>;
  newEmail: InputMaybe<Order_By>;
  otpHash: InputMaybe<Order_By>;
  otpHashExpiresAt: InputMaybe<Order_By>;
  otpMethodLastUsed: InputMaybe<Order_By>;
  passwordHash: InputMaybe<Order_By>;
  phoneNumber: InputMaybe<Order_By>;
  phoneNumberVerified: InputMaybe<Order_By>;
  refreshTokens_aggregate: InputMaybe<AuthRefreshTokens_Aggregate_Order_By>;
  roles_aggregate: InputMaybe<AuthUserRoles_Aggregate_Order_By>;
  securityKeys_aggregate: InputMaybe<AuthUserSecurityKeys_Aggregate_Order_By>;
  ticket: InputMaybe<Order_By>;
  ticketExpiresAt: InputMaybe<Order_By>;
  totpSecret: InputMaybe<Order_By>;
  updatedAt: InputMaybe<Order_By>;
  userProviders_aggregate: InputMaybe<Auth_User_Providers_Aggregate_Order_By>;
};

/** primary key columns input for table: auth.users */
export type Users_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Users_Prepend_Input = {
  metadata: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "auth.users" */
export enum Users_Select_Column {
  /** column name */
  ActiveMfaType = 'activeMfaType',
  /** column name */
  AvatarUrl = 'avatarUrl',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CurrentChallenge = 'currentChallenge',
  /** column name */
  DefaultRole = 'defaultRole',
  /** column name */
  Disabled = 'disabled',
  /** column name */
  DisplayName = 'displayName',
  /** column name */
  Email = 'email',
  /** column name */
  EmailVerified = 'emailVerified',
  /** column name */
  Id = 'id',
  /** column name */
  IsAnonymous = 'isAnonymous',
  /** column name */
  LastSeen = 'lastSeen',
  /** column name */
  Locale = 'locale',
  /** column name */
  Metadata = 'metadata',
  /** column name */
  NewEmail = 'newEmail',
  /** column name */
  OtpHash = 'otpHash',
  /** column name */
  OtpHashExpiresAt = 'otpHashExpiresAt',
  /** column name */
  OtpMethodLastUsed = 'otpMethodLastUsed',
  /** column name */
  PasswordHash = 'passwordHash',
  /** column name */
  PhoneNumber = 'phoneNumber',
  /** column name */
  PhoneNumberVerified = 'phoneNumberVerified',
  /** column name */
  Ticket = 'ticket',
  /** column name */
  TicketExpiresAt = 'ticketExpiresAt',
  /** column name */
  TotpSecret = 'totpSecret',
  /** column name */
  UpdatedAt = 'updatedAt',
}

/** input type for updating data in table "auth.users" */
export type Users_Set_Input = {
  activeMfaType: InputMaybe<Scalars['String']>;
  avatarUrl: InputMaybe<Scalars['String']>;
  createdAt: InputMaybe<Scalars['timestamptz']>;
  currentChallenge: InputMaybe<Scalars['String']>;
  defaultRole: InputMaybe<Scalars['String']>;
  disabled: InputMaybe<Scalars['Boolean']>;
  displayName: InputMaybe<Scalars['String']>;
  email: InputMaybe<Scalars['citext']>;
  emailVerified: InputMaybe<Scalars['Boolean']>;
  id: InputMaybe<Scalars['uuid']>;
  isAnonymous: InputMaybe<Scalars['Boolean']>;
  lastSeen: InputMaybe<Scalars['timestamptz']>;
  locale: InputMaybe<Scalars['String']>;
  metadata: InputMaybe<Scalars['jsonb']>;
  newEmail: InputMaybe<Scalars['citext']>;
  otpHash: InputMaybe<Scalars['String']>;
  otpHashExpiresAt: InputMaybe<Scalars['timestamptz']>;
  otpMethodLastUsed: InputMaybe<Scalars['String']>;
  passwordHash: InputMaybe<Scalars['String']>;
  phoneNumber: InputMaybe<Scalars['String']>;
  phoneNumberVerified: InputMaybe<Scalars['Boolean']>;
  ticket: InputMaybe<Scalars['String']>;
  ticketExpiresAt: InputMaybe<Scalars['timestamptz']>;
  totpSecret: InputMaybe<Scalars['String']>;
  updatedAt: InputMaybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "users" */
export type Users_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Users_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Users_Stream_Cursor_Value_Input = {
  activeMfaType: InputMaybe<Scalars['String']>;
  avatarUrl: InputMaybe<Scalars['String']>;
  createdAt: InputMaybe<Scalars['timestamptz']>;
  currentChallenge: InputMaybe<Scalars['String']>;
  defaultRole: InputMaybe<Scalars['String']>;
  disabled: InputMaybe<Scalars['Boolean']>;
  displayName: InputMaybe<Scalars['String']>;
  email: InputMaybe<Scalars['citext']>;
  emailVerified: InputMaybe<Scalars['Boolean']>;
  id: InputMaybe<Scalars['uuid']>;
  isAnonymous: InputMaybe<Scalars['Boolean']>;
  lastSeen: InputMaybe<Scalars['timestamptz']>;
  locale: InputMaybe<Scalars['String']>;
  metadata: InputMaybe<Scalars['jsonb']>;
  newEmail: InputMaybe<Scalars['citext']>;
  otpHash: InputMaybe<Scalars['String']>;
  otpHashExpiresAt: InputMaybe<Scalars['timestamptz']>;
  otpMethodLastUsed: InputMaybe<Scalars['String']>;
  passwordHash: InputMaybe<Scalars['String']>;
  phoneNumber: InputMaybe<Scalars['String']>;
  phoneNumberVerified: InputMaybe<Scalars['Boolean']>;
  ticket: InputMaybe<Scalars['String']>;
  ticketExpiresAt: InputMaybe<Scalars['timestamptz']>;
  totpSecret: InputMaybe<Scalars['String']>;
  updatedAt: InputMaybe<Scalars['timestamptz']>;
};

/** update columns of table "auth.users" */
export enum Users_Update_Column {
  /** column name */
  ActiveMfaType = 'activeMfaType',
  /** column name */
  AvatarUrl = 'avatarUrl',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CurrentChallenge = 'currentChallenge',
  /** column name */
  DefaultRole = 'defaultRole',
  /** column name */
  Disabled = 'disabled',
  /** column name */
  DisplayName = 'displayName',
  /** column name */
  Email = 'email',
  /** column name */
  EmailVerified = 'emailVerified',
  /** column name */
  Id = 'id',
  /** column name */
  IsAnonymous = 'isAnonymous',
  /** column name */
  LastSeen = 'lastSeen',
  /** column name */
  Locale = 'locale',
  /** column name */
  Metadata = 'metadata',
  /** column name */
  NewEmail = 'newEmail',
  /** column name */
  OtpHash = 'otpHash',
  /** column name */
  OtpHashExpiresAt = 'otpHashExpiresAt',
  /** column name */
  OtpMethodLastUsed = 'otpMethodLastUsed',
  /** column name */
  PasswordHash = 'passwordHash',
  /** column name */
  PhoneNumber = 'phoneNumber',
  /** column name */
  PhoneNumberVerified = 'phoneNumberVerified',
  /** column name */
  Ticket = 'ticket',
  /** column name */
  TicketExpiresAt = 'ticketExpiresAt',
  /** column name */
  TotpSecret = 'totpSecret',
  /** column name */
  UpdatedAt = 'updatedAt',
}

export type Users_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append: InputMaybe<Users_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path: InputMaybe<Users_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem: InputMaybe<Users_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key: InputMaybe<Users_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend: InputMaybe<Users_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set: InputMaybe<Users_Set_Input>;
  /** filter the rows which have to be updated */
  where: Users_Bool_Exp;
};

/** Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'. */
export type Uuid_Comparison_Exp = {
  _eq: InputMaybe<Scalars['uuid']>;
  _gt: InputMaybe<Scalars['uuid']>;
  _gte: InputMaybe<Scalars['uuid']>;
  _in: InputMaybe<Array<Scalars['uuid']>>;
  _is_null: InputMaybe<Scalars['Boolean']>;
  _lt: InputMaybe<Scalars['uuid']>;
  _lte: InputMaybe<Scalars['uuid']>;
  _neq: InputMaybe<Scalars['uuid']>;
  _nin: InputMaybe<Array<Scalars['uuid']>>;
};

export type GetAvailableDiscountsQueryVariables = Exact<{
  discountTitles: InputMaybe<Array<Scalars['String']> | Scalars['String']>;
}>;

export type GetAvailableDiscountsQuery = {
  __typename?: 'query_root';
  dbt_store_discount: Array<{
    __typename?: 'dbt_store_discount';
    ends_at: any | null;
    starts_at: any;
    id: any;
    value: any;
    value_type: string;
    code: string | null;
    title: string;
    min_amount: any | null;
    collection: Array<{
      __typename?: 'dbt_store_discount_collection';
      collection_internal_id: string;
    }>;
  }>;
};

export type SubscribeToOpenedPriceOfferSubscriptionVariables = Exact<{
  productShopifyId: InputMaybe<Scalars['bigint']>;
}>;

export type SubscribeToOpenedPriceOfferSubscription = {
  __typename?: 'subscription_root';
  PriceOffer: Array<{
    __typename?: 'PriceOffer';
    newPriceInCents: any;
    id: string;
    initiatedBy: any;
    status: any;
    discountCode: string | null;
  }>;
};

export type HandDeliveryOrderLineFragmentFragment = {
  __typename?: 'OrderLines';
  shippingSolution: any;
  order: { __typename?: 'Order'; shopifyId: string };
  productVariant: {
    __typename?: 'ProductVariant';
    product: { __typename?: 'Product'; shopifyId: any };
  } | null;
};

export type FetchConversationUserDetailsQueryVariables = Exact<{
  userShopifyId: InputMaybe<Scalars['bigint']>;
}>;

export type FetchConversationUserDetailsQuery = {
  __typename?: 'query_root';
  Customer: Array<{
    __typename?: 'Customer';
    purchasedOrders: Array<{
      __typename?: 'Order';
      orderLines: Array<{
        __typename?: 'OrderLines';
        shippingSolution: any;
        order: { __typename?: 'Order'; shopifyId: string };
        productVariant: {
          __typename?: 'ProductVariant';
          product: { __typename?: 'Product'; shopifyId: any };
        } | null;
      }>;
    }>;
    vendorSoldOrderLines: Array<{
      __typename?: 'OrderLines';
      shippingSolution: any;
      order: { __typename?: 'Order'; shopifyId: string };
      productVariant: {
        __typename?: 'ProductVariant';
        product: { __typename?: 'Product'; shopifyId: any };
      } | null;
    }>;
    onlineProducts: Array<{ __typename?: 'Product'; shopifyId: any }>;
  }>;
};

export type FetchConversationProductDetailsQueryVariables = Exact<{
  productShopifyId: InputMaybe<Scalars['bigint']>;
}>;

export type FetchConversationProductDetailsQuery = {
  __typename?: 'query_root';
  Product: Array<{
    __typename?: 'Product';
    id: string;
    handle: string | null;
    vendorId: any;
    variants: Array<{
      __typename?: 'ProductVariant';
      storeExposedVariant: {
        __typename?: 'dbt_store_exposed_product_variant';
        price: any;
      } | null;
    }>;
    Vendor: {
      __typename?: 'Customer';
      negociationAgreements: Array<{
        __typename?: 'NegociationAgreement';
        maxAmountPercent: number;
        priority: number;
        productType: string | null;
      }>;
    };
  }>;
};

export type FetchNegociationAgreementQueryVariables = Exact<{
  vendorId: InputMaybe<Scalars['uuid']>;
}>;

export type FetchNegociationAgreementQuery = {
  __typename?: 'query_root';
  NegociationAgreement: Array<{
    __typename?: 'NegociationAgreement';
    id: string;
    maxAmountPercent: number;
  }>;
  Customer: Array<{ __typename?: 'Customer'; phoneNumber: string | null }>;
};

export type OpenedPriceOfferProductPageSubscriptionVariables = Exact<{
  productId: Scalars['String'];
}>;

export type OpenedPriceOfferProductPageSubscription = {
  __typename?: 'subscription_root';
  PriceOffer: Array<{
    __typename?: 'PriceOffer';
    id: string;
    product: { __typename?: 'Product'; shopifyId: any };
  }>;
};

export type VendorDetailsFragment = {
  __typename?: 'Customer';
  isPro: boolean;
  sellerName: string | null;
  shipmentTimeframe: any | null;
  profilePictureShopifyCdnUrl: string | null;
  createdAt: any;
  authUserId: any;
  VendorReviews: Array<{
    __typename?: 'VendorReview';
    Review: {
      __typename?: 'Review';
      content: string | null;
      createdAt: any;
      id: string;
      rating: number;
      title: string;
      authorNickname: string | null;
      Customer: {
        __typename?: 'Customer';
        createdAt: any;
        sellerName: string | null;
        profilePictureShopifyCdnUrl: string | null;
      };
    };
  }>;
  negociationAgreements: Array<{
    __typename?: 'NegociationAgreement';
    maxAmountPercent: number;
  }>;
};

export type ProductCardFieldsFragment = {
  __typename?: 'dbt_store_exposed_product';
  handle: string;
  vendor: string;
  title: string;
  description: string | null;
  productType: string;
  numberOfViews: any;
  status: any;
  product: {
    __typename?: 'dbt_store_base_product';
    id: string;
    shopifyId: any;
    collections: Array<{
      __typename?: 'dbt_store_product_collection';
      collection_id: string;
    }>;
    variants: Array<{
      __typename?: 'dbt_store_base_product_variant';
      id: string | null;
      shopifyId: any;
      variant: {
        __typename?: 'dbt_store_exposed_product_variant';
        inventoryQuantity: any;
        option1Name: string | null;
        option1: string | null;
        option2Name: string | null;
        option2: string | null;
        option3Name: string | null;
        option3: string | null;
        price: any;
        compareAtPrice: any | null;
        condition: any | null;
        isRefurbished: boolean | null;
      } | null;
    }>;
    tags: Array<{
      __typename?: 'dbt_store_exposed_product_tag';
      tag: string;
      value: string;
    }>;
    images: Array<{
      __typename?: 'dbt_store_exposed_product_image';
      alt: string | null;
      src: string;
      height: any;
      width: any;
    }>;
  } | null;
};

export type FetchProductsQueryVariables = Exact<{
  productIds: InputMaybe<Array<Scalars['bigint']> | Scalars['bigint']>;
  productHandles: InputMaybe<Array<Scalars['String']> | Scalars['String']>;
}>;

export type FetchProductsQuery = {
  __typename?: 'query_root';
  Product: Array<{
    __typename?: 'Product';
    storeExposedProduct: {
      __typename?: 'dbt_store_exposed_product';
      handle: string;
      vendor: string;
      title: string;
      description: string | null;
      productType: string;
      numberOfViews: any;
      status: any;
      product: {
        __typename?: 'dbt_store_base_product';
        id: string;
        shopifyId: any;
        collections: Array<{
          __typename?: 'dbt_store_product_collection';
          collection_id: string;
        }>;
        variants: Array<{
          __typename?: 'dbt_store_base_product_variant';
          id: string | null;
          shopifyId: any;
          variant: {
            __typename?: 'dbt_store_exposed_product_variant';
            inventoryQuantity: any;
            option1Name: string | null;
            option1: string | null;
            option2Name: string | null;
            option2: string | null;
            option3Name: string | null;
            option3: string | null;
            price: any;
            compareAtPrice: any | null;
            condition: any | null;
            isRefurbished: boolean | null;
          } | null;
        }>;
        tags: Array<{
          __typename?: 'dbt_store_exposed_product_tag';
          tag: string;
          value: string;
        }>;
        images: Array<{
          __typename?: 'dbt_store_exposed_product_image';
          alt: string | null;
          src: string;
          height: any;
          width: any;
        }>;
      } | null;
    } | null;
    Vendor: {
      __typename?: 'Customer';
      isPro: boolean;
      sellerName: string | null;
      shipmentTimeframe: any | null;
      profilePictureShopifyCdnUrl: string | null;
      createdAt: any;
      authUserId: any;
      VendorReviews: Array<{
        __typename?: 'VendorReview';
        Review: {
          __typename?: 'Review';
          content: string | null;
          createdAt: any;
          id: string;
          rating: number;
          title: string;
          authorNickname: string | null;
          Customer: {
            __typename?: 'Customer';
            createdAt: any;
            sellerName: string | null;
            profilePictureShopifyCdnUrl: string | null;
          };
        };
      }>;
      negociationAgreements: Array<{
        __typename?: 'NegociationAgreement';
        maxAmountPercent: number;
      }>;
    };
  }>;
};

export type ReviewsFieldsFragment = {
  __typename?: 'VendorReview';
  Review: {
    __typename?: 'Review';
    content: string | null;
    createdAt: any;
    id: string;
    rating: number;
    title: string;
    authorNickname: string | null;
    Customer: {
      __typename?: 'Customer';
      createdAt: any;
      sellerName: string | null;
      profilePictureShopifyCdnUrl: string | null;
    };
  };
};

export type SaveNewSearchAlertMutationVariables = Exact<{
  searchAlertInput: SearchAlert_Insert_Input;
}>;

export type SaveNewSearchAlertMutation = {
  __typename?: 'mutation_root';
  insert_SearchAlert_one: { __typename?: 'SearchAlert'; id: string } | null;
};

export type FetchOnlineProductsQueryVariables = Exact<{ [key: string]: never }>;

export type FetchOnlineProductsQuery = {
  __typename?: 'query_root';
  Customer: Array<{
    __typename?: 'Customer';
    onlineProducts: Array<{
      __typename?: 'Product';
      status: any;
      shopifyId: any;
      storeProduct: {
        __typename?: 'dbt_store_exposed_product';
        handle: string;
        productType: string;
        numberOfViews: any;
        size: string | null;
        gender: string | null;
        modelYear: string | null;
        brand: string | null;
        firstImage: string | null;
        product: {
          __typename?: 'dbt_store_base_product';
          variants: Array<{
            __typename?: 'dbt_store_base_product_variant';
            variant: {
              __typename?: 'dbt_store_exposed_product_variant';
              condition: any | null;
              price: any;
            } | null;
          }>;
        } | null;
      } | null;
    }>;
  }>;
};

export type FetchSoldOrderLinesQueryVariables = Exact<{ [key: string]: never }>;

export type FetchSoldOrderLinesQuery = {
  __typename?: 'query_root';
  Customer: Array<{
    __typename?: 'Customer';
    vendorSoldOrderLines: Array<{
      __typename?: 'OrderLines';
      priceInCents: any;
      productType: string;
      productImage: string | null;
      brand: string | null;
      handle: string;
      size: string | null;
      condition: any | null;
      gender: string | null;
      modelYear: string | null;
      order: {
        __typename?: 'Order';
        id: string;
        status: any;
        name: string;
        createdAt: any;
      };
    }>;
  }>;
};

export type FetchOrderDataQueryVariables = Exact<{
  orderId: InputMaybe<Scalars['String']>;
}>;

export type FetchOrderDataQuery = {
  __typename?: 'query_root';
  Order: Array<{
    __typename?: 'Order';
    name: string;
    createdAt: any;
    shippingAddressAddress1: string;
    shippingAddressAddress2: string | null;
    shippingAddressCity: string;
    shippingAddressCountry: string;
    shippingAddressPhone: string;
    shippingAddressFirstName: string | null;
    shippingAddressLastName: string;
    shippingAddressZip: string;
    status: any;
    orderLines: Array<{
      __typename?: 'OrderLines';
      productType: string;
      productImage: string | null;
      priceInCents: any;
      shippingSolution: any;
      id: string;
      brand: string | null;
      variantName: string;
      modelYear: string | null;
      size: string | null;
      condition: any | null;
      handle: string;
      fulfillmentOrder: {
        __typename?: 'FulfillmentOrder';
        status: any;
        fulfillments: Array<{
          __typename?: 'Fulfillment';
          trackingUrl: string;
        }>;
      } | null;
      vendorCustomer: { __typename?: 'Customer'; usedShipping: any } | null;
    }>;
  }>;
};

export type FetchPurchasesQueryVariables = Exact<{ [key: string]: never }>;

export type FetchPurchasesQuery = {
  __typename?: 'query_root';
  Customer: Array<{
    __typename?: 'Customer';
    purchasedOrders: Array<{
      __typename?: 'Order';
      id: string;
      name: string;
      status: any;
      createdAt: any;
      totalPriceInCents: any;
      orderLines: Array<{
        __typename?: 'OrderLines';
        productType: string;
        name: string;
        productImage: string | null;
        brand: string | null;
        handle: string;
        size: string | null;
        condition: any | null;
        gender: string | null;
        modelYear: string | null;
      }>;
    }>;
  }>;
};

export type FetchSavedSearchesQueryVariables = Exact<{ [key: string]: never }>;

export type FetchSavedSearchesQuery = {
  __typename?: 'query_root';
  SavedSearch: Array<{
    __typename?: 'SavedSearch';
    id: string;
    name: string;
    resultsUrl: string | null;
    FacetFilters: Array<{
      __typename?: 'FacetFilter';
      facetName: string;
      label: string;
      value: string;
    }>;
    NumericFilters: Array<{
      __typename?: 'NumericFilter';
      facetName: string;
      operator: string;
      value: string;
    }>;
  }>;
};

export type RemoveSavedSearchMutationVariables = Exact<{
  searchId: Scalars['String'];
}>;

export type RemoveSavedSearchMutation = {
  __typename?: 'mutation_root';
  delete_SavedSearch_by_pk: { __typename?: 'SavedSearch'; id: string } | null;
};

export type StoreProductFieldsFragment = {
  __typename?: 'dbt_store_exposed_product';
  firstImage: string | null;
  handle: string;
  productType: string;
  size: string | null;
  gender: string | null;
  modelYear: string | null;
  brand: string | null;
  product: {
    __typename?: 'dbt_store_base_product';
    variants: Array<{
      __typename?: 'dbt_store_base_product_variant';
      variant: {
        __typename?: 'dbt_store_exposed_product_variant';
        condition: any | null;
        price: any;
      } | null;
    }>;
  } | null;
};

export type FetchAccountPageCustomerDataQueryVariables = Exact<{
  maxItems: InputMaybe<Scalars['Int']>;
}>;

export type FetchAccountPageCustomerDataQuery = {
  __typename?: 'query_root';
  Customer: Array<{
    __typename?: 'Customer';
    lastName: string | null;
    firstName: string | null;
    sellerName: string | null;
    profilePictureShopifyCdnUrl: string | null;
    createdAt: any;
    favorites: Array<{
      __typename?: 'FavoriteProducts';
      product: {
        __typename?: 'Product';
        storeProduct: {
          __typename?: 'dbt_store_exposed_product';
          firstImage: string | null;
          handle: string;
          productType: string;
          size: string | null;
          gender: string | null;
          modelYear: string | null;
          brand: string | null;
          product: {
            __typename?: 'dbt_store_base_product';
            variants: Array<{
              __typename?: 'dbt_store_base_product_variant';
              variant: {
                __typename?: 'dbt_store_exposed_product_variant';
                condition: any | null;
                price: any;
              } | null;
            }>;
          } | null;
        } | null;
      } | null;
    }>;
    purchasedOrders: Array<{
      __typename?: 'Order';
      id: string;
      totalPriceInCents: any;
      name: string;
      status: any;
      orderLines: Array<{
        __typename?: 'OrderLines';
        name: string;
        productBrand: string | null;
        productImage: string | null;
      }>;
    }>;
  }>;
};

export type FetchAccountPageVendorDataQueryVariables = Exact<{
  maxItems: InputMaybe<Scalars['Int']>;
}>;

export type FetchAccountPageVendorDataQuery = {
  __typename?: 'query_root';
  Customer: Array<{
    __typename?: 'Customer';
    onlineProducts: Array<{
      __typename?: 'Product';
      storeProduct: {
        __typename?: 'dbt_store_exposed_product';
        firstImage: string | null;
        handle: string;
        productType: string;
        size: string | null;
        gender: string | null;
        modelYear: string | null;
        brand: string | null;
        product: {
          __typename?: 'dbt_store_base_product';
          variants: Array<{
            __typename?: 'dbt_store_base_product_variant';
            variant: {
              __typename?: 'dbt_store_exposed_product_variant';
              condition: any | null;
              price: any;
            } | null;
          }>;
        } | null;
      } | null;
    }>;
    vendorSoldOrderLines: Array<{
      __typename?: 'OrderLines';
      priceInCents: any;
      name: string;
      productBrand: string | null;
      productImage: string | null;
      order: { __typename?: 'Order'; id: string; status: any; name: string };
    }>;
  }>;
};

export type FetchProductNotationQueryVariables = Exact<{
  productShopifyId: InputMaybe<Scalars['bigint']>;
}>;

export type FetchProductNotationQuery = {
  __typename?: 'query_root';
  Product: Array<{
    __typename?: 'Product';
    manualNotation: any | null;
    source: string | null;
    sourceUrl: string | null;
  }>;
  dbt_store_product_for_analytics: Array<{
    __typename?: 'dbt_store_product_for_analytics';
    created_at: any;
    vendor_notation: any | null;
    calculated_notation: any | null;
    calculated_notation_beta: any | null;
  }>;
};

export type FetchProductHitDataQueryVariables = Exact<{
  productId: InputMaybe<Scalars['String']>;
}>;

export type FetchProductHitDataQuery = {
  __typename?: 'query_root';
  Product: Array<{ __typename?: 'Product'; manualNotation: any | null }>;
  dbt_store_product_for_analytics: Array<{
    __typename?: 'dbt_store_product_for_analytics';
    vendor_notation: any | null;
    calculated_notation: any | null;
    calculated_notation_beta: any | null;
    views_last_30_days: any;
    created_at: any;
    calculated_scoring: any;
  }>;
};

export type FetchCollectionPageDataQueryVariables = Exact<{
  collectionHandle: Scalars['String'];
  vendorSellerName: Scalars['String'];
}>;

export type FetchCollectionPageDataQuery = {
  __typename?: 'query_root';
  Collection: Array<{
    __typename?: 'Collection';
    shopifyId: string;
    handle: string;
    type: any | null;
    description: string | null;
    title: string | null;
    featuredImageSrc: string | null;
    seoTitle: string | null;
    seoDescription: string | null;
    parentCollection: {
      __typename?: 'Collection';
      shortName: string | null;
      handle: string;
      shopifyId: string;
      title: string | null;
      childCollections: Array<{
        __typename?: 'Collection';
        handle: string;
        shortName: string | null;
        shopifyId: string;
        title: string | null;
      }>;
      parentCollection: {
        __typename?: 'Collection';
        shortName: string | null;
        handle: string;
        shopifyId: string;
        title: string | null;
        parentCollection: {
          __typename?: 'Collection';
          shortName: string | null;
          handle: string;
          shopifyId: string;
          title: string | null;
        } | null;
      } | null;
    } | null;
    childCollections: Array<{
      __typename?: 'Collection';
      shortName: string | null;
      handle: string;
      title: string | null;
      featuredImageSrc: string | null;
    }>;
  }>;
  vendorData: Array<{
    __typename?: 'Customer';
    sellerName: string | null;
    coverPictureShopifyCdnUrl: string | null;
    description: string | null;
    profilePictureShopifyCdnUrl: string | null;
    VendorReviews: Array<{
      __typename?: 'VendorReview';
      Review: {
        __typename?: 'Review';
        content: string | null;
        createdAt: any;
        id: string;
        rating: number;
        title: string;
        authorNickname: string | null;
        Customer: {
          __typename?: 'Customer';
          createdAt: any;
          sellerName: string | null;
          profilePictureShopifyCdnUrl: string | null;
        };
      };
    }>;
  }>;
};

export type CheckExistingCustomerQueryVariables = Exact<{
  customerId: InputMaybe<Scalars['String']>;
}>;

export type CheckExistingCustomerQuery = {
  __typename?: 'query_root';
  Customer: Array<{ __typename?: 'Customer'; authUserId: any }>;
};

export type FetchFavoriteProductsQueryVariables = Exact<{
  [key: string]: never;
}>;

export type FetchFavoriteProductsQuery = {
  __typename?: 'query_root';
  FavoriteProducts: Array<{ __typename?: 'FavoriteProducts'; productId: any }>;
};

export type AddFavoriteProductMutationVariables = Exact<{
  customerId: Scalars['uuid'];
  productId: InputMaybe<Scalars['bigint']>;
}>;

export type AddFavoriteProductMutation = {
  __typename?: 'mutation_root';
  insert_FavoriteProducts_one: {
    __typename?: 'FavoriteProducts';
    id: string;
  } | null;
};

export type RemoveFavoriteProductsMutationVariables = Exact<{
  customerId: Scalars['uuid'];
  productId: InputMaybe<Scalars['bigint']>;
}>;

export type RemoveFavoriteProductsMutation = {
  __typename?: 'mutation_root';
  delete_FavoriteProducts: {
    __typename?: 'FavoriteProducts_mutation_response';
    affected_rows: number;
  } | null;
};

export type UpdateCustomerInfoMutationVariables = Exact<{
  userId: InputMaybe<Scalars['uuid']>;
  lastName: Scalars['String'];
  firstName: Scalars['String'];
  sellerName: Scalars['String'];
  phoneNumber: Scalars['String'];
}>;

export type UpdateCustomerInfoMutation = {
  __typename?: 'mutation_root';
  update_Customer: {
    __typename?: 'Customer_mutation_response';
    affected_rows: number;
  } | null;
};

export type UpdateDisplayNameMutationVariables = Exact<{
  userId: InputMaybe<Scalars['uuid']>;
  displayName: Scalars['String'];
}>;

export type UpdateDisplayNameMutation = {
  __typename?: 'mutation_root';
  updateUsers: {
    __typename?: 'users_mutation_response';
    affected_rows: number;
  } | null;
};

export type FetchProductMetadataQueryVariables = Exact<{
  productHandle: InputMaybe<Scalars['String']>;
}>;

export type FetchProductMetadataQuery = {
  __typename?: 'query_root';
  shopify: {
    __typename?: 'shopifyQueryRoot';
    product: {
      __typename?: 'shopify_Product';
      productType: string;
      featuredImage: {
        __typename?: 'shopify_Image';
        src: any;
        width: number | null;
        height: number | null;
      } | null;
      seo: {
        __typename?: 'shopify_SEO';
        description: string | null;
        title: string | null;
      };
    } | null;
  } | null;
};
